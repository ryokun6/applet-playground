{
  "content": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n    <link rel=\"stylesheet\" href=\"https://os.ryo.lu/fonts/fonts.css\">\n    <!-- ts=1763051833299 --> \n    \n    <script src=\"https://cdn.tailwindcss.com/3.4.16\"></script>\n    <script>\n      tailwind.config = {\n        theme: {\n          extend: {\n            fontFamily: {\n              sans: [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"sans-serif\"],\n              mono: [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"ui-monospace\", \"SFMono-Regular\", \"Menlo\", \"Monaco\", \"Consolas\", \"Liberation Mono\", \"Courier New\", \"monospace\"],\n              serif: [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"SerenityOS-Emoji\", \"serif\"],\n              emoji: [\"SerenityOS-Emoji\", \"AppleColorEmoji\", \"AppleColorEmojiFallback\"],\n              'geneva': [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"system-ui\", \"-apple-system\", \"sans-serif\"],\n              'mondwest': [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"serif\"],\n              'neuebit': [\"NeueBit\", \"ArkPixel\", \"SerenityOS-Emoji\", \"Helvetica\", \"Arial\", \"Hiragino Sans\", \"sans-serif\"],\n              'monaco': [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"monospace\"],\n              'jacquard': [\"Jacquard\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"serif\"]\n            }\n          }\n        }\n      }\n    </script>\n  <style>\n    * {\n      box-sizing: border-box;\n      \n    }\n    html, body {\n      margin: 0;\n      overflow-x: auto; /* Allow horizontal scroll if content overflows */\n      width: 100%;\n      height: 100%;\n      max-width: 100%; /* Prevent body from exceeding viewport width */\n      \n    }\n    \n    /* Ensure pre doesn't break layout */\n    pre {\n      white-space: pre-wrap; /* Allow wrapping */\n      word-break: break-all; /* Break long words */\n    }\n  </style>\n  \n  <!-- Move click interceptor script to head for earlier execution -->\n  <script>\n    document.addEventListener('DOMContentLoaded', function() {\n      document.addEventListener('click', function(event) {\n        var targetElement = event.target.closest('a');\n        // Only intercept if it's a valid link and NOT inside the draggable toolbar\n        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            // Resolve relative URLs against the document's base URI (if set) or window location\n            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;\n            // Use a specific message type for AI HTML navigation\n            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');\n            console.log('Intercepted link click:', absoluteUrl);\n          } catch (e) { console.error(\"Error resolving/posting URL:\", e); }\n        }\n      }, true); // Use capture phase to intercept early\n    });\n    \n    // Also add immediate execution version for documents that load quickly\n    // This helps ensure we don't miss any clicks during initial page load\n    (function() {\n      document.addEventListener('click', function(event) {\n        var targetElement = event.target.closest('a');\n        // Only intercept if it's a valid link and NOT inside the draggable toolbar\n        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            // Resolve relative URLs against the document's base URI (if set) or window location\n            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;\n            // Use a specific message type for AI HTML navigation\n            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');\n            console.log('Intercepted link click (immediate handler):', absoluteUrl);\n          } catch (e) { console.error(\"Error resolving/posting URL:\", e); }\n        }\n      }, true); // Use capture phase to intercept early\n    })();\n  </script>\n \n</head>\n<body>\n  <div class=\"w-full h-screen bg-neutral-900 text-neutral-100 font-geneva flex flex-col overflow-hidden\">\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-2 flex items-center justify-between flex-shrink-0\">\n    <div class=\"flex items-center gap-3\">\n      <button id=\"menuBtn\" class=\"text-sm text-neutral-300 hover:text-neutral-100 transition-colors\">‚ò∞</button>\n      <div class=\"flex items-center gap-1\">\n        <div class=\"text-sm text-neutral-400\">\n          <input id=\"cityName\" type=\"text\" value=\"new city\" class=\"bg-transparent border-none outline-none text-white cursor-pointer hover:bg-neutral-700 px-1 rounded transition-colors\">\n        </div>\n        <button id=\"speedToggle\" class=\"text-xs text-neutral-300 hover:text-neutral-100 transition-colors\">‚è∏</button>\n      </div>\n    </div>\n    \n    <div class=\"flex items-center gap-3\">\n      <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"rciBtn\">\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"rDemand\" class=\"w-full bg-green-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"cDemand\" class=\"w-full bg-blue-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"iDemand\" class=\"w-full bg-yellow-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n      </div>\n      \n      <div class=\"flex items-center gap-3 text-xs\">\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"popBtn\">\n          <span class=\"text-neutral-500\">‚òª</span>\n          <span id=\"population\" class=\"text-white tabular-nums\">0</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"moneyBtn\">\n          <span class=\"text-neutral-500\">$</span>\n          <span id=\"money\" class=\"text-white tabular-nums\">50k</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"happyBtn\">\n          <span class=\"text-neutral-500\">‚ô•</span>\n          <span id=\"happiness\" class=\"text-white tabular-nums\">70</span>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-1.5 flex items-center gap-3 text-xs flex-shrink-0\">\n    <div id=\"yearDisplay\" class=\"text-neutral-400 font-mono tabular-nums\">1990</div>\n    <div class=\"flex-1 overflow-hidden relative\" style=\"height: 1.25rem; line-height: 1.25rem;\">\n      <div id=\"newsTicker\" class=\"text-neutral-300 whitespace-nowrap absolute left-0 transition-all duration-500\" style=\"line-height: 1.25rem;\"></div>\n    </div>\n  </div>\n\n  <div id=\"menu\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-3 flex-shrink-0\">\n    <div class=\"space-y-3\">\n      <div class=\"flex items-start gap-3\">\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">view</div>\n          <div class=\"flex items-center gap-1\">\n            <button id=\"zoomOutBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">‚àí</button>\n            <div id=\"zoomLevel\" class=\"text-xs text-neutral-300 tabular-nums px-2\">100%</div>\n            <button id=\"zoomInBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">+</button>\n          </div>\n        </div>\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">settings</div>\n          <label class=\"flex items-center gap-2 px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors cursor-pointer\">\n            <input id=\"disastersToggle\" type=\"checkbox\" checked class=\"w-4 h-4 accent-green-600\">\n            <span>disasters</span>\n          </label>\n        </div>\n      </div>\n      <div class=\"flex items-center gap-2\">\n        <button id=\"aiSuggestBtn\" class=\"flex-1 text-left px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors flex items-center gap-2\">\n          <span>ask AI mayor for advice</span>\n        </button>\n        <button id=\"newCityBtn\" class=\"flex-1 text-left px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors\">\n          new city\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"newGamePanel\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-4 flex-shrink-0\">\n    <div class=\"max-w-md mx-auto space-y-3\">\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">city name</label>\n        <input id=\"newCityName\" type=\"text\" value=\"\" placeholder=\"new city\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none focus:border-neutral-500\">\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">terrain type</label>\n        <select id=\"terrainType\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"balanced\">balanced</option>\n          <option value=\"island\">island</option>\n          <option value=\"valley\">valley</option>\n          <option value=\"plains\">plains</option>\n        </select>\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">difficulty</label>\n        <select id=\"difficulty\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"easy\">easy ($100k)</option>\n          <option value=\"normal\" selected>normal ($50k)</option>\n          <option value=\"hard\">hard ($20k)</option>\n        </select>\n      </div>\n      <button id=\"startGameBtn\" class=\"w-full bg-green-700 hover:bg-green-600 text-white px-4 py-2 rounded text-sm transition-colors\">\n        start game\n      </button>\n    </div>\n  </div>\n\n  <div class=\"flex-1 overflow-hidden flex\">\n    <div id=\"grid\" class=\"flex-1 overflow-auto p-4 relative\">\n      <canvas id=\"canvas\" class=\"rounded\" style=\"image-rendering: pixelated;\"></canvas>\n    </div>\n\n    <div class=\"flex flex-shrink-0 relative\">\n      <div id=\"subToolbar\" class=\"hidden absolute right-[calc(100%+1px)] w-14 border-r border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto rounded-lg z-10\"></div>\n      <div class=\"w-14 border-l border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto flex-shrink-0\" id=\"mainToolbar\">\n        <button data-tool=\"road\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üõ£Ô∏è</button>\n        <button data-tool=\"residential\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè†</button>\n        <button data-tool=\"commercial\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè¢</button>\n        <button data-tool=\"industrial\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè≠</button>\n        <button data-submenu=\"park\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üå≥</button>\n        <button data-tool=\"police\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üëÆ</button>\n        <button data-tool=\"fire\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üöí</button>\n        <button data-tool=\"school\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè´</button>\n        <button data-tool=\"hospital\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè•</button>\n        <div class=\"w-full flex flex-col\">\n          <div class=\"h-1\"></div>\n          <div class=\"h-px w-full bg-neutral-700\"></div>\n          <div class=\"h-1\"></div>\n        </div>\n        <button data-tool=\"bulldoze\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üí•</button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"aiPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0\">\n    <div class=\"flex items-start gap-2 mb-2\">\n      <div class=\"flex-1\">\n        <div class=\"text-xs text-yellow-500 mb-1\">AI Mayor</div>\n        <div id=\"aiMessage\" class=\"text-sm text-neutral-300 leading-relaxed\"></div>\n      </div>\n      <button id=\"closeAiBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n    </div>\n  </div>\n\n  <div id=\"infoPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0\">\n    <div class=\"flex items-start gap-2 mb-2\">\n      <div class=\"flex-1\">\n        <div class=\"text-xs text-blue-400 mb-1\" id=\"infoTitle\">Info</div>\n        <div id=\"infoContent\" class=\"text-sm text-neutral-300 leading-relaxed space-y-1\"></div>\n      </div>\n      <button id=\"closeInfoBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n    </div>\n  </div>\n\n  <div class=\"border-t border-neutral-700 bg-neutral-800 px-3 py-2 text-xs text-neutral-400 flex items-center justify-between flex-shrink-0\">\n    <div id=\"statusText\">select a tool to start building</div>\n    <div id=\"costText\" class=\"text-neutral-500\"></div>\n  </div>\n</div>\n\n<style>\n@keyframes tickerRollUp {\n  0% { transform: translateY(0); opacity: 1; }\n  100% { transform: translateY(-100%); opacity: 0; }\n}\n@keyframes shake {\n  0%, 100% { transform: translate(0, 0); }\n  10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 1px); }\n  20%, 40%, 60%, 80% { transform: translate(2px, -1px); }\n}\n.ticker-roll { animation: tickerRollUp 0.5s ease-out forwards; }\n.earthquake { animation: shake 0.5s ease-in-out; }\n@media (hover: hover) and (pointer: fine) {\n  .tool-btn:hover { background-color: rgb(64, 64, 64); }\n  .tool-btn[data-tool=\"bulldoze\"]:hover { background-color: rgb(127, 29, 29); }\n  .tool-btn.submenu-active:hover { background-color: rgb(127, 29, 29); }\n}\n</style>\n\n<script>\nconst GR_SZ = 32, CL_SZ = 16;\nlet TK_INT = 2000, tkTmr = null, aiReq = false, edtNm = false, nwsIdx = 0, tkrTmr = null, trans = false, nwsQ = [];\nconst COSTS = {road:100,residential:500,commercial:800,industrial:1000,park:300,park2:300,park3:300,park4:300,police:2000,fire:2000,school:3000,hospital:4000};\nconst LAND_VALUE_LOW_COLOR = {r:250,g:204,b:21};\nconst LAND_VALUE_HIGH_COLOR = {r:34,g:197,b:94};\n\nlet st = {cityName:'new city',money:50000,population:0,happiness:70,grid:[],terrain:[],landValue:[],crime:[],crimeEvents:[],selectedTool:null,tickCount:0,speed:3000,rDemand:50,cDemand:50,iDemand:50,year:1990,newsEvents:[],ticksSinceNews:0,fires:[],employment:0,cars:[],zoom:1,disastersEnabled:true};\nlet showLandValueOverlay = false;\nlet showCrimeOverlay = false;\n\nconst cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d');\ncvs.width = GR_SZ * CL_SZ; cvs.height = GR_SZ * CL_SZ;\n\nfunction genTerr(t) {\n  const tr = [];\n  for (let y=0; y<GR_SZ; y++) { const r=[]; for (let x=0; x<GR_SZ; x++) r.push('grass'); tr.push(r); }\n  if (t==='island') {\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const dx=x-GR_SZ/2, dy=y-GR_SZ/2, d=Math.sqrt(dx*dx+dy*dy), n=(Math.sin(x*0.3)+Math.cos(y*0.3))*2;\n      if (d+n>GR_SZ/2.3) tr[y][x]='water';\n    }\n    for (let i=0; i<3; i++) {\n      const cx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), cy=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-cx, dy=y-cy, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<3 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  } else if (t==='valley') {\n    for (let y=0; y<GR_SZ; y++) {\n      const cd=Math.abs(y-GR_SZ/2), th=GR_SZ/4+Math.sin(y*0.2)*2;\n      if (cd>th) for (let x=0; x<GR_SZ; x++) tr[y][x]='cliff';\n    }\n    const ry=Math.floor(GR_SZ/2);\n    for (let x=0; x<GR_SZ; x++) {\n      const of=Math.floor(Math.sin(x*0.3)*3), r=ry+of;\n      if (r>=0 && r<GR_SZ) { tr[r][x]='water'; if (r-1>=0 && Math.random()<0.5) tr[r-1][x]='water'; if (r+1<GR_SZ && Math.random()<0.5) tr[r+1][x]='water'; }\n    }\n  } else if (t==='plains') {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<4) tr[y][x]='water';\n      }\n    }\n  } else {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<3.5) tr[y][x]='water';\n      }\n    }\n    for (let i=0; i<2; i++) {\n      const mx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), my=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-mx, dy=y-my, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<2.5 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  }\n  return tr;\n}\n\n// Helper function to ensure empty cells are always 1x1\nfunction normalizeEmptyCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return;\n  const c=st.grid[y][x];\n  if (c.type==='empty' && ((c.w||1)!==1 || (c.h||1)!==1)) {\n    st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1};\n  }\n}\n\nfunction initGr(tt='balanced') {\n  st.grid=[]; st.terrain=genTerr(tt); st.landValue=[]; st.crime=[]; st.fires=[]; st.cars=[]; st.crimeEvents=[];\n  for (let y=0; y<GR_SZ; y++) {\n    const r=[], vr=[], cr=[];\n    for (let x=0; x<GR_SZ; x++) { r.push({type:'empty',age:0,level:0,w:1,h:1}); vr.push(50); cr.push(30); }\n    st.grid.push(r); st.landValue.push(vr); st.crime.push(cr);\n  }\n}\n\nfunction sv() { try { localStorage.setItem('simcity_state',JSON.stringify(st)); } catch(e) {} }\nfunction ld() {\n  try {\n    const s=localStorage.getItem('simcity_state');\n    if (s) {\n      const p=JSON.parse(s);\n      if (p.grid && p.grid.length===GR_SZ) {\n        st=p;\n        if (!st.rDemand) st.rDemand=50; if (!st.cDemand) st.cDemand=50; if (!st.iDemand) st.iDemand=50;\n        if (!st.year) st.year=1990; if (!st.newsEvents) st.newsEvents=[]; if (!st.ticksSinceNews) st.ticksSinceNews=0;\n        if (!st.terrain) st.terrain=genTerr('balanced'); if (!st.landValue) { st.landValue=[]; for (let y=0; y<GR_SZ; y++) { const vr=[]; for (let x=0; x<GR_SZ; x++) vr.push(50); st.landValue.push(vr); } }\n        if (!st.crime) { st.crime=[]; for (let y=0; y<GR_SZ; y++) { const cr=[]; for (let x=0; x<GR_SZ; x++) cr.push(30); st.crime.push(cr); } }\n        if (!st.fires) st.fires=[]; if (!st.employment) st.employment=0; if (!st.cars) st.cars=[]; if (!st.crimeEvents) st.crimeEvents=[];\n        if (!st.zoom) st.zoom=1;\n        if (st.disastersEnabled === undefined) st.disastersEnabled = true;\n        for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) { \n          if (!st.grid[y][x].level) st.grid[y][x].level=0; \n          if (!st.grid[y][x].w) st.grid[y][x].w=1; \n          if (!st.grid[y][x].h) st.grid[y][x].h=1; \n          // Normalize empty cells to ensure they're always 1x1\n          if (st.grid[y][x].type==='empty') normalizeEmptyCell(x,y);\n        }\n        return true;\n      }\n    }\n  } catch(e) {}\n  return false;\n}\n\nfunction isRd(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].type==='road'; }\nfunction getRdNb(x,y) { return {top:isRd(x,y-1),right:isRd(x+1,y),bottom:isRd(x,y+1),left:isRd(x-1,y)}; }\n\nfunction drRd(px,py,nb) {\n  ctx.fillStyle='#3a3a3a'; ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);\n  ctx.fillStyle='#4a4a4a';\n  if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }\n  else if (rc===3) {\n    if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }\n    else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n  } else if (rc===2) {\n    if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n    else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }\n    else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }\n  } else if (rc===1) {\n    if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n  } else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n}\n\nfunction drTl(x,y,tp,lv,ab,w,h) {\n  const px=x*CL_SZ, py=y*CL_SZ, wd=w*CL_SZ, ht=h*CL_SZ, tr=st.terrain[y][x];\n  if (tp==='empty') {\n    if (tr==='water') ctx.fillStyle='#1e40af'; \n    else if (tr==='cliff') ctx.fillStyle='#3e2723'; \n    else ctx.fillStyle='#2d5016';\n    ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  } else if (tp==='road') { \n    const nb=getRdNb(x,y); drRd(px,py,nb); \n  }\n  else if (tp==='residential') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,124,89,0.5)'; \n      ctx.fillRect(px+3,py+3,wd-6,ht-6); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-6, bh=ht-6; \n      ctx.fillRect(px+3,py+5,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+3,py+5,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+Math.floor(5+bh*0.35),2,2); \n      ctx.fillRect(px+9,py+Math.floor(5+bh*0.35),2,2); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(5+bh*0.35),2,2); \n    }\n    else {\n      const sz=w===2?wd-4:(lv===1?8:10), of=w===2?2:(lv===1?4:3), bh=w===2?ht-7:(lv===1?8:10);\n      ctx.fillStyle=w===2?'#16a34a':(lv===3?'#22c55e':(lv===2?'#16a34a':'#15803d')); \n      ctx.fillRect(px+of,py+6,sz,bh);\n      ctx.fillStyle=w===2?'#15803d':(lv===3?'#16a34a':'#15803d'); \n      ctx.fillRect(px+of,py+6,sz,Math.floor(bh*0.25));\n      if (lv>=2 || w===2) {\n        ctx.fillStyle='#4ade80';\n        const wh=2, ww=2, gap=1;\n        const floors = w===2&&h===1?1:(lv===3?2:(lv===2?2:1));\n        for (let f=0; f<floors; f++) {\n          const wy = py+Math.floor(6+bh*0.4)+(f*(wh+gap+1));\n          ctx.fillRect(px+5,wy,ww,wh); \n          ctx.fillRect(px+9,wy,ww,wh);\n          if (w===2) { \n            ctx.fillRect(px+20,wy,ww,wh); \n            ctx.fillRect(px+24,wy,ww,wh); \n          }\n        }\n      } else if (lv===1) {\n        ctx.fillStyle='#4ade80';\n        const wy = py+Math.floor(6+bh*0.4);\n        ctx.fillRect(px+5,wy,2,2); \n        ctx.fillRect(px+9,wy,2,2);\n      }\n      ctx.fillStyle='#166534'; \n      ctx.fillRect(px+6,py+ht-3,3,3); \n      if (w===2) ctx.fillRect(px+21,py+ht-3,3,3);\n    }\n  } else if (tp==='commercial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,107,138,0.5)'; \n      ctx.fillRect(px+2,py+2,wd-4,ht-4); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-4; \n      ctx.fillRect(px+2,py+4,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+4,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+4,py+Math.floor(4+bh*0.4),3,3); \n      ctx.fillRect(px+9,py+Math.floor(4+bh*0.4),3,3); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(4+bh*0.4),3,3); \n    }\n    else {\n      const bh=w===2||h===2?ht-3:(lv===1?9:(lv===2?11:13)), yo=w===2||h===2?2:(lv===1?4:(lv===2?2:1));\n      ctx.fillStyle=w===2||h===2?'#2563eb':(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')); \n      ctx.fillRect(px+2,py+yo+1,wd-4,bh);\n      ctx.fillStyle=w===2||h===2?'#1e40af':(lv===3?'#2563eb':'#1e40af'); \n      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));\n      ctx.fillStyle='#87ceeb';\n      const wh=3, ww=3;\n      const floors = w===2&&h===1?1:(w===2||h===2?2:1);\n      for (let f=0; f<floors; f++) {\n        const wy = py+Math.floor((yo+1)+bh*0.4)+(f*5);\n        ctx.fillRect(px+4,wy,ww,wh); \n        ctx.fillRect(px+9,wy,ww,wh);\n        if (w===2) { \n          ctx.fillRect(px+20,wy,ww,wh); \n          ctx.fillRect(px+25,wy,ww,wh); \n        }\n      }\n      ctx.fillStyle='#1e3a8a'; \n      ctx.fillRect(px+6,py+ht-4,4,4); \n      if (w===2) ctx.fillRect(px+22,py+ht-4,4,4);\n    }\n  } else if (tp==='industrial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(138,124,74,0.5)'; \n      ctx.fillRect(px+2,py+3,wd-4,ht-6); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-6; \n      ctx.fillRect(px+2,py+6,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+6,bw,Math.floor(bh*0.4)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+11,2,2); \n      ctx.fillRect(px+9,py+11,2,2); \n      if (w===2) ctx.fillRect(px+21,py+11,2,2); \n    }\n    else {\n      const bh=w===2?ht-4:(lv===1?8:(lv===2?10:11)), yo=w===2?3:(lv===1?5:(lv===2?4:3));\n      // Main building body\n      ctx.fillStyle=w===2?'#ca8a04':(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')); \n      ctx.fillRect(px+2,py+yo+1,wd-4,bh);\n      // Slanted roof (darker top section)\n      ctx.fillStyle=w===2?'#a16207':(lv===3?'#ca8a04':'#854d0e'); \n      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));\n      // Chimney structure\n      ctx.fillStyle='#6b4423'; \n      const ch=lv===3?6:5; \n      ctx.fillRect(px+4,py+yo-ch+1,2,ch); \n      if (w===2) ctx.fillRect(px+26,py+yo-ch+1,2,ch);\n      // Chimney top cap\n      ctx.fillStyle='#854d0e'; \n      ctx.fillRect(px+3,py+yo-ch+1,4,1); \n      if (w===2) ctx.fillRect(px+25,py+yo-ch+1,4,1);\n      // Smoke from chimney\n      ctx.fillStyle='#9ca3af'; \n      ctx.fillRect(px+4,py+yo-ch,1,1); \n      ctx.fillRect(px+5,py+yo-ch-1,1,1); \n      if (w===2) { \n        ctx.fillRect(px+26,py+yo-ch,1,1); \n        ctx.fillRect(px+27,py+yo-ch-1,1,1); \n      }\n      // Windows\n      ctx.fillStyle='#fde047'; \n      if (w===2 && h===2) {\n        // Two rows of windows for 2x2 buildings\n        const wy1 = py+yo+Math.floor(bh*0.4);\n        const wy2 = py+yo+Math.floor(bh*0.58);\n        ctx.fillRect(px+5,wy1,2,2); \n        ctx.fillRect(px+9,wy1,2,2); \n        ctx.fillRect(px+21,wy1,2,2); \n        ctx.fillRect(px+25,wy1,2,2);\n        ctx.fillRect(px+5,wy2,2,2); \n        ctx.fillRect(px+9,wy2,2,2); \n        ctx.fillRect(px+21,wy2,2,2); \n        ctx.fillRect(px+25,wy2,2,2);\n      } else {\n        // Single row of windows for smaller buildings\n        ctx.fillRect(px+5,py+yo+Math.floor(bh*0.55),2,2); \n        ctx.fillRect(px+9,py+yo+Math.floor(bh*0.55),2,2); \n        if (w===2) { \n          ctx.fillRect(px+21,py+yo+Math.floor(bh*0.55),2,2); \n          ctx.fillRect(px+25,py+yo+Math.floor(bh*0.55),2,2); \n        }\n      }\n      // Entrance/door\n      ctx.fillStyle='#713f12'; \n      ctx.fillRect(px+6,py+ht-3,4,3); \n      if (w===2) ctx.fillRect(px+22,py+ht-3,4,3);\n    }\n  } else if (tp.startsWith('park')) {\n    const bc=tp==='park'?'#1d6b2e':(tp==='park2'?'#2a5a3a':(tp==='park3'?'#1a5a2a':'#2d6b1e'));\n    ctx.fillStyle=bc; ctx.fillRect(px,py,wd,ht);\n    if (tp==='park') { \n      ctx.fillStyle='#2a8f3f'; \n      ctx.fillRect(px+4,py+3,3,3); \n      ctx.fillRect(px+9,py+8,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+5,3,3); \n        ctx.fillRect(px+15,py+20,3,3); \n      } \n      ctx.fillStyle='#165a24'; \n      ctx.fillRect(px+2,py+9,2,2); \n      ctx.fillRect(px+11,py+4,2,2); \n      ctx.fillStyle='#6b4423'; \n      ctx.fillRect(px+7,py+6,2,4); \n      if (w===2||h===2) ctx.fillRect(px+23,py+10,2,4); \n    }\n    else if (tp==='park2') { \n      ctx.fillStyle='#ff69b4'; \n      ctx.fillRect(px+4,py+4,2,2); \n      ctx.fillRect(px+9,py+7,2,2); \n      ctx.fillRect(px+6,py+10,2,2); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+6,2,2); \n        ctx.fillRect(px+25,py+9,2,2); \n        ctx.fillRect(px+17,py+20,2,2); \n      } \n      ctx.fillStyle='#ffc0cb'; \n      ctx.fillRect(px+11,py+5,1,1); \n      ctx.fillRect(px+3,py+8,1,1); \n    }\n    else if (tp==='park3') { \n      ctx.fillStyle='#2d5016'; \n      ctx.fillRect(px+5,py+2,3,4); \n      ctx.fillRect(px+10,py+8,3,4); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+4,3,4); \n        ctx.fillRect(px+16,py+20,3,4); \n      } \n      ctx.fillStyle='#1a4010'; \n      ctx.fillRect(px+3,py+10,2,3); \n      ctx.fillRect(px+12,py+5,2,3); \n    }\n    else { \n      ctx.fillStyle='#ffd700'; \n      ctx.fillRect(px+5,py+5,3,3); \n      ctx.fillRect(px+10,py+9,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+7,3,3); \n        ctx.fillRect(px+16,py+20,3,3); \n      } \n      ctx.fillStyle='#8b4513'; \n      ctx.fillRect(px+6,py+8,1,3); \n      ctx.fillRect(px+11,py+12,1,3); \n    }\n  } else if (tp==='police') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#000080'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#0000a0'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#ff0000'; ctx.fillRect(px+6,py+5,4,1); \n    ctx.fillStyle='#0000ff'; ctx.fillRect(px+6,py+6,4,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='fire') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#8b0000'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#a00000'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#444444'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#ff4500'; ctx.fillRect(px+6,py+5,4,2); \n    ctx.fillStyle='#ffd700'; ctx.fillRect(px+7,py+6,2,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='school') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#daa520'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#b8860b'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#8b4513'; ctx.fillRect(px+6,py+11,4,3); \n    ctx.fillStyle='#000000'; ctx.fillRect(px+7,py+8,2,1); \n  }\n  else if (tp==='hospital') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#dc143c'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#c01030'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#ffffff'; ctx.fillRect(px+7,py+5,2,5); ctx.fillRect(px+5,py+7,6,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,wd,ht);\n}\n\nfunction drGr() {\n  ctx.clearRect(0,0,cvs.width,cvs.height); const drn={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (drn[k]) continue;\n    const c=st.grid[y][x]; drTl(x,y,c.type,c.level||0,c.abandoned||false,c.w||1,c.h||1);\n    for (let dy=0; dy<(c.h||1); dy++) for (let dx=0; dx<(c.w||1); dx++) drn[`${x+dx},${y+dy}`]=true;\n  }\n  if (showLandValueOverlay) drawLandValueOverlay();\n  if (showCrimeOverlay) drawCrimeOverlay();\n  st.fires.forEach(f => {\n    if (f.age<20) {\n      ctx.fillStyle=f.age%4<2?'#ff4500':'#ffd700';\n      ctx.fillRect(f.x*CL_SZ+4,f.y*CL_SZ+2,8,12);\n    }\n  });\n  st.crimeEvents.forEach(evt => {\n    if (evt.age<20) {\n      ctx.fillStyle=evt.age%4<2?'#dc143c':'#ff0000';\n      ctx.fillRect(evt.x*CL_SZ+5,evt.y*CL_SZ+3,6,10);\n    }\n  });\n  st.cars.forEach(c => {\n    ctx.fillStyle=c.color;\n    ctx.fillRect(c.x,c.y,3,2);\n  });\n}\n\nfunction drawLandValueOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getLandValueOverlayColor(st.landValue[y][x]);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getLandValueOverlayColor(value) {\n  const ratio=Math.max(0,Math.min(1,(value||0)/100));\n  const r=Math.round(LAND_VALUE_LOW_COLOR.r+(LAND_VALUE_HIGH_COLOR.r-LAND_VALUE_LOW_COLOR.r)*ratio);\n  const g=Math.round(LAND_VALUE_LOW_COLOR.g+(LAND_VALUE_HIGH_COLOR.g-LAND_VALUE_LOW_COLOR.g)*ratio);\n  const b=Math.round(LAND_VALUE_LOW_COLOR.b+(LAND_VALUE_HIGH_COLOR.b-LAND_VALUE_LOW_COLOR.b)*ratio);\n  return `rgba(${r},${g},${b},0.4)`;\n}\n\nfunction setLandValueOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showLandValueOverlay=true;\n    updLV();\n    drGr();\n    return;\n  }\n  if (showLandValueOverlay) {\n    showLandValueOverlay=false;\n    drGr();\n  }\n}\n\nfunction drawCrimeOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getCrimeOverlayColor(st.crime[y][x]||30);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getCrimeOverlayColor(value) {\n  const crimeLevel=Math.max(0,Math.min(100,value||30));\n  let r, g, b;\n  if (crimeLevel>=70) {\n    // High crime: red (255,0,0) to dark red (200,0,0)\n    const ratio=(crimeLevel-70)/30;\n    r=Math.round(200+55*ratio);\n    g=0;\n    b=0;\n  } else if (crimeLevel>=30) {\n    // Medium crime: yellow (255,255,0) to red (255,0,0)\n    const ratio=(crimeLevel-30)/40;\n    r=255;\n    g=Math.round(255*(1-ratio));\n    b=0;\n  } else {\n    // Low crime: green (0,255,0) to yellow (255,255,0)\n    const ratio=crimeLevel/30;\n    r=Math.round(255*ratio);\n    g=255;\n    b=0;\n  }\n  return `rgba(${r},${g},${b},0.5)`;\n}\n\nfunction setCrimeOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showCrimeOverlay=true;\n    updCrime();\n    drGr();\n    return;\n  }\n  if (showCrimeOverlay) {\n    showCrimeOverlay=false;\n    drGr();\n  }\n}\n\nfunction findPath(sx,sy,ex,ey) {\n  const q=[{x:sx,y:sy,path:[{x:sx,y:sy}]}], vis=new Set();\n  while(q.length>0) {\n    const cur=q.shift(), k=`${cur.x},${cur.y}`;\n    if (vis.has(k)) continue;\n    vis.add(k);\n    if (cur.x===ex && cur.y===ey) return cur.path;\n    if (cur.path.length>50) continue;\n    const dirs=[[0,-1],[1,0],[0,1],[-1,0]];\n    for (const [dx,dy] of dirs) {\n      const nx=cur.x+dx, ny=cur.y+dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && !vis.has(`${nx},${ny}`)) {\n        if (st.grid[ny][nx].type==='road') {\n          q.push({x:nx,y:ny,path:[...cur.path,{x:nx,y:ny}]});\n        }\n      }\n    }\n  }\n  return null;\n}\n  \nfunction getEdgeDirection(structCell,roadCell) {\n  if (!structCell || !roadCell) return {x:0,y:0};\n  const dx=structCell.x-roadCell.x;\n  const dy=structCell.y-roadCell.y;\n  if (dx===0 && dy===0) return {x:0,y:0};\n  if (Math.abs(dx)>Math.abs(dy)) return {x:dx>0?1:-1,y:0};\n  if (Math.abs(dy)>Math.abs(dx)) return {x:0,y:dy>0?1:-1};\n  if (dx!==0) return {x:dx>0?1:-1,y:0};\n  return {x:0,y:dy>0?1:-1};\n}\n\nfunction spawnCar() {\n  const res=[], com=[], ind=[], pol=[], fir=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && !c.abandoned && hasRdAcc(x,y)) res.push({x,y});\n    else if (c.type==='commercial' && !c.abandoned && hasRdAcc(x,y)) com.push({x,y});\n    else if (c.type==='industrial' && !c.abandoned && hasRdAcc(x,y)) ind.push({x,y});\n    else if (c.type==='police' && hasRdAcc(x,y)) pol.push({x,y});\n    else if (c.type==='fire' && hasRdAcc(x,y)) fir.push({x,y});\n  }\n  if (res.length===0) return;\n  \n  let tp='normal', src, dst, clr;\n  const r=Math.random();\n  if (r<0.05 && pol.length>0) {\n    tp='police'; src=pol[Math.floor(Math.random()*pol.length)];\n    const opts=[...res,...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);\n    if (opts.length===0) return;\n    dst=opts[Math.floor(Math.random()*opts.length)];\n    clr='#2196f3';\n  } else if (r<0.1 && fir.length>0) {\n    tp='fire'; src=fir[Math.floor(Math.random()*fir.length)];\n    const opts=[...res,...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);\n    if (opts.length===0) return;\n    dst=opts[Math.floor(Math.random()*opts.length)];\n    clr='#dc143c';\n  } else {\n    src=res[Math.floor(Math.random()*res.length)];\n    const dests=[...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);\n    if (dests.length===0) return;\n    dst=dests[Math.floor(Math.random()*dests.length)];\n    const rnd=Math.random();\n    if (rnd<0.7) clr='#808080';\n    else if (rnd<0.85) clr='#a0a0a0';\n    else if (rnd<0.95) clr='#606060';\n    else clr=['#ffeb3b','#4caf50','#9c27b0'][Math.floor(Math.random()*3)];\n  }\n  \n  const rdNear=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=src.x+dx, ny=src.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdNear.push({x:nx,y:ny});\n  }\n  if (rdNear.length===0) return;\n  const start=rdNear[Math.floor(Math.random()*rdNear.length)];\n  \n  const rdEnd=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=dst.x+dx, ny=dst.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdEnd.push({x:nx,y:ny});\n  }\n  if (rdEnd.length===0) return;\n  const end=rdEnd[Math.floor(Math.random()*rdEnd.length)];\n  \n  const path=findPath(start.x,start.y,end.x,end.y);\n  if (!path || path.length<2) return;\n  \n    // Determine direction: randomly choose forward or reverse\n    const reverse=Math.random()<0.5;\n    const carPath=reverse ? [...path].reverse() : path;\n    const spawnRoad=reverse ? end : start;\n    const exitRoad=reverse ? start : end;\n    const spawnBuilding=reverse ? dst : src;\n    const exitBuilding=reverse ? src : dst;\n    \n    // Determine lane offset based on first segment direction\n    // Cars going in opposite directions should be in opposite lanes\n    let laneOffset=0;\n    const startCenterX=carPath[0].x*CL_SZ+7;\n    const startCenterY=carPath[0].y*CL_SZ+7;\n    let startX=startCenterX;\n    let startY=startCenterY;\n    \n    if (carPath.length>=2) {\n      const dx=carPath[1].x-carPath[0].x;\n      const dy=carPath[1].y-carPath[0].y;\n      \n      if (Math.abs(dx)>Math.abs(dy)) {\n        // Horizontal movement: use y offset for lanes\n        // Left-to-right (dx > 0): bottom lane (+5)\n        // Right-to-left (dx < 0): top lane (-5)\n        laneOffset=dx>0 ? 5 : -5;\n        startY+=laneOffset;\n      } else {\n        // Vertical movement: use x offset for lanes\n        // Ensure right-hand traffic: southbound (dy > 0) stays to the viewer's left (laneOffset = -5)\n        laneOffset=dy>0 ? -5 : 5;\n        startX+=laneOffset;\n      }\n    }\n    \n    const entryDir=getEdgeDirection(spawnBuilding,spawnRoad);\n    let entryTarget=null;\n    let entering=false;\n    let spawnX=startX;\n    let spawnY=startY;\n    if (entryDir.x!==0 || entryDir.y!==0) {\n      entering=true;\n      entryTarget={x:startX,y:startY};\n      if (Math.abs(entryDir.x)>=Math.abs(entryDir.y) && entryDir.x!==0) {\n        spawnX=startCenterX+entryDir.x*CAR_EDGE_OFFSET;\n        spawnY=startY;\n      } else if (entryDir.y!==0) {\n        spawnY=startCenterY+entryDir.y*CAR_EDGE_OFFSET;\n        spawnX=startX;\n      }\n    }\n    \n    const endIdx=carPath.length-1;\n    const endNode=carPath[endIdx];\n    const endCenterX=endNode.x*CL_SZ+7;\n    const endCenterY=endNode.y*CL_SZ+7;\n    let exitLaneX=endCenterX;\n    let exitLaneY=endCenterY;\n    if (carPath.length>=2) {\n      const dxLast=carPath[endIdx].x-carPath[endIdx-1].x;\n      const dyLast=carPath[endIdx].y-carPath[endIdx-1].y;\n      if (Math.abs(dxLast)>Math.abs(dyLast)) {\n        exitLaneY+=dxLast>0 ? 5 : -5;\n      } else {\n        exitLaneX+=dyLast>0 ? -5 : 5;\n      }\n    }\n    const exitDir=getEdgeDirection(exitBuilding,exitRoad);\n    let exitTarget=null;\n    if (exitDir.x!==0 || exitDir.y!==0) {\n      exitTarget={x:exitLaneX,y:exitLaneY};\n      if (Math.abs(exitDir.x)>=Math.abs(exitDir.y) && exitDir.x!==0) {\n        exitTarget.x=endCenterX+exitDir.x*CAR_EDGE_OFFSET;\n      } else if (exitDir.y!==0) {\n        exitTarget.y=endCenterY+exitDir.y*CAR_EDGE_OFFSET;\n      }\n    }\n    \n    st.cars.push({\n      x:spawnX,\n      y:spawnY,\n      path:carPath,\n      pathIdx:0,\n      color:clr,\n      type:tp,\n      laneOffset:laneOffset,\n      reverse:reverse,\n      entering:entering,\n      entryTarget:entryTarget,\n      exiting:false,\n      exitTarget:exitTarget\n    });\n}\n  \n  function updCars() {\n    st.cars=st.cars.filter(c => {\n      let remainingDist=getCarSpeedPerFrame();\n      if (remainingDist<=0) return true;\n      \n      while (remainingDist>0) {\n        let targetStage='path';\n        let tx,ty;\n        if (c.entering && c.entryTarget) {\n          targetStage='entry';\n          tx=c.entryTarget.x;\n          ty=c.entryTarget.y;\n        } else if (c.exiting && c.exitTarget) {\n          targetStage='exit';\n          tx=c.exitTarget.x;\n          ty=c.exitTarget.y;\n        } else {\n          if (c.pathIdx>=c.path.length-1) {\n            if (c.exitTarget) {\n              c.exiting=true;\n              continue;\n            }\n            return false;\n          }\n          const nextTarget=getCarSegmentTarget(c);\n          tx=nextTarget.tx;\n          ty=nextTarget.ty;\n        }\n        \n        const dx=tx-c.x, dy=ty-c.y;\n        const dist=Math.sqrt(dx*dx+dy*dy);\n        if (dist===0) {\n          if (targetStage==='entry') {\n            c.entering=false;\n            c.entryTarget=null;\n            continue;\n          }\n          if (targetStage==='exit') return false;\n          c.pathIdx++;\n          if (c.pathIdx>=c.path.length-1) {\n            if (c.exitTarget) {\n              c.exiting=true;\n              continue;\n            }\n            return false;\n          }\n          updateCarLaneOffset(c);\n          continue;\n        }\n        \n        const step=Math.min(dist,remainingDist);\n        c.x+=dx/dist*step;\n        c.y+=dy/dist*step;\n        remainingDist-=step;\n        if (step===dist) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      return true;\n    });\n    \n    const maxCars=Math.min(60,Math.floor(st.population/18)+8);\n    const populationFactor=Math.min(1,st.population/4000);\n    const totalDemand=\n      Math.max(0,(st.rDemand||0))+\n      Math.max(0,(st.cDemand||0))+\n      Math.max(0,(st.iDemand||0));\n    const demandFactor=Math.min(1,totalDemand/400);\n    const spawnChance=Math.min(0.25,0.02+0.1*populationFactor+0.08*demandFactor);\n    if (st.speed>0 && st.population>10 && st.cars.length<maxCars && Math.random()<spawnChance) {\n      spawnCar();\n      if (st.cars.length<maxCars && Math.random()<0.15) spawnCar();\n    }\n  }\n\nfunction updInpWd() {\n  const inp=document.getElementById('cityName'), tmp=document.createElement('span');\n  tmp.style.font=window.getComputedStyle(inp).font; tmp.style.visibility='hidden'; tmp.style.position='absolute'; tmp.style.whiteSpace='pre';\n  tmp.textContent=inp.value||inp.placeholder||'new city'; document.body.appendChild(tmp); inp.style.width=(tmp.offsetWidth+8)+'px'; document.body.removeChild(tmp);\n}\n\nfunction shwNxtNws() {\n  if (nwsQ.length>0 && !trans) {\n    const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=nwsQ.shift();\n    if (ot===nt) return;\n    trans=true; tk.classList.add('ticker-roll');\n    setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n      setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n        setTimeout(() => { trans=false; if (nwsQ.length>0) setTimeout(shwNxtNws,100); },500);\n      },10);\n    },500);\n    return;\n  }\n  if (st.newsEvents.length===0||trans) return;\n  const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=st.newsEvents[nwsIdx];\n  if (ot===nt) { nwsIdx=(nwsIdx+1)%st.newsEvents.length; return; }\n  trans=true; tk.classList.add('ticker-roll');\n  setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n    setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n      setTimeout(() => { trans=false; },500);\n    },10);\n  },500);\n  nwsIdx=(nwsIdx+1)%st.newsEvents.length;\n}\n\nfunction updNwsTk() {\n  if (tkrTmr) clearInterval(tkrTmr);\n  if (st.newsEvents.length>0 && st.speed>0) {\n    nwsIdx=st.newsEvents.length-1; const tk=document.getElementById('newsTicker');\n    tk.textContent=st.newsEvents[nwsIdx]; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n    nwsIdx=(nwsIdx+1)%st.newsEvents.length; tkrTmr=setInterval(shwNxtNws,5000);\n  } else {\n    const tk=document.getElementById('newsTicker');\n    if (st.speed===0) tk.textContent=st.newsEvents.length>0?st.newsEvents[st.newsEvents.length-1]:'';\n    else if (st.newsEvents.length===0) tk.textContent='';\n    tk.classList.remove('ticker-roll');\n  }\n}\n\nconst STAT_INFO_TYPES = ['rci','pop','money','happy'];\nlet currentInfoType = null;\n\nfunction shwInfo(title,content,infoType) {\n  plySnd('click');\n  const pnl=document.getElementById('infoPanel');\n  \n  // If clicking the same stat, toggle it off\n  if (currentInfoType === infoType && !pnl.classList.contains('hidden')) {\n    pnl.classList.add('hidden');\n    currentInfoType = null;\n    setLandValueOverlay(false);\n    setCrimeOverlay(false);\n    return;\n  }\n  \n  // Otherwise, show the new panel\n  document.getElementById('menu').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoTitle').textContent=title;\n  document.getElementById('infoContent').innerHTML=content;\n  pnl.classList.remove('hidden');\n  currentInfoType = infoType;\n  if (infoType === 'happy') {\n    setLandValueOverlay(false);\n    setCrimeOverlay(true);\n  } else {\n    setCrimeOverlay(false);\n    setLandValueOverlay(STAT_INFO_TYPES.includes(infoType));\n  }\n}\n\nfunction updUI() {\n  const inp=document.getElementById('cityName'); if (!edtNm) { inp.value=st.cityName; updInpWd(); }\n  document.getElementById('population').textContent=st.population.toLocaleString();\n  document.getElementById('money').textContent=`${(st.money/1000).toFixed(0)}k`;\n  document.getElementById('happiness').textContent=st.happiness;\n  if (!edtNm) document.getElementById('yearDisplay').textContent=st.year;\n  const mEl=document.getElementById('money');\n  if (st.money<0) { mEl.classList.remove('text-white'); mEl.classList.add('text-red-400'); }\n  else { mEl.classList.remove('text-red-400'); mEl.classList.add('text-white'); }\n  const rB=document.getElementById('rDemand'), cB=document.getElementById('cDemand'), iB=document.getElementById('iDemand');\n  rB.style.height=`${st.rDemand}%`; cB.style.height=`${st.cDemand}%`; iB.style.height=`${st.iDemand}%`;\n  rB.parentElement.style.display='flex'; rB.parentElement.style.flexDirection='column'; rB.parentElement.style.justifyContent='flex-end';\n  cB.parentElement.style.display='flex'; cB.parentElement.style.flexDirection='column'; cB.parentElement.style.justifyContent='flex-end';\n  iB.parentElement.style.display='flex'; iB.parentElement.style.flexDirection='column'; iB.parentElement.style.justifyContent='flex-end';\n  const sBtn=document.getElementById('speedToggle');\n  if (st.speed===0) sBtn.textContent='‚è∏'; else if (st.speed===3000) sBtn.textContent='1x'; else if (st.speed===1500) sBtn.textContent='2x'; else if (st.speed===500) sBtn.textContent='3x';\n}\n\nfunction selTl(tl) {\n  st.selectedTool=tl;\n  updateToolSelection();\n  const c=COSTS[tl]||0, cTx=document.getElementById('costText'), sTx=document.getElementById('statusText');\n  if (tl==='bulldoze') { sTx.textContent='click to demolish buildings'; cTx.textContent=''; }\n  else if (tl) { const dn=tl.startsWith('park')?'park':tl; sTx.textContent=`placing ${dn}`; cTx.textContent=c>0?`$${c.toLocaleString()}`:''; }\n  else { sTx.textContent='select a tool to start building'; cTx.textContent=''; }\n}\n\nfunction canPlLg(x,y,w,h,zt) {\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=GR_SZ||ny>=GR_SZ) return false;\n    const c=st.grid[ny][nx]; \n    // Normalize empty cells to ensure they're 1x1\n    if (c.type==='empty') normalizeEmptyCell(nx,ny);\n    // Prevent merging through roads and other incompatible tiles\n    if (c.type==='road') return false;\n    if (c.type!=='empty' && c.type!==zt && !c.abandoned) return false;\n    const tr=st.terrain[ny][nx]; if (tr==='water'||tr==='cliff') return false;\n  }\n  return true;\n}\n\n// Helper: given any cell in a building, find the building's top-left and size\nfunction getBuildingBoundsFromCell(x,y) {\n  const c=st.grid[y][x];\n  if (!c) return {startX:x,startY:y,w:1,h:1};\n  const baseW=c.w||1, baseH=c.h||1;\n\n  // Single-tile structures (including empty zones) should never sweep across\n  // adjacent tiles just because they share the same zone type. Treat them as\n  // isolated cells so bulldozing/park placement only affects the clicked tile.\n  if (baseW===1 && baseH===1) return {startX:x,startY:y,w:1,h:1};\n\n  // Expand left/right and up/down while the cell looks like the same building.\n  let startX=x, endX=x, startY=y, endY=y;\n\n  // Horizontal extent\n  for (let cx=x-1; cx>=0; cx--) {\n    const cc=st.grid[y][cx];\n    if (cc.type===c.type && (cc.w||1)===baseW && (cc.h||1)===baseH) startX=cx; else break;\n  }\n  for (let cx=x+1; cx<GR_SZ; cx++) {\n    const cc=st.grid[y][cx];\n    if (cc.type===c.type && (cc.w||1)===baseW && (cc.h||1)===baseH) endX=cx; else break;\n  }\n\n  // Vertical extent\n  for (let cy=y-1; cy>=0; cy--) {\n    const cc=st.grid[cy][x];\n    if (cc.type===c.type && (cc.w||1)===baseW && (cc.h||1)===baseH) startY=cy; else break;\n  }\n  for (let cy=y+1; cy<GR_SZ; cy++) {\n    const cc=st.grid[cy][x];\n    if (cc.type===c.type && (cc.w||1)===baseW && (cc.h||1)===baseH) endY=cy; else break;\n  }\n\n  const w=endX-startX+1;\n  const h=endY-startY+1;\n  return {startX,startY,w,h};\n}\n\nfunction isTopLeftCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false;\n  const cell=st.grid[y][x];\n  if (!cell) return false;\n  const w=cell.w||1, h=cell.h||1;\n  if (w===1 && h===1) return true;\n  if (x>0) {\n    const left=st.grid[y][x-1];\n    if (left && left.type===cell.type && (left.w||1)===w && (left.h||1)===h) return false;\n  }\n  if (y>0) {\n    const above=st.grid[y-1][x];\n    if (above && above.type===cell.type && (above.w||1)===w && (above.h||1)===h) return false;\n  }\n  return true;\n}\n\nfunction plcTl(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return; if (!st.selectedTool) return;\n  const c=st.grid[y][x], tr=st.terrain[y][x];\n  if (tr==='water'||tr==='cliff') { plySnd('error'); return; }\n  if (st.selectedTool==='bulldoze') {\n    if (c.type!=='empty') {\n      plySnd('bulldoze');\n\n      // Roads: always bulldoze a single tile only\n      if (c.type==='road') {\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1};\n        normalizeEmptyCell(x,y);\n        drGr(); sv();\n        return;\n      }\n\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n      const isEmptyZone=isZone && (c.level===0 || c.abandoned);\n      const isSmallMulti=(w===2 && h===1) || (w===1 && h===2) || (w===2 && h===2);\n\n      if (isEmptyZone || isSmallMulti) {\n        // Bulldoze the entire small merged building or empty zone\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          const nx=startX+dx, ny=startY+dy; if (nx<GR_SZ && ny<GR_SZ) {\n            st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1};\n            normalizeEmptyCell(nx,ny);\n          }\n        }\n      } else {\n        // All other buildings: only bulldoze the clicked cell\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1};\n        normalizeEmptyCell(x,y);\n      }\n\n      drGr(); sv();\n    }\n    return;\n  }\n  const isPk=st.selectedTool.startsWith('park');\n  \n  // For parks: allow placing on empty zones (level 0 or abandoned zones)\n  if (isPk) {\n    const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n    const isEmptyZone=isZone && (c.level===0 || c.abandoned);\n    if (c.type!=='empty' && !isEmptyZone) return;\n    \n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    \n    plySnd('place'); \n    st.money-=cs;\n    \n    // If replacing an empty zone, replace the entire building\n    if (isEmptyZone) {\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      // Replace all cells of the zone building with park\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=startX+dx, ny=startY+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            st.grid[ny][nx]={type:st.selectedTool,age:0,level:1,w:1,h:1};\n          }\n        }\n      }\n      // Try to merge parks after placement (from the top-left)\n      tryMrgPark(startX,startY);\n    } else {\n      // Normal placement on empty terrain\n      st.grid[y][x]={type:st.selectedTool,age:0,level:1,w:1,h:1};\n      // Try to merge with adjacent parks of the same type\n      tryMrgPark(x,y);\n    }\n  } else {\n    // For non-park tools: only allow empty or abandoned\n    if (c.type!=='empty' && !c.abandoned) return;\n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    plySnd('place'); \n    st.money-=cs;\n    st.grid[y][x]={type:st.selectedTool,age:0,level:0,w:1,h:1};\n  }\n  drGr(); updUI(); sv();\n}\n\nlet isDragging = false, dragStart = null, lastPlaced = null, isScrolling = false, touchStartPos = null, lastTouchPos = null;\n\nfunction getCarSpeedMultiplier() {\n  if (st.speed<=0) return 0;\n  if (st.speed===500) return 3;\n  if (st.speed===1500) return 2;\n  return 1;\n}\n\nconst CAR_BASE_SPEED = 1.0;\nconst CAR_EDGE_OFFSET = CL_SZ/2 - 1;\n\nfunction getCarSpeedPerFrame() {\n  return CAR_BASE_SPEED * getCarSpeedMultiplier();\n}\n\nfunction updateCarLaneOffset(car) {\n  if (car.pathIdx>=car.path.length-1) return;\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    if (Math.abs(dxSeg)>Math.abs(dySeg)) {\n      car.laneOffset=dxSeg>0 ? 5 : -5;\n    } else {\n      car.laneOffset=dySeg>0 ? -5 : 5;\n    }\n}\n\nfunction getCarSegmentTarget(car) {\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  let tx=nextNode.x*CL_SZ+7;\n  let ty=nextNode.y*CL_SZ+7;\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    const horizontal=Math.abs(dxSeg)>Math.abs(dySeg);\n    if (horizontal) ty+=car.laneOffset;\n    else tx+=car.laneOffset;\n    \n    const hasNextTurn=car.pathIdx+2<car.path.length;\n    if (hasNextTurn) {\n      const afterNode=car.path[car.pathIdx+2];\n      const dxNext=afterNode.x-nextNode.x;\n      const dyNext=afterNode.y-nextNode.y;\n      const nextHorizontal=Math.abs(dxNext)>Math.abs(dyNext);\n      if (horizontal && !nextHorizontal) {\n        const nextLaneOffset=dyNext>0 ? -5 : 5;\n        tx+=nextLaneOffset;\n      } else if (!horizontal && nextHorizontal) {\n        const nextLaneOffset=dxNext>0 ? 5 : -5;\n        ty+=nextLaneOffset;\n      }\n    }\n  return {tx,ty};\n}\n\nfunction getCanvasPos(e) {\n  const r = cvs.getBoundingClientRect();\n  const sx = cvs.width / r.width, sy = cvs.height / r.height;\n  let clientX, clientY;\n  \n  if (e.touches && e.touches.length > 0) {\n    clientX = e.touches[0].clientX;\n    clientY = e.touches[0].clientY;\n    lastTouchPos = { x: clientX, y: clientY };\n  } else if (e.changedTouches && e.changedTouches.length > 0) {\n    // For touchend events\n    clientX = e.changedTouches[0].clientX;\n    clientY = e.changedTouches[0].clientY;\n  } else if (lastTouchPos) {\n    // Fallback to last known touch position\n    clientX = lastTouchPos.x;\n    clientY = lastTouchPos.y;\n  } else {\n    clientX = e.clientX;\n    clientY = e.clientY;\n  }\n  \n  const x = Math.floor((clientX - r.left) * sx / CL_SZ);\n  const y = Math.floor((clientY - r.top) * sy / CL_SZ);\n  return { x, y };\n}\n\nfunction placeLine(x0, y0, x1, y1) {\n  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;\n  let err = dx - dy, x = x0, y = y0;\n  const placed = new Set();\n  \n  while (true) {\n    const key = `${x},${y}`;\n    if (!placed.has(key)) {\n      placed.add(key);\n      plcTl(x, y);\n    }\n    if (x === x1 && y === y1) break;\n    const e2 = 2 * err;\n    if (e2 > -dy) { err -= dy; x += sx; }\n    if (e2 < dx) { err += dx; y += sy; }\n  }\n}\n\nlet lastZoneBounds = null;\n\nfunction placeZone(x0, y0, x1, y1) {\n  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);\n  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);\n  const currentBounds = `${minX},${minY},${maxX},${maxY}`;\n  \n  // Only place if bounds changed to avoid redundant work\n  if (currentBounds === lastZoneBounds) return;\n  lastZoneBounds = currentBounds;\n  \n  for (let y = minY; y <= maxY; y++) {\n    for (let x = minX; x <= maxX; x++) {\n      plcTl(x, y);\n    }\n  }\n}\n\nfunction handleDragStart(e) {\n  // On mobile (touch events), allow scrolling and only handle taps\n  if (e.touches) {\n    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n    isDragging = false;\n    isScrolling = false;\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  if (!st.selectedTool) return;\n  \n  const pos = getCanvasPos(e);\n  dragStart = pos;\n  lastPlaced = { x: pos.x, y: pos.y };\n  lastZoneBounds = null; // Reset zone bounds tracking\n  isDragging = true;\n  isScrolling = false;\n}\n\nfunction handleDragMove(e) {\n  // On mobile (touch events), allow native scrolling - don't place tiles while dragging\n  if (e.touches) {\n    if (touchStartPos) {\n      const dx = Math.abs(e.touches[0].clientX - touchStartPos.x);\n      const dy = Math.abs(e.touches[0].clientY - touchStartPos.y);\n      // If moved significantly, mark as scrolling (not a tap)\n      if (dx > 5 || dy > 5) {\n        isScrolling = true;\n      }\n    }\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  if (!st.selectedTool || !isDragging || !dragStart) return;\n  \n  const pos = getCanvasPos(e);\n  \n  // For roads: place as line\n  if (st.selectedTool === 'road') {\n    placeLine(dragStart.x, dragStart.y, pos.x, pos.y);\n    dragStart = pos; // Update start for continuous line\n  }\n  // For RCI zones: place as zone\n  else if (st.selectedTool === 'residential' || st.selectedTool === 'commercial' || st.selectedTool === 'industrial') {\n    placeZone(dragStart.x, dragStart.y, pos.x, pos.y);\n  }\n  // For other tools: place individual tiles\n  else {\n    const key = `${pos.x},${pos.y}`;\n    const lastKey = `${lastPlaced.x},${lastPlaced.y}`;\n    if (key !== lastKey) {\n      plcTl(pos.x, pos.y);\n      lastPlaced = pos;\n    }\n  }\n}\n\nfunction handleDragEnd(e) {\n  // Handle mobile tap (touch without scrolling)\n  if (e.changedTouches && touchStartPos && !isScrolling && st.selectedTool) {\n    // This was a tap, not a scroll - place a tile\n    const pos = getCanvasPos(e);\n    plcTl(pos.x, pos.y);\n  }\n  // Handle desktop mouse drag end\n  else if (isDragging && !isScrolling && dragStart && st.selectedTool && !e.touches) {\n    const pos = getCanvasPos(e);\n    // If we didn't move much (or at all), treat as click\n    const moved = Math.abs(pos.x - dragStart.x) > 0 || Math.abs(pos.y - dragStart.y) > 0;\n    if (!moved) {\n      plcTl(pos.x, pos.y);\n    }\n  }\n  \n  isDragging = false;\n  isScrolling = false;\n  dragStart = null;\n  lastPlaced = null;\n  touchStartPos = null;\n  lastTouchPos = null;\n  lastZoneBounds = null;\n}\n\n// Mouse events\ncvs.addEventListener('mousedown', handleDragStart);\ncvs.addEventListener('mousemove', handleDragMove);\ncvs.addEventListener('mouseup', handleDragEnd);\ncvs.addEventListener('mouseleave', handleDragEnd);\n\n// Touch events - passive for smooth scrolling on mobile\ncvs.addEventListener('touchstart', handleDragStart, { passive: true });\ncvs.addEventListener('touchmove', handleDragMove, { passive: true });\ncvs.addEventListener('touchend', handleDragEnd, { passive: true });\ncvs.addEventListener('touchcancel', handleDragEnd, { passive: true });\n\n// Click handler for mouse only (touch events are handled separately)\ncvs.addEventListener('click', e => {\n  // Only handle mouse clicks, not touch-generated clicks\n  if (e.detail === 0) return; // Touch events have detail = 0\n  if (!isDragging && !isScrolling && st.selectedTool) {\n    const r = cvs.getBoundingClientRect(), sx = cvs.width / r.width, sy = cvs.height / r.height;\n    const x = Math.floor((e.clientX - r.left) * sx / CL_SZ), y = Math.floor((e.clientY - r.top) * sy / CL_SZ);\n    plcTl(x, y);\n  }\n});\n\nlet activeSubmenu = null;\n\nconst submenuItems = {\n  park: [\n    { tool: 'park', icon: 'üå≥' },\n    { tool: 'park2', icon: 'üå∏' },\n    { tool: 'park3', icon: 'üå≤' },\n    { tool: 'park4', icon: 'üåª' }\n  ]\n};\n\nfunction openSubmenu(button, submenuKey) {\n  // Close any existing submenu\n  closeSubmenu();\n  \n  // Store reference to the button\n  activeSubmenu = { button, submenuKey };\n  \n  // Change button to X\n  const originalContent = button.innerHTML;\n  button.dataset.originalContent = originalContent;\n  button.innerHTML = '‚úï';\n  button.classList.add('submenu-active');\n  \n  // Get sub-toolbar\n  const subToolbar = document.getElementById('subToolbar');\n  \n  // Populate sub-toolbar with items (but keep hidden for now)\n  subToolbar.innerHTML = '';\n  const items = submenuItems[submenuKey];\n  items.forEach(item => {\n    const subBtn = document.createElement('button');\n    subBtn.className = 'tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center';\n    subBtn.dataset.tool = item.tool;\n    subBtn.textContent = item.icon;\n    subBtn.addEventListener('click', (e) => {\n      e.stopPropagation();\n      plySnd('click');\n      selTl(item.tool);\n      // Don't close submenu - keep it open so user can switch tools\n    });\n    subToolbar.appendChild(subBtn);\n  });\n  \n  // Auto-select the first tool in the submenu\n  if (items.length > 0) {\n    selTl(items[0].tool);\n  }\n  \n  // Make submenu invisible but rendered to measure it\n  subToolbar.style.visibility = 'hidden';\n  subToolbar.classList.remove('hidden');\n  \n  // Position submenu vertically centered on the toggle button\n  requestAnimationFrame(() => {\n    const parentContainer = button.closest('.flex.flex-shrink-0.relative');\n    const parentRect = parentContainer.getBoundingClientRect();\n    const buttonRect = button.getBoundingClientRect();\n    const subToolbarRect = subToolbar.getBoundingClientRect();\n    \n    // Calculate positions relative to parent container\n    const buttonTopRelative = buttonRect.top - parentRect.top;\n    const buttonCenterY = buttonTopRelative + buttonRect.height / 2;\n    const submenuHeight = subToolbarRect.height;\n    const submenuCenterY = submenuHeight / 2;\n    \n    // Calculate top position to center submenu on button\n    const topPosition = buttonCenterY - submenuCenterY;\n    subToolbar.style.top = `${topPosition}px`;\n    \n    // Now make it visible\n    subToolbar.style.visibility = '';\n    \n    updateToolSelection();\n  });\n}\n\nfunction closeSubmenu() {\n  if (activeSubmenu) {\n    // Restore original button content\n    if (activeSubmenu.button.dataset.originalContent) {\n      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;\n      activeSubmenu.button.classList.remove('submenu-active');\n    }\n    activeSubmenu = null;\n  }\n  \n  // Hide sub-toolbar and reset position\n  const subToolbar = document.getElementById('subToolbar');\n  subToolbar.classList.add('hidden');\n  subToolbar.style.top = '';\n  subToolbar.style.visibility = '';\n}\n\nfunction updateToolSelection() {\n  // Update all tool buttons including sub-toolbar buttons\n  document.querySelectorAll('.tool-btn').forEach(b => {\n    const bt = b.dataset.tool;\n    b.style.borderColor = '';\n    b.style.opacity = '';\n    if (bt === st.selectedTool) {\n      b.style.borderColor = '#666';\n      b.style.opacity = '1';\n    } else {\n      // All other unselected buttons get reduced opacity (including submenu toggle showing X)\n      b.style.opacity = '0.5';\n    }\n  });\n}\n\ndocument.querySelectorAll('.tool-btn').forEach(b => {\n  b.addEventListener('click', (e) => {\n    plySnd('click');\n    \n    // Check if this button has a submenu\n    if (b.dataset.submenu) {\n      // If submenu is already open, close it\n      if (activeSubmenu && activeSubmenu.button === b) {\n        closeSubmenu();\n      } else {\n        // Open submenu\n        openSubmenu(b, b.dataset.submenu);\n      }\n    } else if (b.dataset.tool) {\n      // Regular tool selection\n      selTl(b.dataset.tool);\n      closeSubmenu();\n    }\n  });\n});\n\nfunction centerCanvas() {\n  const gridContainer = document.getElementById('grid');\n  if (!gridContainer) return;\n  \n  // Wait for next frame to ensure layout is calculated\n  requestAnimationFrame(() => {\n    const zoom = st.zoom || 1;\n    const canvasWidth = cvs.width * zoom;\n    const canvasHeight = cvs.height * zoom;\n    const containerWidth = gridContainer.clientWidth;\n    const containerHeight = gridContainer.clientHeight;\n    \n    // If canvas is smaller than container, center it with CSS\n    if (canvasWidth <= containerWidth && canvasHeight <= containerHeight) {\n      // Center using flexbox or margin auto\n      gridContainer.style.display = 'flex';\n      gridContainer.style.justifyContent = 'center';\n      gridContainer.style.alignItems = 'center';\n      gridContainer.scrollLeft = 0;\n      gridContainer.scrollTop = 0;\n    } else {\n      // Canvas is larger, use scroll positioning\n      gridContainer.style.display = 'block';\n      gridContainer.style.justifyContent = '';\n      gridContainer.style.alignItems = '';\n      \n      // Calculate scroll position to center the canvas\n      const scrollLeft = Math.max(0, (canvasWidth - containerWidth) / 2);\n      const scrollTop = Math.max(0, (canvasHeight - containerHeight) / 2);\n      \n      gridContainer.scrollLeft = scrollLeft;\n      gridContainer.scrollTop = scrollTop;\n    }\n  });\n}\n\nfunction applyZoom() {\n  if (!st.zoom) st.zoom = 1;\n  cvs.style.transform = `scale(${st.zoom})`;\n  cvs.style.transformOrigin = 'top left';\n  document.getElementById('zoomLevel').textContent = Math.round(st.zoom * 100) + '%';\n  sv();\n  centerCanvas();\n}\n\nfunction zoomIn() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.min(3, st.zoom + 0.25);\n  applyZoom();\n}\n\nfunction zoomOut() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.max(0.25, st.zoom - 0.25);\n  applyZoom();\n}\n\nfunction zoomReset() {\n  st.zoom = 1;\n  applyZoom();\n}\n\ndocument.getElementById('zoomInBtn').addEventListener('click', () => { plySnd('click'); zoomIn(); });\ndocument.getElementById('zoomOutBtn').addEventListener('click', () => { plySnd('click'); zoomOut(); });\n\nconst inpNm=document.getElementById('cityName');\ninpNm.addEventListener('focus', () => edtNm=true);\ninpNm.addEventListener('blur', () => { edtNm=false; st.cityName=inpNm.value||'new city'; sv(); updUI(); });\ninpNm.addEventListener('input', () => updInpWd());\ninpNm.addEventListener('change', e => { st.cityName=e.target.value||'new city'; sv(); });\ninpNm.addEventListener('click', e => e.target.select());\n\ndocument.getElementById('menuBtn').addEventListener('click', () => {\n  plySnd('click'); const m=document.getElementById('menu'); m.classList.toggle('hidden');\n  document.getElementById('newGamePanel').classList.add('hidden'); \n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n});\n\ndocument.getElementById('speedToggle').addEventListener('click', () => {\n  plySnd('click');\n  if (st.speed===0) st.speed=3000; else if (st.speed===3000) st.speed=1500; else if (st.speed===1500) st.speed=500; else st.speed=0;\n  sv(); if (tkTmr) clearInterval(tkTmr);\n  if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); updNwsTk(); }\n  else updNwsTk();\n  updUI();\n});\n\ndocument.getElementById('newCityBtn').addEventListener('click', () => { \n  plySnd('click'); \n  document.getElementById('newCityName').value = '';\n  document.getElementById('menu').classList.add('hidden'); \n  document.getElementById('newGamePanel').classList.remove('hidden'); \n});\n\ndocument.getElementById('startGameBtn').addEventListener('click', () => {\n  plySnd('click');\n  const nm=document.getElementById('newCityName').value||'new city', tr=document.getElementById('terrainType').value, df=document.getElementById('difficulty').value;\n  let mn=50000; if (df==='easy') mn=100000; else if (df==='hard') mn=20000;\n  aiReq=false; initGr(tr); st.money=mn; st.population=0; st.happiness=70; st.tickCount=0; st.cityName=nm; st.rDemand=50; st.cDemand=50; st.iDemand=50; st.year=1990; st.newsEvents=['Welcome to '+nm+'!']; st.ticksSinceNews=0; st.employment=0;\n  if (!st.zoom) st.zoom=1;\n  drGr(); updUI(); updNwsTk(); sv();\n  document.getElementById('newGamePanel').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  setTimeout(centerCanvas, 100);\n});\n\ndocument.getElementById('aiSuggestBtn').addEventListener('click', async () => {\n  plySnd('click'); document.getElementById('menu').classList.add('hidden'); document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  const pnl=document.getElementById('aiPanel'), msg=document.getElementById('aiMessage');\n  pnl.classList.remove('hidden'); msg.innerHTML='<span class=\"text-neutral-500\">thinking...</span>';\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  const prm=`You are an AI mayor advisor for a SimCity-like game. Analyze the current city state and give 2-3 SHORT, actionable suggestions (1-2 sentences total).\\n\\nCurrent city stats:\\n- Money: $${st.money.toLocaleString()}\\n- Population: ${st.population}\\n- Happiness: ${st.happiness}/100\\n- Buildings: ${JSON.stringify(cnts)}\\n- RCI Demand: R=${st.rDemand}% C=${st.cDemand}% I=${st.iDemand}%\\n\\nAvailable building types: road, residential, commercial, industrial, park, police, fire, school, hospital\\n\\nGive practical advice based on what's missing or unbalanced. Keep it brief and conversational.`;\n  try {\n    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n    if (!r.ok) throw new Error('AI request failed');\n    const d=await r.json(), rp=d.reply||'everything looks good!';\n    msg.textContent=''; let i=0;\n    const tw=setInterval(() => { if (i<rp.length) { msg.textContent+=rp.charAt(i); i++; } else clearInterval(tw); },20);\n  } catch(e) { console.error('AI error:',e); msg.textContent='could not reach AI mayor. try building more infrastructure!'; }\n});\n\ndocument.getElementById('closeAiBtn').addEventListener('click', () => { plySnd('click'); document.getElementById('aiPanel').classList.add('hidden'); });\ndocument.getElementById('closeInfoBtn').addEventListener('click', () => {\n  plySnd('click');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n});\n\ndocument.getElementById('rciBtn').addEventListener('click', () => {\n  shwInfo('RCI Demand', `<div><span class=\"text-green-500\">Residential:</span> ${st.rDemand}%</div><div><span class=\"text-blue-500\">Commercial:</span> ${st.cDemand}%</div><div><span class=\"text-yellow-500\">Industrial:</span> ${st.iDemand}%</div><div class=\"mt-2 text-xs text-neutral-400\">Higher demand means more zones needed</div>`, 'rci');\n});\n\ndocument.getElementById('popBtn').addEventListener('click', () => {\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  shwInfo('Population Stats', `<div>Total: ${st.population.toLocaleString()}</div><div>Residential zones: ${cnts.residential||0}</div><div>Employment: ${st.employment}%</div><div class=\"mt-2 text-xs text-neutral-400\">Build more residential zones to grow</div>`, 'pop');\n});\n\ndocument.getElementById('moneyBtn').addEventListener('click', () => {\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  const inc=Math.floor(st.population*2), mnt=Math.floor(cnts.road*1+(cnts.residential||0)*2+(cnts.commercial||0)*3+(cnts.industrial||0)*5+(cnts.park||0)*2+(cnts.police||0)*10+(cnts.fire||0)*10+(cnts.school||0)*15+(cnts.hospital||0)*20);\n  shwInfo('Budget', `<div>Balance: $${st.money.toLocaleString()}</div><div class=\"text-green-500\">Income: +$${inc}</div><div class=\"text-red-400\">Expenses: -$${mnt}</div><div class=\"mt-2 text-xs text-neutral-400\">Income from population taxes</div>`, 'money');\n});\n\ndocument.getElementById('happyBtn').addEventListener('click', () => {\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  let avgCrime=0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    avgCrime+=st.crime[y][x]||30;\n  }\n  avgCrime=Math.floor(avgCrime/(GR_SZ*GR_SZ));\n  shwInfo('Happiness', `<div>Level: ${st.happiness}/100</div><div class=\"mt-1\">Parks: ${cnts.park||0}</div><div>Services: ${(cnts.police||0)+(cnts.fire||0)+(cnts.school||0)+(cnts.hospital||0)}</div><div class=\"mt-1\">Avg Crime: ${avgCrime}%</div><div>Active Crimes: ${st.crimeEvents.length}</div><div class=\"mt-2 text-xs text-neutral-400\">Build parks, services, and police to increase</div>`, 'happy');\n});\n\nfunction hasRdAcc(x,y) {\n  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const cx=x+dx, cy=y+dy;\n    for (let ndy=-1; ndy<=1; ndy++) for (let ndx=-1; ndx<=1; ndx++) {\n      if (ndx===0 && ndy===0) continue;\n      const nx=cx+ndx, ny=cy+ndy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='road') return true;\n    }\n  }\n  return false;\n}\n\nfunction calcLV(x,y) {\n  let v=50; const tr=st.terrain[y][x];\n  if (tr==='water') for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) { const d=Math.abs(dx)+Math.abs(dy); if (d<=2) v+=(3-d)*5; }\n  }\n  let pk=0, pl=0, sv=0;\n  for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), c=st.grid[ny][nx];\n      if (c.type.startsWith('park')) { const m=(c.w||1)*(c.h||1); pk+=(7-d)*2*m; }\n      else if (c.type==='industrial') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*2*m; }\n      else if (c.type==='police'||c.type==='fire'||c.type==='school'||c.type==='hospital') sv+=(7-d);\n    }\n  }\n  v+=Math.min(pk,30); v-=Math.min(pl,40); v+=Math.min(sv,20);\n  if (!hasRdAcc(x,y)) v-=30;\n  return Math.max(0,Math.min(100,v));\n}\n\nfunction calcCrime(x,y) {\n  let c=30; const tr=st.terrain[y][x];\n  if (tr==='water'||tr==='cliff') return 0;\n  \n  // Reduce crime near police stations (8-tile radius)\n  let policeCoverage=0;\n  for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), cell=st.grid[ny][nx];\n      if (cell.type==='police' && d<=8) {\n        policeCoverage+=(9-d)*3;\n      }\n    }\n  }\n  c-=Math.min(policeCoverage,50);\n  \n  // Increase crime in high-population areas without police coverage\n  const cell=st.grid[y][x];\n  if ((cell.type==='residential'||cell.type==='commercial') && !cell.abandoned) {\n    const popDensity=(cell.w||1)*(cell.h||1)*(cell.level||0);\n    if (policeCoverage<10) c+=popDensity*5;\n  }\n  \n  // Factor in happiness (low happiness = more crime)\n  if (st.happiness<50) c+=20;\n  else if (st.happiness<70) c+=10;\n  \n  // Increase crime if no road access\n  if (!hasRdAcc(x,y)) c+=15;\n  \n  // Check for active crime events nearby\n  for (const evt of st.crimeEvents) {\n    const dx=Math.abs(x-evt.x), dy=Math.abs(y-evt.y), d=dx+dy;\n    if (d<=3) c+=Math.max(0,(4-d)*10);\n  }\n  \n  return Math.max(0,Math.min(100,c));\n}\n\nfunction updLV() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.landValue[y][x]=calcLV(x,y); }\nfunction updCrime() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.crime[y][x]=calcCrime(x,y); }\n\nfunction calcDmd(rC,cC,iC,p) {\n  let rD=50, cD=50, iD=50; const tZ=rC+cC+iC;\n  if (tZ===0) { rD=80; cD=40; iD=40; }\n  else {\n    const iR={r:0.5,c:0.25,i:0.25}, aR={r:rC/tZ,c:cC/tZ,i:iC/tZ};\n    rD=Math.max(0,Math.min(100,50+(iR.r-aR.r)*200)); cD=Math.max(0,Math.min(100,50+(iR.c-aR.c)*200)); iD=Math.max(0,Math.min(100,50+(iR.i-aR.i)*200));\n    if (p>0) { const jA=cC*5+iC*8, jN=p*0.6; if (jA<jN) { cD=Math.min(100,cD+20); iD=Math.min(100,iD+20); } }\n    if (st.happiness<50) rD=Math.max(0,rD-20); else if (st.happiness>80) rD=Math.min(100,rD+10);\n  }\n  return {rDemand:rD,cDemand:cD,iDemand:iD};\n}\n\nasync function genNws() {\n  if (aiReq) return; aiReq=true;\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  const ctx=`${st.cityName}, ${st.year}, pop ${st.population}, $${(st.money/1000).toFixed(0)}k, happiness ${st.happiness}, ${cnts.residential||0}R ${cnts.commercial||0}C ${cnts.industrial||0}I`;\n  const prm=`Generate ONE dramatic news headline (8 words max) for SimCity game. Context: ${ctx}. Topics: politics, pop culture, tech, disasters, economy, society. Include brief stat at end like (+200 pop) or (-$2k) or (+5 joy). Be punchy and dramatic. Return ONLY headline.`;\n  try {\n    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n    if (!r.ok) throw new Error('AI request failed');\n    const d=await r.json(); let ev=d.reply||'City continues to grow';\n    ev=ev.replace(/^[\"']|[\"']$/g,'').trim();\n    const m=ev.match(/\\(([^)]+)\\)/);\n    if (m) {\n      const ch=m[1];\n      if (ch.includes('pop')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0); st.population=Math.max(0,st.population+vl); }\n      else if (ch.includes('$')||ch.includes('k')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0), mt=ch.includes('k')?1000:1; st.money+=vl*mt; }\n      else if (ch.includes('joy')||ch.includes('happiness')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0); st.happiness=Math.max(0,Math.min(100,st.happiness+vl)); }\n    }\n    st.newsEvents.push(ev); if (st.newsEvents.length>10) st.newsEvents.shift();\n    nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();\n  } catch(e) { console.error('News generation error:',e); } finally { aiReq=false; }\n}\n\nfunction tryMrgPark(x,y) {\n  const c=st.grid[y][x]; if (!c||!c.type.startsWith('park')) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  \n  // Try to merge 2x1 tiles into 2x2\n  if (c.w===2&&c.h===1) {\n    // Check if there's a 2x1 tile directly above or below\n    const checkAbove=y>0 && x+1<GR_SZ;\n    const checkBelow=y+1<GR_SZ && x+1<GR_SZ;\n    \n    if (checkAbove) {\n      const above=st.grid[y-1][x];\n      if (above.type===c.type&&above.w===2&&above.h===1 && y-1>=0 && x+1<GR_SZ && st.grid[y-1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y-1>=0 && y<GR_SZ && x>=0 && x+1<GR_SZ) {\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y-1+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkBelow) {\n      const below=st.grid[y+1][x];\n      if (below.type===c.type&&below.w===2&&below.h===1 && y+1<GR_SZ && x+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Try to merge 1x2 tiles into 2x2\n  if (c.w===1&&c.h===2) {\n    // Check if there's a 1x2 tile directly left or right\n    const checkLeft=x>0 && y+1<GR_SZ;\n    const checkRight=x+1<GR_SZ && y+1<GR_SZ;\n    \n    if (checkLeft) {\n      const left=st.grid[y][x-1];\n      if (left.type===c.type&&left.w===1&&left.h===2 && x-1>=0 && y+1<GR_SZ && st.grid[y+1][x-1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x-1>=0 && x<GR_SZ) {\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x-1+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkRight) {\n      const right=st.grid[y][x+1];\n      if (right.type===c.type&&right.w===1&&right.h===2 && x+1<GR_SZ && y+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Original logic: merge 1x1 tiles\n  if (c.w!==1||c.h!==1) return false;\n  \n  // Try to merge with adjacent parks of the same type\n  const dirs=[{dx:0,dy:0,w:2,h:2},{dx:-1,dy:0,w:2,h:1},{dx:0,dy:-1,w:1,h:2},{dx:-1,dy:-1,w:2,h:2},{dx:0,dy:0,w:2,h:1},{dx:0,dy:0,w:1,h:2}];\n  for (const d of dirs) {\n    const sx=x+d.dx, sy=y+d.dy;\n    if (sx<0||sy<0||sx+d.w>GR_SZ||sy+d.h>GR_SZ) continue;\n    \n    // Check if all cells in the area are the same park type and 1x1\n    let canMerge=true;\n    for (let dy=0; dy<d.h; dy++) for (let dx=0; dx<d.w; dx++) {\n      const nx=sx+dx, ny=sy+dy, nb=st.grid[ny][nx];\n      if (nb.type!==c.type||nb.w!==1||nb.h!==1) { canMerge=false; break; }\n    }\n    \n    if (canMerge) {\n      // Merge the parks - ensure all cells are within bounds\n      for (let dy=0; dy<d.h; dy++) {\n        for (let dx=0; dx<d.w; dx++) {\n          const nx=sx+dx, ny=sy+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:d.w,h:d.h};\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n// First step: merge 1x1 buildings to 2x1 or 1x2\nfunction tryMrgTo2x1(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge mature 1x1 buildings\n  const w=c.w||1, h=c.h||1;\n  if (w!==1 || h!==1) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const targets=[\n    {dx:1, dy:0, w:2, h:1}, // Merge to the right (2x1)\n    {dx:0, dy:1, w:1, h:2}  // Merge downward (1x2)\n  ];\n  \n  for (const target of targets) {\n    const adjX=x+target.dx, adjY=y+target.dy;\n    if (adjX<0||adjX>=GR_SZ||adjY<0||adjY>=GR_SZ) continue;\n    const adj=st.grid[adjY][adjX];\n    if (!adj) continue;\n    if (adj.type!==c.type) continue;\n    if ((adj.w||1)!==1 || (adj.h||1)!==1) continue;\n    \n    const adjLevel=adj.level||0;\n    if (adjLevel<=0 && !adj.abandoned) continue; // keep level-0 zones 1x1\n    \n    const topLeftX=Math.min(x,adjX);\n    const topLeftY=Math.min(y,adjY);\n    const bestAge=Math.max(c.age||0,adj.age||0);\n    const bestLevel=Math.max(1,Math.min(c.level||1,adj.level||c.level||1));\n    const isAbandoned=c.abandoned && adj.abandoned;\n    \n    for (let dy=0; dy<target.h; dy++) {\n      for (let dx=0; dx<target.w; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          st.grid[ny][nx]={type:c.type,age:bestAge,level:bestLevel,w:target.w,h:target.h,abandoned:isAbandoned};\n        }\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction tryMrg(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge buildings that are 1x2 or 2x1 (not 1x1 - those merge first)\n  const w=c.w||1, h=c.h||1;\n  if (!((w===1&&h===2) || (w===2&&h===1))) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const baseLevel=Math.max(1,c.level||1);\n  const baseAge=c.age||0;\n  const expansions=[];\n  \n  if (w===2 && h===1) {\n    if (y>0) expansions.push({topLeftX:x, topLeftY:y-1, fillCells:[{x:x,y:y-1},{x:x+1,y:y-1}]});\n    if (y+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x,y:y+1},{x:x+1,y:y+1}]});\n  } else if (w===1 && h===2) {\n    if (x>0) expansions.push({topLeftX:x-1, topLeftY:y, fillCells:[{x:x-1,y:y},{x:x-1,y:y+1}]});\n    if (x+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x+1,y:y},{x:x+1,y:y+1}]});\n  }\n  \n  for (const option of expansions) {\n    const {topLeftX, topLeftY, fillCells}=option;\n    if (topLeftX<0 || topLeftY<0 || topLeftX+1>=GR_SZ || topLeftY+1>=GR_SZ) continue;\n    \n    let canExpand=true;\n    let mergedAge=baseAge;\n    for (const pos of fillCells) {\n      if (pos.x<0 || pos.x>=GR_SZ || pos.y<0 || pos.y>=GR_SZ) { canExpand=false; break; }\n      const target=st.grid[pos.y][pos.x];\n      if (!target) { canExpand=false; break; }\n      if (target.type!==c.type) { canExpand=false; break; }\n      if ((target.w||1)!==1 || (target.h||1)!==1) { canExpand=false; break; }\n      const targetLevel=target.level||0;\n      if (targetLevel>0 && !target.abandoned) { canExpand=false; break; }\n      mergedAge=Math.max(mergedAge,target.age||0);\n    }\n    \n    if (!canExpand) continue;\n    \n    for (let dy=0; dy<2; dy++) {\n      for (let dx=0; dx<2; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        st.grid[ny][nx]={type:c.type,age:mergedAge,level:baseLevel,w:2,h:2,abandoned:false};\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction updFires() {\n  st.fires=st.fires.filter(f => {\n    f.age++; if (f.age>30) { \n      st.grid[f.y][f.x]={type:'empty',age:0,level:0,w:1,h:1}; \n      normalizeEmptyCell(f.x,f.y); // Ensure it's 1x1\n      return false; \n    }\n    const c=st.grid[f.y][f.x]; if (c.type==='empty') return false;\n    let hasFr=false; for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n      const nx=f.x+dx, ny=f.y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='fire') hasFr=true;\n    }\n    if (hasFr && f.age>10) return false; return true;\n  });\n}\n\nfunction startFire() {\n  const blds=[]; for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x]; if ((c.type==='residential'||c.type==='commercial'||c.type==='industrial') && !c.abandoned) blds.push({x,y});\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)]; st.fires.push({x:b.x,y:b.y,age:0});\n    st.newsEvents.push(`üî• Fire breaks out in ${st.cityName}! (-$5k)`); st.money-=5000;\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\n\nfunction startQuake() {\n  const gr=document.getElementById('grid'); gr.classList.add('earthquake');\n  setTimeout(() => gr.classList.remove('earthquake'),500);\n  const blds=[]; \n  const processedBuildings=new Set(); // Track buildings we've already added\n  \n  // Collect buildings, but only add the top-left cell of each building\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x]; \n      if (c.type==='empty' || c.type==='road') continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only add the top-left cell of each building to avoid duplicates\n      // Check if this is the top-left cell\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (isTopLeft) {\n        // Ensure this building's footprint does not include any roads (which can happen\n        // with older saves or after complex merges next to roads)\n        let hasRoadInFootprint=false;\n        for (let dy=0; dy<h && !hasRoadInFootprint; dy++) {\n          for (let dx=0; dx<w; dx++) {\n            const nx=x+dx, ny=y+dy;\n            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n              if (st.grid[ny][nx].type==='road') {\n                hasRoadInFootprint=true;\n                break;\n              }\n            }\n          }\n        }\n        if (hasRoadInFootprint) continue;\n\n        const buildingKey=`${x},${y},${c.type},${w},${h}`;\n        if (!processedBuildings.has(buildingKey)) {\n          processedBuildings.add(buildingKey);\n          blds.push({x,y,w,h});\n        }\n      }\n    }\n  }\n  \n  const dmg=Math.min(5,Math.floor(blds.length*0.1));\n  for (let i=0; i<dmg; i++) {\n    if (blds.length>0) {\n      const b=blds.splice(Math.floor(Math.random()*blds.length),1)[0];\n      // Destroy all cells that are part of this building\n      const w=b.w||1, h=b.h||1;\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=b.x+dx, ny=b.y+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            // Only destroy if it's not a road\n            if (st.grid[ny][nx].type!=='road') {\n              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1};\n              normalizeEmptyCell(nx,ny); // Ensure it's 1x1\n            }\n          }\n        }\n      }\n    }\n  }\n  st.newsEvents.push(`üåé Earthquake hits ${st.cityName}! ${dmg} buildings damaged (-$10k)`); st.money-=10000;\n  nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n}\n\nfunction updCrimeEvents() {\n  st.crimeEvents=st.crimeEvents.filter(evt => {\n    evt.age++;\n    // Check if police station is nearby (within 8 tiles) - resolves faster\n    let hasPolice=false;\n    for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {\n      const nx=evt.x+dx, ny=evt.y+dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        if (st.grid[ny][nx].type==='police') {\n          const d=Math.abs(dx)+Math.abs(dy);\n          if (d<=8) { hasPolice=true; break; }\n        }\n      }\n    }\n    // Crime events last 20 ticks normally, but only 10 ticks if police nearby\n    const maxAge=hasPolice?10:20;\n    if (evt.age>maxAge) return false;\n    return true;\n  });\n}\n\nfunction startCrimeEvent() {\n  const blds=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    // Higher crime areas are more likely to have crime events\n    const crimeLevel=st.crime[y][x]||30;\n    if ((c.type==='residential'||c.type==='commercial') && !c.abandoned && crimeLevel>40) {\n      // Weight by crime level - higher crime = more likely\n      for (let i=0; i<Math.floor(crimeLevel/20); i++) blds.push({x,y,crimeLevel});\n    }\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)];\n    const crimeTypes=['robbery','break-in','vandalism'];\n    const crimeType=crimeTypes[Math.floor(Math.random()*crimeTypes.length)];\n    st.crimeEvents.push({x:b.x,y:b.y,type:crimeType,age:0});\n    const cost=Math.floor(Math.random()*3000)+2000;\n    st.money-=cost;\n    const msg=crimeType==='robbery'?`üö® Robbery reported in ${st.cityName}! (-$${(cost/1000).toFixed(0)}k)`:\n           crimeType==='break-in'?`üö® Break-in reported in ${st.cityName}! (-$${(cost/1000).toFixed(0)}k)`:\n           `üö® Vandalism reported in ${st.cityName}! (-$${(cost/1000).toFixed(0)}k)`;\n    st.newsEvents.push(msg);\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\n\nfunction simTk() {\n  st.tickCount++; st.ticksSinceNews++;\n  if (st.tickCount%8===0) st.year++;\n  let rC=0, cC=0, iC=0, pC=0, poC=0, fC=0, sC=0, hC=0, rdC=0; const cntd={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (cntd[k]) continue;\n    const c=st.grid[y][x]; \n    // Normalize empty cells to ensure they're always 1x1\n    if (c.type==='empty') normalizeEmptyCell(x,y);\n    if (c.type!=='empty') {\n      c.age++; const w=c.w||1, h=c.h||1;\n      for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) cntd[`${x+dx},${y+dy}`]=true;\n    }\n    if (c.type==='residential') rC++; else if (c.type==='commercial') cC++; else if (c.type==='industrial') iC++;\n    else if (c.type.startsWith('park')) pC++; else if (c.type==='police') poC++; else if (c.type==='fire') fC++;\n    else if (c.type==='school') sC++; else if (c.type==='hospital') hC++; else if (c.type==='road') rdC++;\n  }\n  updLV();\n  updCrime();\n  // Track processed buildings to avoid duplicate updates for merged buildings\n  const processedBuildings = new Set();\n  const processedCells = new Set(); // Track individual cells that have been processed\n  \n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential'||c.type==='commercial'||c.type==='industrial') {\n      // Skip if this cell has already been processed (e.g., as part of a merged building)\n      const cellKey = `${x},${y}`;\n      if (processedCells.has(cellKey)) continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only process the top-left cell of each building\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (!isTopLeft) continue;\n      \n      // Skip if this building has already been processed\n      const buildingKey = `${x},${y},${c.type},${w},${h}`;\n      if (processedBuildings.has(buildingKey)) continue;\n      processedBuildings.add(buildingKey);\n      \n      // Mark all cells of this building as processed\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=x+dx, ny=y+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            processedCells.add(`${nx},${ny}`);\n          }\n        }\n      }\n      \n      const lv=st.landValue[y][x], hr=hasRdAcc(x,y), mv=c.type==='industrial'?10:20;\n      \n      // Track ticks without road access\n      if (!hr) {\n        c.ticksNoRoad = (c.ticksNoRoad || 0) + 1;\n      } else {\n        c.ticksNoRoad = 0;\n      }\n      \n      // Immediate abandonment if land value too low\n      if (lv<mv) { \n        c.abandoned=true;\n        // Keep level but mark as abandoned - don't set to 0\n        // Update all cells of merged building\n        const w=c.w||1, h=c.h||1;\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=true;\n          }\n        }\n      }\n      // Gradual decline without road access\n      else if (!hr) {\n        // Downgrade every 3 ticks without road\n        if (c.ticksNoRoad > 3 && c.level > 1) {\n          c.level--;\n          c.ticksNoRoad = 0; // Reset counter after downgrade\n          // Update all cells of merged building\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n          }\n        }\n        // Become abandoned after being at level 1 for 5 ticks without road\n        else if (c.ticksNoRoad > 5 && c.level >= 1) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n        // Immediately abandon if no road for 10+ ticks\n        else if (c.ticksNoRoad > 10) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          const w=c.w||1, h=c.h||1;\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n      }\n      else {\n        c.abandoned=false;\n        // Update all cells of merged building to un-abandon\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=false;\n          }\n        }\n        \n        // Check for downgrades first (more important)\n        let downgraded = false;\n        if (lv<30 && c.level>1) { \n          const newLevel = Math.max(1,c.level-1);\n          c.level = newLevel;\n          downgraded = true;\n          // Update all cells of merged building\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n          }\n        }\n        else if (lv>=30 && lv<40 && c.level===3) { \n          c.level=2; \n          downgraded = true;\n          // Update all cells of merged building\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=2;\n          }\n        }\n        \n          // Upgrade logic - only if not downgraded, gradual one level at a time\n          // Slowed down upgrades: require more age and better conditions\n          if (!downgraded) {\n            let upgraded = false;\n            // Level 0 -> 1: needs age > 10 ticks (was 5)\n            if (c.level===0 && c.age>10) {\n              c.level=1;\n              upgraded = true;\n            }\n            // Level 1 -> 2: needs age > 30 AND land value > 55 (was 15 and 50)\n            else if (c.level===1 && c.age>30 && lv>55) {\n              c.level=2;\n              upgraded = true;\n            }\n            // Level 2 -> 3: needs age > 50 AND land value > 75 (was 25 and 70)\n            else if (c.level===2 && c.age>50 && lv>75) {\n              c.level=3;\n              upgraded = true;\n            }\n          \n          // Update all cells of merged building if upgraded\n          if (upgraded) {\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n            }\n          }\n        }\n        \n        // Two-step merging process:\n        // Step 1: Try to merge 1x1 buildings to 2x1 or 1x2 first\n        if (c.age>8 && w===1 && h===1 && c.level>0) {\n          const merged=tryMrgTo2x1(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged building as processed\n            // The merged building is now 2x1 or 1x2, so we need to update processedCells\n            // But we don't know which direction it merged, so we'll let the next iteration handle it\n            // For now, just mark the current cell as processed\n            processedCells.add(`${x},${y}`);\n            if (x+1<GR_SZ) processedCells.add(`${x+1},${y}`); // If merged right (2x1)\n            if (y+1<GR_SZ) processedCells.add(`${x},${y+1}`); // If merged down (1x2)\n          }\n        }\n        // Step 2: Try to merge 2x1 or 1x2 buildings to 2x2 (only if at least one is 2x1/1x2)\n        if (c.age>12 && ((w===1&&h===2) || (w===2&&h===1)) && c.level>0) {\n          // Only try merge if this is the top-left cell of the building\n          // For 1x2: always top-left (spans down)\n          // For 2x1: always top-left (spans right)\n          const merged=tryMrg(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged 2x2 building as processed\n            // After merge, the grid has been updated with a 2x2 building\n            // Check the current cell and nearby cells to find the 2x2 building's top-left\n            let found2x2=false;\n            for (let checkY=Math.max(0,y-1); checkY<=Math.min(GR_SZ-2,y+1) && !found2x2; checkY++) {\n              for (let checkX=Math.max(0,x-1); checkX<=Math.min(GR_SZ-2,x+1) && !found2x2; checkX++) {\n                const checkCell=st.grid[checkY][checkX];\n                if (checkCell.type===c.type && (checkCell.w||1)===2 && (checkCell.h||1)===2) {\n                  // This is the top-left of the merged 2x2 building\n                  // Mark all 4 cells as processed\n                  for (let dy=0; dy<2; dy++) {\n                    for (let dx=0; dx<2; dx++) {\n                      const nx=checkX+dx, ny=checkY+dy;\n                      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                        processedCells.add(`${nx},${ny}`);\n                      }\n                    }\n                  }\n                  found2x2=true;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else if (c.type.startsWith('park')) {\n      // Try to merge parks of the same type\n      tryMrgPark(x,y);\n    }\n  }\n  const bPR=10; let nP=0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n      const sM=(c.w||1)*(c.h||1), lM=c.level===3?1.5:(c.level===2?1.2:1);\n      nP+=Math.floor(bPR*sM*lM);\n    }\n  }\n  st.population=nP;\n  const jA=cC*5+iC*8, jN=nP*0.6;\n  if (jA<=0 || jN<=0) st.employment=0;\n  else st.employment=Math.min(100,Math.floor((Math.min(jA,jN)/jN)*100));\n  const inc=Math.floor(st.population*2), mnt=Math.floor(rdC*1+rC*2+cC*3+iC*5+pC*2+poC*10+fC*10+sC*15+hC*20);\n  st.money+=inc-mnt;\n  let hp=70;\n  if (st.population>0) {\n    const pR=pC/(rC+1); hp+=Math.min(pR*50,15);\n    const sR=(poC+fC+sC+hC)/(st.population/100+1); hp+=Math.min(sR*20,10);\n    const jR=(cC+iC)/(rC+1); if (jR<0.5) hp-=10; else if (jR>2) hp-=5;\n    if (st.money<0) hp-=15;\n    // Factor in crime - calculate average city crime\n    let avgCrime=0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime+=st.crime[y][x]||30;\n    }\n    avgCrime=avgCrime/(GR_SZ*GR_SZ);\n    // High crime reduces happiness (up to -15 points)\n    if (avgCrime>60) hp-=Math.min(15,Math.floor((avgCrime-60)/2));\n    else if (avgCrime>40) hp-=Math.min(8,Math.floor((avgCrime-40)/3));\n    // Police coverage improves happiness\n    if (poC>0 && st.population>0) {\n      const policeRatio=poC/(st.population/500+1);\n      hp+=Math.min(5,policeRatio*2);\n    }\n  }\n  st.happiness=Math.max(0,Math.min(100,Math.floor(hp)));\n  const dmd=calcDmd(rC,cC,iC,st.population); st.rDemand=Math.floor(dmd.rDemand); st.cDemand=Math.floor(dmd.cDemand); st.iDemand=Math.floor(dmd.iDemand);\n  const tB=rC+cC+iC+pC+poC+fC+sC+hC;\n  if (st.ticksSinceNews>=8 && tB>5 && !aiReq) { st.ticksSinceNews=0; genNws(); }\n  if (Math.random()<0.02 && tB>10) startFire();\n  if (Math.random()<0.01 && tB>20) startQuake();\n  if (Math.random()<0.02 && st.population>50) startCrimeEvent();\n  updFires(); updCrimeEvents(); drGr(); updUI(); sv();\n}\n\nconst aC=new (window.AudioContext||window.webkitAudioContext)();\nfunction plySnd(t) {\n  const n=aC.currentTime;\n  if (t==='place') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); }\n  else if (t==='bulldoze') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sawtooth'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(200,n); g.gain.setValueAtTime(0.15,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); }\n  else if (t==='click') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(600,n); g.gain.setValueAtTime(0.08,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.05); o.start(n); o.stop(n+0.05); }\n  else if (t==='error') { const o=aC.createOscillator(), g=aC.createGain(); o.type='square'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(300,n); o.frequency.setValueAtTime(200,n+0.1); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); }\n}\n\nif (!ld()) { initGr('balanced'); st.newsEvents=['Welcome to '+st.cityName+'!']; }\nif (!st.zoom) st.zoom=1;\nif (st.disastersEnabled === undefined) st.disastersEnabled = true;\nconst disastersToggleEl = document.getElementById('disastersToggle');\nif (disastersToggleEl) disastersToggleEl.checked = st.disastersEnabled;\napplyZoom();\ndrGr(); updUI(); updNwsTk(); selTl('road');\nif (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); }\n\n// Center canvas after page is fully loaded\nwindow.addEventListener('load', () => {\n  setTimeout(centerCanvas, 100);\n});\n\n// Re-center canvas when window is resized\nlet resizeTimeout;\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimeout);\n  resizeTimeout = setTimeout(centerCanvas, 100);\n});\n\nsetInterval(() => { if (st.speed>0) { updCars(); drGr(); } },50);\n</script>\n</body>\n</html>\n",
  "title": "AI SimCity",
  "icon": "üèôÔ∏è",
  "name": "AI SimCity.app",
  "windowWidth": 420,
  "windowHeight": 625,
  "createdAt": 1763142872296,
  "createdBy": "ryo",
  "updatedAt": 1763142872296,
  "featured": true
}