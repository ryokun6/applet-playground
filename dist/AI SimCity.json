{
  "content": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n    <link rel=\"stylesheet\" href=\"https://os.ryo.lu/fonts/fonts.css\">\n    <!-- ts=1763051833299 --> \n    \n    <script src=\"https://cdn.tailwindcss.com/3.4.16\"></script>\n    <script>\n      tailwind.config = {\n        theme: {\n          extend: {\n            fontFamily: {\n              sans: [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"sans-serif\"],\n              mono: [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"ui-monospace\", \"SFMono-Regular\", \"Menlo\", \"Monaco\", \"Consolas\", \"Liberation Mono\", \"Courier New\", \"monospace\"],\n              serif: [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"SerenityOS-Emoji\", \"serif\"],\n              emoji: [\"SerenityOS-Emoji\", \"AppleColorEmoji\", \"AppleColorEmojiFallback\"],\n              'geneva': [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"system-ui\", \"-apple-system\", \"sans-serif\"],\n              'mondwest': [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"serif\"],\n              'neuebit': [\"NeueBit\", \"ArkPixel\", \"SerenityOS-Emoji\", \"Helvetica\", \"Arial\", \"Hiragino Sans\", \"sans-serif\"],\n              'monaco': [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"monospace\"],\n              'jacquard': [\"Jacquard\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"serif\"]\n            }\n          }\n        }\n      }\n    </script>\n  <style>\n    * {\n      box-sizing: border-box;\n      \n    }\n    html, body {\n      margin: 0;\n      overflow-x: auto; /* Allow horizontal scroll if content overflows */\n      width: 100%;\n      height: 100%;\n      max-width: 100%; /* Prevent body from exceeding viewport width */\n      \n    }\n    \n    /* Ensure pre doesn't break layout */\n    pre {\n      white-space: pre-wrap; /* Allow wrapping */\n      word-break: break-all; /* Break long words */\n    }\n      \n      #yearDisplay {\n        font-variant-numeric: tabular-nums;\n        font-feature-settings: 'tnum';\n      }\n  </style>\n  \n  <script>\n    (function() {\n      function handleLinkClick(event) {\n        const targetElement = event.target.closest('a');\n        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]') && !targetElement.hasAttribute('download')) {\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;\n            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');\n          } catch (e) { console.error(\"Error resolving/posting URL:\", e); }\n        }\n      }\n      document.addEventListener('click', handleLinkClick, true);\n      document.addEventListener('DOMContentLoaded', () => document.addEventListener('click', handleLinkClick, true));\n    })();\n  </script>\n \n</head>\n<body>\n  <div class=\"w-full h-screen bg-neutral-900 text-neutral-100 font-geneva flex flex-col overflow-hidden relative\">\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-2 flex items-center justify-between flex-shrink-0\">\n    <div class=\"flex items-center gap-3\">\n      <button id=\"menuBtn\" class=\"text-sm text-neutral-300 hover:text-neutral-100 transition-colors\">‚ò∞</button>\n      <div class=\"flex items-center gap-1\">\n        <div class=\"text-sm text-neutral-400\">\n          <input id=\"cityName\" type=\"text\" value=\"new city\" class=\"bg-transparent border-none outline-none text-white cursor-pointer hover:bg-neutral-700 px-1 rounded transition-colors\">\n        </div>\n        <button id=\"speedToggle\" class=\"text-xs text-neutral-300 hover:text-neutral-100 transition-colors\">‚è∏</button>\n      </div>\n    </div>\n    \n    <div class=\"flex items-center gap-3\">\n      <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"rciBtn\">\n        <div id=\"powerShortageIndicator\" class=\"flex items-center gap-0.5 text-xs mr-1\" style=\"display: none;\">\n          <span class=\"text-red-400\">‚ö°</span>\n          <span id=\"powerShortageValue\" class=\"text-red-400 tabular-nums\"></span>\n        </div>\n        <div id=\"waterShortageIndicator\" class=\"flex items-center gap-0.5 text-xs mr-1\" style=\"display: none;\">\n          <span class=\"text-red-400\">üíß</span>\n          <span id=\"waterShortageValue\" class=\"text-red-400 tabular-nums\"></span>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"rDemand\" class=\"w-full bg-green-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"cDemand\" class=\"w-full bg-blue-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"iDemand\" class=\"w-full bg-yellow-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n      </div>\n      \n      <div class=\"flex items-center gap-1.5 text-xs\">\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"popBtn\">\n          <span class=\"text-neutral-500\">‚òª</span>\n          <span id=\"population\" class=\"text-white tabular-nums\">0</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"moneyBtn\">\n          <span class=\"text-neutral-500\">$</span>\n          <span id=\"money\" class=\"text-white tabular-nums\">50k</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"happyBtn\">\n          <span class=\"text-neutral-500\">‚ô•</span>\n          <span id=\"happiness\" class=\"text-white tabular-nums\">70</span>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-1.5 flex items-center gap-3 text-xs flex-shrink-0\">\n    <div id=\"yearDisplay\" class=\"text-neutral-400 font-mono tabular-nums\">1990</div>\n    <div class=\"flex-1 overflow-hidden relative\" style=\"height: 1.25rem; line-height: 1.25rem;\">\n      <div id=\"newsTicker\" class=\"text-neutral-300 whitespace-nowrap absolute left-0 transition-all duration-500\" style=\"line-height: 1.25rem;\"></div>\n    </div>\n  </div>\n\n  <div id=\"menu\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-3 flex-shrink-0\">\n    <div class=\"max-w-md mx-auto space-y-3\">\n      <div class=\"flex items-start gap-3\">\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">zoom</div>\n          <div class=\"flex items-center gap-1 w-full justify-between\">\n            <button id=\"zoomOutBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">‚àí</button>\n            <div id=\"zoomLevel\" class=\"text-xs text-neutral-300 tabular-nums px-2\">100%</div>\n            <button id=\"zoomInBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">+</button>\n          </div>\n        </div>\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">settings</div>\n          <label class=\"flex items-center gap-2 px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors cursor-pointer\">\n            <input id=\"disastersToggle\" type=\"checkbox\" checked class=\"w-4 h-4 accent-green-600\">\n            <span>disasters</span>\n          </label>\n        </div>\n      </div>\n      <div class=\"flex items-center gap-2\">\n        <button id=\"exportBtn\" class=\"flex-1 text-center px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors\">\n          export\n        </button>\n        <button id=\"importBtn\" class=\"flex-1 text-center px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors\">\n          import\n        </button>\n        <input type=\"file\" id=\"importFileInput\" accept=\".json\" class=\"hidden\">\n      </div>\n      <div class=\"flex items-center gap-2\">\n        <button id=\"aiSuggestBtn\" class=\"flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors flex items-center justify-center gap-2\">\n          <span>ask AI mayor</span>\n        </button>\n        <button id=\"newCityBtn\" class=\"flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors\">\n          new city\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"newGamePanel\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-4 flex-shrink-0\">\n    <div class=\"max-w-md mx-auto space-y-3\">\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">city name</label>\n        <input id=\"newCityName\" type=\"text\" value=\"\" placeholder=\"new city\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none focus:border-neutral-500\">\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">terrain type</label>\n        <select id=\"terrainType\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"balanced\">balanced</option>\n          <option value=\"island\">island</option>\n          <option value=\"valley\">valley</option>\n          <option value=\"plains\">plains</option>\n        </select>\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">difficulty</label>\n        <select id=\"difficulty\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"easy\">easy ($100k)</option>\n          <option value=\"normal\" selected>normal ($50k)</option>\n          <option value=\"hard\">hard ($20k)</option>\n        </select>\n      </div>\n      <button id=\"startGameBtn\" class=\"w-full bg-green-700 hover:bg-green-600 text-white px-4 py-2 rounded text-sm transition-colors\">\n        start game\n      </button>\n    </div>\n  </div>\n\n  <div class=\"flex-1 overflow-hidden flex\">\n    <div id=\"grid\" class=\"flex-1 overflow-auto p-4 relative\">\n      <canvas id=\"canvas\" class=\"rounded\" style=\"image-rendering: pixelated;\"></canvas>\n    </div>\n\n    <div class=\"flex flex-shrink-0 relative\" style=\"overflow: visible;\">\n      <div id=\"subToolbar\" class=\"hidden absolute right-[calc(100%+1px)] w-14 border-r border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto rounded-lg z-10\" style=\"overflow-x: visible;\"></div>\n      <div class=\"w-14 border-l border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto flex-shrink-0\" id=\"mainToolbar\" style=\"overflow-x: visible;\">\n        <button data-tool=\"road\" data-tooltip=\"road\" data-shortcut=\"R\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üõ£Ô∏è</button>\n        <button data-tool=\"residential\" data-tooltip=\"residential\" data-shortcut=\"H\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè†</button>\n        <button data-tool=\"commercial\" data-tooltip=\"commercial\" data-shortcut=\"C\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè¢</button>\n        <button data-tool=\"industrial\" data-tooltip=\"industrial\" data-shortcut=\"I\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè≠</button>\n        <div class=\"w-full flex flex-col\">\n          <div class=\"h-1\"></div>\n          <div class=\"h-px w-full bg-neutral-700\"></div>\n          <div class=\"h-1\"></div>\n        </div>\n        <button data-submenu=\"power\" data-tooltip=\"energy\" data-shortcut=\"E\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">‚ö°</button>\n        <button data-submenu=\"water\" data-tooltip=\"water\" data-shortcut=\"Q\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üíß</button>\n        <button data-submenu=\"services\" data-tooltip=\"services\" data-shortcut=\"S\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üèõÔ∏è</button>\n        <button data-submenu=\"park\" data-tooltip=\"park\" data-shortcut=\"P\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üå≥</button>\n        <div class=\"w-full flex flex-col\">\n          <div class=\"h-1\"></div>\n          <div class=\"h-px w-full bg-neutral-700\"></div>\n          <div class=\"h-1\"></div>\n        </div>\n        <button data-submenu=\"disaster\" data-tooltip=\"disasters\" data-shortcut=\"W\" class=\"disaster-btn tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\" style=\"display: none;\">‚ö†Ô∏è</button>\n        <button data-tool=\"bulldoze\" data-tooltip=\"demolish\" data-shortcut=\"D\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üí•</button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"aiPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0\">\n    <div class=\"max-w-md mx-auto\">\n      <div class=\"flex items-start gap-2 mb-2\">\n        <div class=\"flex-1\">\n          <div class=\"text-xs text-yellow-500 mb-1\">AI Mayor</div>\n          <div id=\"aiMessage\" class=\"text-sm text-neutral-300 leading-relaxed\"></div>\n        </div>\n        <button id=\"closeAiBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n      </div>\n    </div>\n  </div>\n\n  <!-- Building info panel for stat view -->\n  <div id=\"buildingInfoPanel\" class=\"hidden border-t border-b border-neutral-700 bg-neutral-800 p-3 max-h-72 overflow-y-auto flex-shrink-0 absolute bottom-0 left-0 right-0 z-50\">\n    <div class=\"flex flex-col\">\n      <div class=\"flex items-start justify-between gap-2 mb-2\">\n        <div id=\"buildingInfoTitle\" class=\"text-sm font-bold text-white flex-1\"></div>\n        <button id=\"closeBuildingInfoBtn\" onclick=\"hideBuildingInfo()\" class=\"text-xs text-neutral-500 hover:text-neutral-300 transition-colors flex-shrink-0\">‚úï</button>\n      </div>\n      <div id=\"buildingInfoContent\" class=\"text-xs text-neutral-300 space-y-1 overflow-y-auto\"></div>\n    </div>\n  </div>\n\n  <div id=\"infoPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0 relative z-10\">\n    <div>\n      <div class=\"flex items-start gap-2 mb-2\">\n        <div class=\"flex-1\">\n          <div class=\"text-xs text-blue-400 mb-1\" id=\"infoTitle\">Info</div>\n          <div id=\"infoContent\" class=\"text-sm text-neutral-300 leading-relaxed space-y-1\"></div>\n        </div>\n        <button id=\"closeInfoBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n      </div>\n    </div>\n  </div>\n\n\n\n  <div class=\"border-t border-neutral-700 bg-neutral-800 px-3 py-2 text-xs text-neutral-400 flex items-center justify-between flex-shrink-0\">\n    <div id=\"statusText\">select a tool to start building</div>\n    <div id=\"costText\" class=\"text-neutral-500\"></div>\n  </div>\n</div>\n\n<style>\n@keyframes tickerRollUp {\n  0% { transform: translateY(0); opacity: 1; }\n  100% { transform: translateY(-100%); opacity: 0; }\n}\n@keyframes shake {\n  0%, 100% { transform: translate(0, 0); }\n  5% { transform: translate(-8px, 6px); }\n  10% { transform: translate(7px, -5px); }\n  15% { transform: translate(-9px, 4px); }\n  20% { transform: translate(8px, -7px); }\n  25% { transform: translate(-10px, 8px); }\n  30% { transform: translate(9px, -6px); }\n  35% { transform: translate(-7px, 5px); }\n  40% { transform: translate(8px, -8px); }\n  45% { transform: translate(-9px, 7px); }\n  50% { transform: translate(10px, -5px); }\n  55% { transform: translate(-8px, 6px); }\n  60% { transform: translate(7px, -7px); }\n  65% { transform: translate(-6px, 5px); }\n  70% { transform: translate(5px, -6px); }\n  75% { transform: translate(-4px, 4px); }\n  80% { transform: translate(4px, -4px); }\n  85% { transform: translate(-3px, 3px); }\n  90% { transform: translate(2px, -2px); }\n  95% { transform: translate(-1px, 1px); }\n}\n.ticker-roll { animation: tickerRollUp 0.5s ease-out forwards; }\n.earthquake { animation: shake 1.5s ease-in-out; }\n.tool-btn {\n  transition: opacity 0.2s ease, background-color 0.2s ease;\n  position: relative;\n}\n.tooltip {\n  position: fixed;\n  background-color: rgb(30, 30, 30);\n  color: rgb(229, 229, 229);\n  padding: 4px 8px;\n  border-radius: 4px;\n  font-size: 12px;\n  white-space: nowrap;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease;\n  z-index: 10000;\n  border: 1px solid rgb(64, 64, 64);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n}\n.tooltip.show {\n  opacity: 1;\n}\n.tooltip-shortcut {\n  color: rgb(163, 163, 163);\n  margin-left: 6px;\n}\n@media (hover: hover) and (pointer: fine) {\n  .tool-btn:hover { background-color: rgb(64, 64, 64); opacity: 1 !important; }\n  .tool-btn[data-tool=\"bulldoze\"]:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }\n  .tool-btn.submenu-active:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }\n}\n</style>\n\n<script>\n// Constants\nconst GR_SZ = 32, CL_SZ = 16;\nconst COSTS = {road:100,residential:500,commercial:800,industrial:1000,park:300,park2:300,park3:300,park4:300,police:2000,fire:2000,school:3000,hospital:4000,coal:5000,nuclear:10000,wind:3000,pipe:50,waterplant:4000,watertower:2000};\nconst POWER_GENERATION = {coal:600,nuclear:1200,wind:240};\nconst WATER_GENERATION = {waterplant:1600,watertower:800};\n// Approximate monthly maintenance cost per tile for each power plant type\nconst POWER_PLANT_MAINTENANCE = {coal:40,nuclear:70,wind:20};\n// Approximate monthly maintenance cost per tile for each water plant type\nconst WATER_PLANT_MAINTENANCE = {waterplant:30,watertower:15};\nconst LAND_VALUE_LOW_COLOR = {r:250,g:204,b:21};\nconst LAND_VALUE_HIGH_COLOR = {r:34,g:197,b:94};\nconst STATION_MAX_ACTIVE = 2;\nconst STAT_INFO_TYPES = ['rci','pop','money','happy'];\nconst CAR_BASE_SPEED = 1.0;\nconst CAR_EDGE_OFFSET = CL_SZ/2 - 1;\nconst CAR_SNAP_THRESHOLD = 0.5;\nconst EMERGENCY_SPEED_MULTIPLIER = 1.2;\n\n// State variables\nlet TK_INT = 2000, tkTmr = null, aiReq = false, edtNm = false, nwsIdx = 0, tkrTmr = null, trans = false, nwsQ = [];\nlet st = {cityName:'new city',money:50000,population:0,populationNewsBonus:0,happiness:70,grid:[],terrain:[],landValue:[],crime:[],crimeEvents:[],selectedTool:null,tickCount:0,speed:3000,rDemand:50,cDemand:50,iDemand:50,year:1950,newsEvents:[],pendingNews:[],ticksSinceNews:0,fires:[],employment:0,cars:[],zoom:1.5,disastersEnabled:true,stationDispatches:{},taxRate:10,powerGrid:[],powerShortageBuildings:{},waterGrid:[],waterShortageBuildings:{},residents:{}};\nlet nextBuildingId = 1;\nlet nextResidentId = 1;\nlet showLandValueOverlay = false;\nlet showCrimeOverlay = false;\nlet showWaterOverlay = false;\nlet highlightedBuilding = null;\nlet highlightedWorkplace = null;\nlet currentInfoType = null;\nlet activeSubmenu = null;\nlet followedResident = null;\nlet lastBuildingView = null; // Store building coordinates for back button\nlet isDragging = false, dragStart = null, lastPlaced = null, isScrolling = false, touchStartPos = null, lastTouchPos = null;\nlet hoverPos = null;\nlet lastZoneBounds = null;\nlet resizeTimeout;\nconst isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\nlet justPlacedTileOnMobile = false; // Flag to prevent building info panel from showing immediately after placing on mobile\n\n// ===== Power System =====\nfunction getPowerConsumption(buildingType, level) {\n  if (buildingType === 'residential') {\n    if (level === 2) return 5;\n    if (level === 3) return 10;\n    return 0; // L1 residential doesn't need power\n  } else if (buildingType === 'commercial') {\n    if (level === 1) return 10;\n    if (level === 2) return 20;\n    if (level === 3) return 30;\n    return 0;\n  } else if (buildingType === 'industrial') {\n    if (level === 1) return 15;\n    if (level === 2) return 30;\n    if (level === 3) return 45;\n    return 0;\n  }\n  return 0;\n}\n\nfunction getBuildingPowerKey(x, y) {\n  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;\n  const cell = st.grid[y][x];\n  if (!cell || !cell.type || cell.type === 'empty') return null;\n  if (cell.buildingId != null) return `b:${cell.buildingId}`;\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n  return `b:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;\n}\n\nfunction getPowerPlantKey(x, y) {\n  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;\n  const cell = st.grid[y][x];\n  if (!cell || !cell.type) return null;\n  if (cell.buildingId != null) return `p:${cell.buildingId}`;\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n  return `p:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;\n}\n\nfunction getPowerSystemSnapshot() {\n  const processedPowerPlants = new Set();\n  const processedBuildings = new Set();\n  const consumers = [];\n  let totalPowerGeneration = 0;\n  let totalPowerConsumption = 0;\n  let coalGen = 0, nuclearGen = 0, windGen = 0;\n  let coalCount = 0, nuclearCount = 0, windCount = 0;\n  let residentialConsumption = 0, commercialConsumption = 0, industrialConsumption = 0;\n  \n  for (let y = 0; y < GR_SZ; y++) {\n    for (let x = 0; x < GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (!cell) continue;\n      \n      if (cell.type === 'coal' || cell.type === 'nuclear' || cell.type === 'wind') {\n        const plantKey = getPowerPlantKey(x,y);\n        if (plantKey && !processedPowerPlants.has(plantKey)) {\n          processedPowerPlants.add(plantKey);\n          const gen = POWER_GENERATION[cell.type] || 0;\n          totalPowerGeneration += gen;\n          if (cell.type === 'coal') { coalGen += gen; coalCount++; }\n          else if (cell.type === 'nuclear') { nuclearGen += gen; nuclearCount++; }\n          else if (cell.type === 'wind') { windGen += gen; windCount++; }\n        }\n      }\n      \n      if (cell.type === 'residential' || cell.type === 'commercial' || cell.type === 'industrial') {\n        if (cell.abandoned) continue;\n        const buildingKey = getBuildingPowerKey(x,y);\n        if (!buildingKey || processedBuildings.has(buildingKey)) continue;\n        processedBuildings.add(buildingKey);\n        \n        const level = cell.level || 0;\n        const perTileConsumption = getPowerConsumption(cell.type, level);\n        if (perTileConsumption <= 0) continue;\n        const bounds = getBuildingBoundsFromCell(x,y);\n        const area = Math.max(1,(bounds.w||1)*(bounds.h||1));\n        const consumption = perTileConsumption * area;\n        totalPowerConsumption += consumption;\n        if (cell.type === 'residential') residentialConsumption += consumption;\n        else if (cell.type === 'commercial') commercialConsumption += consumption;\n        else industrialConsumption += consumption;\n        \n        const hasConnection = hasPowerAccess(x,y);\n        consumers.push({\n          key: buildingKey,\n          type: cell.type,\n          level,\n          consumption,\n          hasConnection,\n          x: bounds.startX,\n          y: bounds.startY\n        });\n      }\n    }\n  }\n  \n  return {\n    totalPowerGeneration,\n    totalPowerConsumption,\n    coalGen,\n    nuclearGen,\n    windGen,\n    coalCount,\n    nuclearCount,\n    windCount,\n    residentialConsumption,\n    commercialConsumption,\n    industrialConsumption,\n    consumers\n  };\n}\n\nfunction allocatePowerToBuildings() {\n  if (!st.powerShortageBuildings || typeof st.powerShortageBuildings !== 'object') {\n    st.powerShortageBuildings = {};\n  }\n  const snapshot = getPowerSystemSnapshot();\n  const shortageMap = {};\n  const connectedBuildings = [];\n  \n  for (const consumer of snapshot.consumers) {\n    if (!consumer.hasConnection) {\n      shortageMap[consumer.key] = true;\n    } else if (consumer.consumption > 0) {\n      connectedBuildings.push(consumer);\n    }\n  }\n  \n  const typePriority = {residential:0, commercial:1, industrial:2};\n  connectedBuildings.sort((a,b) => {\n    const typeDiff = (typePriority[a.type] ?? 99) - (typePriority[b.type] ?? 99);\n    if (typeDiff !== 0) return typeDiff;\n    if (b.level !== a.level) return b.level - a.level;\n    if (a.consumption !== b.consumption) return a.consumption - b.consumption;\n    return a.key.localeCompare(b.key);\n  });\n  \n  let remainingPower = snapshot.totalPowerGeneration;\n  for (const building of connectedBuildings) {\n    if (remainingPower >= building.consumption) {\n      remainingPower -= building.consumption;\n    } else {\n      shortageMap[building.key] = true;\n    }\n  }\n  \n  st.powerShortageBuildings = shortageMap;\n}\n\n// ===== Resident System =====\nconst FIRST_NAMES = ['John', 'Jane', 'Michael', 'Sarah', 'David', 'Emily', 'James', 'Jessica', 'Robert', 'Amanda', 'William', 'Ashley', 'Richard', 'Melissa', 'Joseph', 'Nicole', 'Thomas', 'Michelle', 'Christopher', 'Kimberly', 'Daniel', 'Amy', 'Matthew', 'Angela', 'Anthony', 'Stephanie', 'Mark', 'Rachel', 'Donald', 'Lauren', 'Steven', 'Lisa', 'Paul', 'Nancy', 'Andrew', 'Karen', 'Joshua', 'Betty', 'Kenneth', 'Helen', 'Kevin', 'Sandra', 'Brian', 'Donna', 'George', 'Carol', 'Timothy', 'Ruth', 'Ronald', 'Sharon', 'Jason', 'Michelle', 'Edward', 'Laura', 'Jeffrey', 'Emily', 'Ryan', 'Kimberly', 'Jacob', 'Deborah', 'Gary', 'Amy', 'Nicholas', 'Angela', 'Eric', 'Ashley', 'Jonathan', 'Shirley', 'Stephen', 'Anna', 'Larry', 'Brenda', 'Justin', 'Pamela', 'Scott', 'Emma', 'Brandon', 'Cynthia', 'Benjamin', 'Marie', 'Samuel', 'Janet', 'Frank', 'Catherine', 'Gregory', 'Frances', 'Raymond', 'Christine', 'Alexander', 'Samantha', 'Patrick', 'Debra', 'Jack', 'Rachel', 'Dennis', 'Carolyn', 'Jerry', 'Janet', 'Tyler', 'Maria', 'Aaron', 'Heather', 'Jose', 'Diane', 'Henry', 'Julie', 'Adam', 'Joyce', 'Douglas', 'Victoria', 'Nathan', 'Kelly', 'Zachary', 'Christina', 'Kyle', 'Joan', 'Noah', 'Evelyn', 'Ethan', 'Judith', 'Jeremy', 'Megan', 'Walter', 'Cheryl', 'Christian', 'Andrea', 'Keith', 'Hannah', 'Roger', 'Jacqueline', 'Terry', 'Martha', 'Gerald', 'Gloria', 'Harold', 'Teresa', 'Sean', 'Sara', 'Austin', 'Janice', 'Carl', 'Marie', 'Arthur', 'Julia', 'Lawrence', 'Grace', 'Dylan', 'Judy', 'Jesse', 'Theresa', 'Jordan', 'Madison', 'Bryan', 'Beverly', 'Billy', 'Denise', 'Joe', 'Marilyn', 'Bruce', 'Amber', 'Gabriel', 'Danielle', 'Logan', 'Rose', 'Alan', 'Brittany', 'Juan', 'Diana', 'Wayne', 'Abigail', 'Roy', 'Jane', 'Ralph', 'Lori', 'Randy', 'Mason', 'Louis', 'Ethan', 'Philip', 'Ava', 'Johnny', 'Sophia', 'Bobby', 'Isabella', 'Howard', 'Mia', 'Eugene', 'Charlotte'];\nconst LAST_NAMES = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Wilson', 'Anderson', 'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Thompson', 'White', 'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson', 'Walker', 'Young', 'Allen', 'King', 'Wright', 'Scott', 'Torres', 'Nguyen', 'Hill', 'Flores', 'Green', 'Adams', 'Nelson', 'Baker', 'Hall', 'Rivera', 'Campbell', 'Mitchell', 'Carter', 'Roberts', 'Gomez', 'Phillips', 'Evans', 'Turner', 'Diaz', 'Parker', 'Cruz', 'Edwards', 'Collins', 'Reyes', 'Stewart', 'Morris', 'Morales', 'Murphy', 'Cook', 'Rogers', 'Gutierrez', 'Ortiz', 'Morgan', 'Cooper', 'Peterson', 'Bailey', 'Reed', 'Kelly', 'Howard', 'Ramos', 'Kim', 'Cox', 'Ward', 'Richardson', 'Watson', 'Brooks', 'Chavez', 'Wood', 'James', 'Bennett', 'Gray', 'Mendoza', 'Ruiz', 'Hughes', 'Price', 'Alvarez', 'Castillo', 'Sanders', 'Patel', 'Myers', 'Long', 'Ross', 'Foster', 'Jimenez', 'Powell', 'Jenkins', 'Perry', 'Russell', 'Sullivan', 'Bell', 'Coleman', 'Butler', 'Henderson', 'Barnes', 'Gonzales', 'Fisher', 'Vasquez', 'Simmons', 'Romero', 'Jordan', 'Patterson', 'Alexander', 'Hamilton', 'Graham', 'Reynolds', 'Griffin', 'Wallace', 'Moreno', 'West', 'Cole', 'Hayes', 'Bryant', 'Herrera', 'Gibson', 'Ellis', 'Tran', 'Medina', 'Aguilar', 'Stevens', 'Murray', 'Ford', 'Castro', 'Marshall', 'Owens', 'Harrison', 'Fernandez', 'Mcdonald', 'Woods', 'Washington', 'Kennedy', 'Wells', 'Vargas', 'Henry', 'Chen', 'Freeman', 'Webb', 'Tucker', 'Guzman', 'Burns', 'Crawford', 'Olson', 'Simpson', 'Porter', 'Hunter', 'Gordon', 'Mendez', 'Silva', 'Shaw', 'Snyder', 'Mason', 'Dixon', 'Munoz', 'Hunt', 'Hicks', 'Holmes', 'Palmer', 'Wagner', 'Black', 'Robertson', 'Boyd', 'Rose', 'Stone', 'Salazar', 'Fox', 'Warren', 'Mills', 'Meyer', 'Rice', 'Schmidt', 'Garza', 'Daniels', 'Ferguson', 'Nichols', 'Stephens', 'Soto', 'Weaver', 'Ryan', 'Gardner', 'Payne', 'Grant', 'Dunn', 'Kelley', 'Spencer', 'Hawkins', 'Arnold', 'Pierce', 'Vazquez', 'Hansen', 'Peters', 'Santos', 'Hart', 'Bradley', 'Knight', 'Elliott', 'Cunningham', 'Duncan', 'Armstrong', 'Hudson', 'Carroll', 'Lane', 'Riley', 'Andrews', 'Alvarado', 'Ray', 'Delgado', 'Berry', 'Perkins', 'Hoffman', 'Johnston', 'Matthews', 'Pena', 'Richards', 'Contreras', 'Willis', 'Carpenter', 'Lawrence', 'Sandoval', 'Guerrero', 'George', 'Chapman', 'Rios', 'Estrada', 'Ortega', 'Watkins', 'Cisneros', 'Reed', 'Bauer', 'Valdez', 'Francis', 'Mclaughlin', 'Lynch', 'Bishop', 'Carr', 'Salinas', 'Zimmerman', 'Douglas', 'Mcdaniel', 'Newton', 'Morrison', 'Fuller', 'Garrett', 'Manning', 'Garner', 'Mcgee', 'Reese', 'Francis', 'Burgess', 'Adkins', 'Goodman', 'Curry', 'Brady', 'Christensen', 'Potter', 'Walton', 'Goodwin', 'Mullins', 'Molina', 'Webster', 'Fischer', 'Campos', 'Avila', 'Sherman', 'Todd', 'Chang', 'Blake', 'Malone', 'Wolf', 'Hodges', 'Juarez', 'Gill', 'Farmer', 'Hines', 'Gallagher', 'Duran', 'Hubbard', 'Cannon', 'Miranda', 'Wang', 'Saunders', 'Tate', 'Mack', 'Hammond', 'Carrillo', 'Townsend', 'Wise', 'Ingram', 'Barton', 'Mejia', 'Ayala', 'Schroeder', 'Hampton', 'Rowe', 'Parsons', 'Frank', 'Waters', 'Strickland', 'Osborne', 'Maxwell', 'Chan', 'Deleon', 'Norman', 'Harrington', 'Casey', 'Patton', 'Logan', 'Bowers', 'Mueller', 'Glover', 'Floyd', 'Hartman', 'Buchanan', 'Cobb', 'French', 'Kramer', 'Mccormick', 'Clarke', 'Tyler', 'Gibbs', 'Moody', 'Conner', 'Sparks', 'Conley', 'Foley', 'Mccarthy', 'Vaughn', 'Rojas', 'Walters', 'Blackburn', 'Dunlap', 'Gould', 'Duffy', 'Vance', 'Herring', 'Mckay', 'Espinoza', 'Rivers', 'Farley', 'Bernard', 'Ashley', 'Friedman', 'Potts', 'Truong', 'Costa', 'Correa', 'Blevins', 'Nixon', 'Clements', 'Fritz', 'Delacruz', 'Higgins', 'Madden', 'Lang', 'Duffy', 'Villa', 'Joyce', 'Daugherty', 'Mccall', 'Morton', 'Stokes', 'Lamb', 'Pacheco', 'Proctor', 'Dillon', 'Hoover', 'Macias', 'Villarreal', 'Booker', 'Cordova', 'Roach', 'Rosario', 'Rubio', 'Cervantes', 'Solis', 'Luna', 'Stanton', 'Swanson', 'Cordero', 'Conway', 'Barrera', 'Travis', 'Hobbs', 'Briggs', 'Shah', 'Roth', 'Frazier', 'Russo', 'Blevins', 'Mcconnell', 'Hendricks', 'Hunt', 'Hoover', 'Reed', 'Marsh', 'Fitzgerald', 'Hines', 'Espinoza', 'Goodwin', 'Madden', 'Mccarthy', 'Dillon', 'Luna', 'Ewing', 'Cantu', 'Spears', 'Sewell', 'Bowman', 'Barrera', 'Mccall', 'Blevins', 'Joyce', 'Mcconnell', 'Hendricks', 'Hunt', 'Hoover', 'Reed', 'Marsh', 'Fitzgerald', 'Hines', 'Espinoza', 'Goodwin', 'Madden', 'Mccarthy', 'Dillon', 'Luna', 'Ewing', 'Cantu', 'Spears', 'Sewell', 'Bowman', 'Barrera', 'Mccall'];\n\nfunction generateResidentName() {\n  const firstName = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)];\n  const lastName = LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];\n  return `${firstName} ${lastName}`;\n}\n\nfunction generateResidentStory(resident) {\n  const age = resident.age || Math.floor(Math.random() * 40) + 25;\n  const buildingLevel = resident.homeBuildingLevel || 1;\n  const landValue = resident.homeLandValue || 50;\n  const workplaceType = resident.workplace ? resident.workplace.type : null;\n  const occupation = resident.occupation || 'unemployed';\n  \n  const stories = [];\n  \n  // Age-based intro\n  if (age < 30) {\n    stories.push(`At ${age} years old, ${resident.name} is`);\n  } else if (age < 50) {\n    stories.push(`${resident.name}, ${age}, is`);\n  } else {\n    stories.push(`At ${age} years old, ${resident.name} is`);\n  }\n  \n  // Building level and land value context\n  if (buildingLevel === 3 && landValue > 70) {\n    stories.push(`living in an upscale neighborhood`);\n  } else if (buildingLevel >= 2 && landValue > 60) {\n    stories.push(`living in a nice area`);\n  } else if (buildingLevel === 1 && landValue < 40) {\n    stories.push(`living in a modest neighborhood`);\n  } else {\n    stories.push(`living in the city`);\n  }\n  \n  // Work and lifestyle\n  if (workplaceType === 'commercial') {\n    const commercialStories = [\n      `working as a ${occupation} at a local business`,\n      `employed at a nearby commercial establishment`,\n      `working in retail and services`,\n      `managing a small business in the area`\n    ];\n    stories.push(commercialStories[Math.floor(Math.random() * commercialStories.length)]);\n  } else if (workplaceType === 'industrial') {\n    const industrialStories = [\n      `working as a ${occupation} at a manufacturing plant`,\n      `employed in the industrial sector`,\n      `working in production and manufacturing`,\n      `working at a factory nearby`\n    ];\n    stories.push(industrialStories[Math.floor(Math.random() * industrialStories.length)]);\n  } else if (workplaceType === 'police') {\n    const policeStories = [\n      `working as a ${occupation} at the police station`,\n      `serving the community as a ${occupation}`,\n      `employed at the local police department`,\n      `working in law enforcement`\n    ];\n    stories.push(policeStories[Math.floor(Math.random() * policeStories.length)]);\n  } else if (workplaceType === 'fire') {\n    const fireStories = [\n      `working as a ${occupation} at the fire station`,\n      `serving the community as a ${occupation}`,\n      `employed at the local fire department`,\n      `working in emergency services`\n    ];\n    stories.push(fireStories[Math.floor(Math.random() * fireStories.length)]);\n  } else if (workplaceType === 'school') {\n    const schoolStories = [\n      `working as a ${occupation} at the local school`,\n      `educating the next generation as a ${occupation}`,\n      `employed at the school`,\n      `working in education`\n    ];\n    stories.push(schoolStories[Math.floor(Math.random() * schoolStories.length)]);\n  } else if (workplaceType === 'hospital') {\n    const hospitalStories = [\n      `working as a ${occupation} at the hospital`,\n      `caring for the community as a ${occupation}`,\n      `employed at the local hospital`,\n      `working in healthcare`\n    ];\n    stories.push(hospitalStories[Math.floor(Math.random() * hospitalStories.length)]);\n  } else if (workplaceType && workplaceType.startsWith('park')) {\n    const parkStories = [\n      `working as a ${occupation} at the park`,\n      `maintaining the city's green spaces as a ${occupation}`,\n      `employed at the local park`,\n      `working in parks and recreation`\n    ];\n    stories.push(parkStories[Math.floor(Math.random() * parkStories.length)]);\n  } else if (workplaceType === 'coal') {\n    const coalStories = [\n      `working as a ${occupation} at the coal power plant`,\n      `generating electricity for the city as a ${occupation}`,\n      `employed at the power plant`,\n      `working in energy production`\n    ];\n    stories.push(coalStories[Math.floor(Math.random() * coalStories.length)]);\n  } else if (workplaceType === 'nuclear') {\n    const nuclearStories = [\n      `working as a ${occupation} at the nuclear power plant`,\n      `operating the city's nuclear facility as a ${occupation}`,\n      `employed at the nuclear plant`,\n      `working in nuclear energy`\n    ];\n    stories.push(nuclearStories[Math.floor(Math.random() * nuclearStories.length)]);\n  } else if (workplaceType === 'wind') {\n    const windStories = [\n      `working as a ${occupation} at the wind farm`,\n      `maintaining renewable energy infrastructure as a ${occupation}`,\n      `employed at the wind power facility`,\n      `working in renewable energy`\n    ];\n    stories.push(windStories[Math.floor(Math.random() * windStories.length)]);\n  } else if (workplaceType === 'waterplant') {\n    const waterplantStories = [\n      `working as a ${occupation} at the water treatment plant`,\n      `ensuring clean water for the city as a ${occupation}`,\n      `employed at the water treatment facility`,\n      `working in water treatment`\n    ];\n    stories.push(waterplantStories[Math.floor(Math.random() * waterplantStories.length)]);\n  } else if (workplaceType === 'watertower') {\n    const watertowerStories = [\n      `working as a ${occupation} at the water tower`,\n      `maintaining the city's water supply as a ${occupation}`,\n      `employed at the water facility`,\n      `working in water management`\n    ];\n    stories.push(watertowerStories[Math.floor(Math.random() * watertowerStories.length)]);\n  } else {\n    stories.push(`currently seeking employment`);\n  }\n  \n  // Add personal touches\n  const personalTouches = [\n    `They enjoy spending time in local parks when possible.`,\n    `They value the community services available in the area.`,\n    `They appreciate the convenience of living close to work.`,\n    `They hope to see the neighborhood continue to develop.`,\n    `They are active in the local community.`\n  ];\n  \n  if (Math.random() > 0.3) {\n    stories.push(personalTouches[Math.floor(Math.random() * personalTouches.length)]);\n  }\n  \n  return stories.join(' ');\n}\n\nfunction assignWorkplace(resident, homeX, homeY) {\n  const workplaces = [];\n  for (let y = 0; y < GR_SZ; y++) {\n    for (let x = 0; x < GR_SZ; x++) {\n      const c = st.grid[y][x];\n      // Include commercial, industrial, services, parks, power plants, and water facilities as workplaces\n      if ((c.type === 'commercial' || c.type === 'industrial' || \n           c.type === 'police' || c.type === 'fire' || \n           c.type === 'school' || c.type === 'hospital' ||\n           c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind' ||\n           c.type === 'waterplant' || c.type === 'watertower' ||\n           c.type.startsWith('park')) && !c.abandoned && hasRdAcc(x, y)) {\n        workplaces.push({ x, y, type: c.type, level: c.level || 1 });\n      }\n    }\n  }\n  \n  if (workplaces.length === 0) return null;\n  \n  // Randomly assign to any available workplace\n  return workplaces[Math.floor(Math.random() * workplaces.length)];\n}\n\nfunction calculateResidentIncome(resident) {\n  if (!resident.workplace) return 0;\n  \n  // Base income varies by workplace type\n  let baseIncome = 2000; // Default\n  if (resident.workplace.type === 'commercial') {\n    baseIncome = 2000;\n  } else if (resident.workplace.type === 'industrial') {\n    baseIncome = 2500;\n  } else if (resident.workplace.type === 'police' || resident.workplace.type === 'fire') {\n    baseIncome = 2800; // Emergency services pay well\n  } else if (resident.workplace.type === 'school') {\n    baseIncome = 2400; // Education\n  } else if (resident.workplace.type === 'hospital') {\n    baseIncome = 3200; // Healthcare pays well\n  } else if (resident.workplace.type.startsWith('park')) {\n    baseIncome = 1800; // Parks and recreation\n  } else if (resident.workplace.type === 'coal') {\n    baseIncome = 2600; // Power plant workers\n  } else if (resident.workplace.type === 'nuclear') {\n    baseIncome = 3500; // Nuclear plant workers (highest pay)\n  } else if (resident.workplace.type === 'wind') {\n    baseIncome = 2400; // Wind turbine workers\n  } else if (resident.workplace.type === 'waterplant') {\n    baseIncome = 2700; // Water treatment workers\n  } else if (resident.workplace.type === 'watertower') {\n    baseIncome = 2200; // Water tower workers\n  }\n  \n  const levelMultiplier = resident.workplace.level === 3 ? 1.5 : resident.workplace.level === 2 ? 1.2 : 1.0;\n  const landValueBonus = resident.workplaceLandValue > 70 ? 1.2 : resident.workplaceLandValue > 50 ? 1.1 : 1.0;\n  \n  return Math.floor(baseIncome * levelMultiplier * landValueBonus);\n}\n\nfunction getWorkplaceTypeName(type) {\n  if (type === 'commercial') return 'Commercial';\n  if (type === 'industrial') return 'Industrial';\n  if (type === 'police') return 'Police Station';\n  if (type === 'fire') return 'Fire Station';\n  if (type === 'school') return 'School';\n  if (type === 'hospital') return 'Hospital';\n  if (type === 'coal') return 'Coal Plant';\n  if (type === 'nuclear') return 'Nuclear Plant';\n  if (type === 'wind') return 'Wind Farm';\n  if (type === 'waterplant') return 'Water Plant';\n  if (type === 'watertower') return 'Water Tower';\n  if (type && type.startsWith('park')) return 'Park';\n  return 'Building';\n}\n\nfunction getWorkplaceEmoji(type) {\n  if (type === 'commercial') return 'üíº';\n  if (type === 'industrial') return 'üè≠';\n  if (type === 'police') return 'üëÆ';\n  if (type === 'fire') return 'üöí';\n  if (type === 'school') return 'üè´';\n  if (type === 'hospital') return 'üè•';\n  if (type === 'coal' || type === 'nuclear' || type === 'wind') return '‚ö°';\n  if (type === 'waterplant' || type === 'watertower') return 'üíß';\n  if (type && type.startsWith('park')) return 'üå≥';\n  return 'üè¢';\n}\n\nfunction getResidentOccupation(workplace) {\n  if (!workplace) return 'Unemployed';\n  \n  if (workplace.type === 'commercial') {\n    const occupations = ['Retail Manager', 'Sales Associate', 'Store Clerk', 'Cashier', 'Customer Service Rep', 'Shop Owner', 'Restaurant Worker', 'Barista'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'industrial') {\n    const occupations = ['Factory Worker', 'Machine Operator', 'Production Supervisor', 'Warehouse Worker', 'Manufacturing Technician', 'Quality Inspector', 'Assembly Worker'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'police') {\n    const occupations = ['Police Officer', 'Detective', 'Dispatcher', 'Administrative Assistant', 'Security Guard'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'fire') {\n    const occupations = ['Firefighter', 'Paramedic', 'Fire Inspector', 'Fire Chief', 'Emergency Responder'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'school') {\n    const occupations = ['Teacher', 'Principal', 'Administrator', 'Librarian', 'Custodian', 'School Nurse', 'Counselor'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'hospital') {\n    const occupations = ['Doctor', 'Nurse', 'Surgeon', 'Administrator', 'Technician', 'Receptionist', 'Pharmacist'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type.startsWith('park')) {\n    const occupations = ['Park Ranger', 'Groundskeeper', 'Maintenance Worker', 'Event Coordinator', 'Tour Guide'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'coal') {\n    const occupations = ['Coal Plant Operator', 'Engineer', 'Maintenance Technician', 'Plant Supervisor', 'Safety Inspector'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'nuclear') {\n    const occupations = ['Nuclear Engineer', 'Reactor Operator', 'Health Physicist', 'Plant Manager', 'Safety Specialist'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'wind') {\n    const occupations = ['Wind Turbine Technician', 'Field Service Engineer', 'Operations Manager', 'Maintenance Worker'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'waterplant') {\n    const occupations = ['Water Treatment Operator', 'Plant Manager', 'Lab Technician', 'Maintenance Worker', 'Quality Control Specialist'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  } else if (workplace.type === 'watertower') {\n    const occupations = ['Water System Operator', 'Maintenance Technician', 'Inspector', 'Facility Manager'];\n    return occupations[Math.floor(Math.random() * occupations.length)];\n  }\n  \n  return 'Worker';\n}\n\nfunction generateResidentsForBuilding(x, y) {\n  const buildingKey = `${x},${y}`;\n  if (st.residents[buildingKey]) {\n    return st.residents[buildingKey]; // Already generated\n  }\n  \n  const c = st.grid[y][x];\n  if (c.type !== 'residential' || c.abandoned || !hasRdAcc(x, y)) {\n    return [];\n  }\n  \n  const bPR = 10; // Base population per tile\n  const sM = (c.w || 1) * (c.h || 1);\n  const levelMultiplier = c.level === 3 ? 1.5 : (c.level === 2 ? 1.2 : 1);\n  const capacity = Math.floor(bPR * sM * levelMultiplier);\n  \n  const residents = [];\n  const landValue = st.landValue[y] && st.landValue[y][x] !== undefined ? st.landValue[y][x] : 50;\n  \n  for (let i = 0; i < capacity; i++) {\n    const residentId = nextResidentId++;\n    const age = Math.floor(Math.random() * 40) + 25;\n    const workplace = assignWorkplace({}, x, y);\n    const workplaceLandValue = workplace ? (st.landValue[workplace.y] && st.landValue[workplace.y][workplace.x] !== undefined ? st.landValue[workplace.y][workplace.x] : 50) : 50;\n    const occupation = getResidentOccupation(workplace);\n    const income = calculateResidentIncome({ workplace, workplaceLandValue });\n    const spend = Math.floor(income * (0.6 + Math.random() * 0.2)); // 60-80% spending\n    const tax = Math.floor(income * (st.taxRate / 100));\n    \n    // Work hours: 9 AM to 5 PM (8 hours)\n    const workStart = 9;\n    const workEnd = 17;\n    \n    const resident = {\n      id: residentId,\n      name: generateResidentName(),\n      homeBuilding: { x, y },\n      homeBuildingLevel: c.level || 1,\n      homeLandValue: landValue,\n      workplace: workplace,\n      workplaceLandValue: workplaceLandValue,\n      workHours: { start: workStart, end: workEnd },\n      income: income,\n      spend: spend,\n      tax: tax,\n      age: age,\n      occupation: occupation,\n      car: null\n    };\n    \n    resident.story = generateResidentStory(resident);\n    residents.push(resident);\n  }\n  \n  st.residents[buildingKey] = residents;\n  return residents;\n}\n\n// Calculate power generation and consumption statistics\nfunction calculatePowerStats(includeDetails = false) {\n  const snapshot = getPowerSystemSnapshot();\n  const result = {\n    totalPowerGeneration: snapshot.totalPowerGeneration,\n    totalPowerConsumption: snapshot.totalPowerConsumption,\n    powerSurplus: snapshot.totalPowerGeneration - snapshot.totalPowerConsumption\n  };\n  \n  if (includeDetails) {\n    result.coalGen = snapshot.coalGen;\n    result.nuclearGen = snapshot.nuclearGen;\n    result.windGen = snapshot.windGen;\n    result.coalCount = snapshot.coalCount;\n    result.nuclearCount = snapshot.nuclearCount;\n    result.windCount = snapshot.windCount;\n    result.residentialConsumption = snapshot.residentialConsumption;\n    result.commercialConsumption = snapshot.commercialConsumption;\n    result.industrialConsumption = snapshot.industrialConsumption;\n  }\n  \n  return result;\n}\n\nconst cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d');\ncvs.width = GR_SZ * CL_SZ; cvs.height = GR_SZ * CL_SZ;\n\n// ===== Terrain & Grid =====\nfunction genTerr(t) {\n  const tr = [];\n  for (let y=0; y<GR_SZ; y++) { const r=[]; for (let x=0; x<GR_SZ; x++) r.push('grass'); tr.push(r); }\n  if (t==='island') {\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const dx=x-GR_SZ/2, dy=y-GR_SZ/2, d=Math.sqrt(dx*dx+dy*dy), n=(Math.sin(x*0.3)+Math.cos(y*0.3))*2;\n      if (d+n>GR_SZ/2.3) tr[y][x]='water';\n    }\n    for (let i=0; i<3; i++) {\n      const cx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), cy=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-cx, dy=y-cy, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<3 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  } else if (t==='valley') {\n    for (let y=0; y<GR_SZ; y++) {\n      const cd=Math.abs(y-GR_SZ/2), th=GR_SZ/4+Math.sin(y*0.2)*2;\n      if (cd>th) for (let x=0; x<GR_SZ; x++) tr[y][x]='cliff';\n    }\n    const ry=Math.floor(GR_SZ/2);\n    for (let x=0; x<GR_SZ; x++) {\n      const of=Math.floor(Math.sin(x*0.3)*3), r=ry+of;\n      if (r>=0 && r<GR_SZ) { tr[r][x]='water'; if (r-1>=0 && Math.random()<0.5) tr[r-1][x]='water'; if (r+1<GR_SZ && Math.random()<0.5) tr[r+1][x]='water'; }\n    }\n  } else if (t==='plains') {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<4) tr[y][x]='water';\n      }\n    }\n  } else {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<3.5) tr[y][x]='water';\n      }\n    }\n    for (let i=0; i<2; i++) {\n      const mx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), my=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-mx, dy=y-my, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<2.5 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  }\n  return tr;\n}\n\n// Helper function to ensure empty cells are always 1x1\nfunction normalizeEmptyCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return;\n  const c=st.grid[y][x];\n  if (c.type==='empty' && ((c.w||1)!==1 || (c.h||1)!==1)) {\n    st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n  }\n}\n  \n  function snapCenterToPixelGrid(value, halfSize) {\n    const fractional = halfSize - Math.floor(halfSize);\n    if (Math.abs(fractional) < 1e-6) return Math.round(value);\n    return Math.round(value - fractional) + fractional;\n  }\n\nfunction initGr(tt='balanced') {\n  st.grid=[]; st.terrain=genTerr(tt); st.landValue=[]; st.crime=[]; st.fires=[]; st.cars=[]; st.crimeEvents=[]; st.stationDispatches={};\n  st.powerShortageBuildings={};\n  st.waterShortageBuildings={};\n  st.residents={};\n  st.populationNewsBonus=0;\n  st.ticksSinceNews=0;\n  st.newsEvents=[];\n  nwsQ=[];\n  nwsIdx=0;\n  trans=false;\n  nextBuildingId=1;\n  nextResidentId=1;\n  for (let y=0; y<GR_SZ; y++) {\n    const r=[], vr=[], cr=[];\n    for (let x=0; x<GR_SZ; x++) { r.push({type:'empty',age:0,level:0,w:1,h:1,buildingId:null}); vr.push(50); cr.push(30); }\n    st.grid.push(r); st.landValue.push(vr); st.crime.push(cr);\n  }\n  initPowerGrid();\n  initWaterGrid();\n}\n\nfunction applyLoadedState(loadedState) {\n  if (!loadedState || !Array.isArray(loadedState.grid) || loadedState.grid.length !== GR_SZ) return false;\n  st = loadedState;\n\n  const ensureNumber = (value, fallback) => (typeof value === 'number' && Number.isFinite(value)) ? value : fallback;\n  const ensureArray = (value) => Array.isArray(value) ? value : [];\n\n  st.cityName = (typeof st.cityName === 'string' && st.cityName.trim().length>0) ? st.cityName : 'new city';\n  st.money = ensureNumber(st.money, 50000);\n  st.population = ensureNumber(st.population, 0);\n  st.happiness = ensureNumber(st.happiness, 70);\n  st.tickCount = ensureNumber(st.tickCount, 0);\n  st.speed = ensureNumber(st.speed, 3000);\n  st.rDemand = ensureNumber(st.rDemand, 50);\n  st.cDemand = ensureNumber(st.cDemand, 50);\n  st.iDemand = ensureNumber(st.iDemand, 50);\n  st.year = ensureNumber(st.year, 1950);\n  st.ticksSinceNews = ensureNumber(st.ticksSinceNews, 0);\n  st.populationNewsBonus = ensureNumber(st.populationNewsBonus, 0);\n  st.employment = ensureNumber(st.employment, 0);\n  st.taxRate = ensureNumber(st.taxRate, 10);\n  st.zoom = ensureNumber(st.zoom, 1);\n  if (typeof st.disastersEnabled !== 'boolean') st.disastersEnabled = true;\n  st.newsEvents = ensureArray(st.newsEvents);\n  st.fires = ensureArray(st.fires);\n  st.crimeEvents = ensureArray(st.crimeEvents);\n  st.cars = ensureArray(st.cars).filter(car => car && typeof car === 'object');\n  st.terrain = (Array.isArray(st.terrain) && st.terrain.length === GR_SZ) ? st.terrain : genTerr('balanced');\n  st.landValue = Array.isArray(st.landValue) ? st.landValue : [];\n  st.crime = Array.isArray(st.crime) ? st.crime : [];\n  st.powerShortageBuildings = (st.powerShortageBuildings && typeof st.powerShortageBuildings === 'object') ? st.powerShortageBuildings : {};\n  st.waterShortageBuildings = (st.waterShortageBuildings && typeof st.waterShortageBuildings === 'object') ? st.waterShortageBuildings : {};\n  st.residents = (st.residents && typeof st.residents === 'object') ? st.residents : {};\n\n  for (let y=0; y<GR_SZ; y++) {\n    if (!Array.isArray(st.grid[y])) st.grid[y]=[];\n    if (!Array.isArray(st.landValue[y])) st.landValue[y]=Array(GR_SZ).fill(50);\n    if (!Array.isArray(st.crime[y])) st.crime[y]=Array(GR_SZ).fill(30);\n    for (let x=0; x<GR_SZ; x++) {\n      if (!Number.isFinite(st.landValue[y][x])) st.landValue[y][x]=50;\n      if (!Number.isFinite(st.crime[y][x])) st.crime[y][x]=30;\n      if (!st.grid[y][x] || typeof st.grid[y][x] !== 'object') {\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n      } else {\n        const cell=st.grid[y][x];\n        if (typeof cell.type!=='string') cell.type='empty';\n        if (!Number.isFinite(cell.age)) cell.age=0;\n        if (!Number.isFinite(cell.level)) cell.level=0;\n        if (!Number.isFinite(cell.w) || cell.w<1) cell.w=1;\n        if (!Number.isFinite(cell.h) || cell.h<1) cell.h=1;\n        if (cell.type==='empty') normalizeEmptyCell(x,y);\n      }\n    }\n  }\n\n  rebuildBuildingIdsFromGrid();\n  calculatePowerGrid();\n  calculateWaterGrid();\n\n  st.stationDispatches = {};\n  st.cars.forEach(car => {\n    if (car.stationKey) incrementStationDispatchCount(car.stationKey);\n  });\n\n  let maxResidentId = 0;\n  Object.keys(st.residents).forEach(key => {\n    const residents = Array.isArray(st.residents[key]) ? st.residents[key].filter(r => r && typeof r === 'object') : [];\n    st.residents[key] = residents;\n    residents.forEach(resident => {\n      if (typeof resident.id === 'number' && Number.isFinite(resident.id) && resident.id > maxResidentId) {\n        maxResidentId = resident.id;\n      }\n    });\n  });\n  nextResidentId = maxResidentId + 1;\n  if (!Number.isFinite(nextResidentId) || nextResidentId < 1) nextResidentId = 1;\n\n  if (typeof st.selectedTool !== 'string' || !st.selectedTool) st.selectedTool='road';\n\n  return true;\n}\n\n// ===== Save/Load =====\nfunction sv() { try { localStorage.setItem('simcity_state',JSON.stringify(st)); } catch(e) {} }\nfunction ld() {\n  try {\n    const s = localStorage.getItem('simcity_state');\n    if (s) {\n      const parsed = JSON.parse(s);\n      if (applyLoadedState(parsed)) return true;\n    }\n  } catch(e) {}\n  return false;\n}\n\n// ===== Rendering =====\nfunction isRd(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].type==='road'; }\nfunction getRdNb(x,y) { return {top:isRd(x,y-1),right:isRd(x+1,y),bottom:isRd(x,y+1),left:isRd(x-1,y)}; }\nfunction isPipe(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].pipe === true; }\nfunction getPipeNb(x,y) { return {top:isPipe(x,y-1),right:isPipe(x+1,y),bottom:isPipe(x,y+1),left:isPipe(x-1,y)}; }\n\nfunction drRd(px,py,nb) {\n  ctx.fillStyle='#3a3a3a'; ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);\n  ctx.fillStyle='#4a4a4a';\n  if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }\n  else if (rc===3) {\n    if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }\n    else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n  } else if (rc===2) {\n    if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n    else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }\n    else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }\n  } else if (rc===1) {\n    if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n  } else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n}\n\nfunction drTl(x,y,tp,lv,ab,w,h) {\n  const px=x*CL_SZ, py=y*CL_SZ, wd=w*CL_SZ, ht=h*CL_SZ, tr=st.terrain[y][x];\n  const c = st.grid[y][x];\n  \n  // Check if building needs power but doesn't have it\n  let needsPowerButNoPower = false;\n  let needsWaterButNoWater = false;\n  if (!ab && (tp === 'residential' || tp === 'commercial' || tp === 'industrial')) {\n    const level = lv || 0;\n    let needsPower = false;\n    if (tp === 'residential' && (level === 2 || level === 3)) {\n      needsPower = true;\n    } else if (tp === 'commercial' || tp === 'industrial') {\n      needsPower = true;\n    }\n    if (needsPower) {\n        const hasPower = buildingHasPower(x, y);\n      if (!hasPower) {\n        needsPowerButNoPower = true;\n      }\n    }\n    // Check water - all buildings with level >= 1 need water\n    if (level >= 1) {\n      const hasWater = buildingHasWater(x, y);\n      if (!hasWater) {\n        needsWaterButNoWater = true;\n      }\n    }\n  }\n  if (tp==='empty') {\n    if (tr==='water') ctx.fillStyle='#1e40af'; \n    else if (tr==='cliff') ctx.fillStyle='#3e2723'; \n    else ctx.fillStyle='#2d5016';\n    ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  } else if (tp==='road') { \n    const nb=getRdNb(x,y); drRd(px,py,nb); \n  }\n  \n  // Draw pipes on top of existing tiles (overlay) - but only for single tiles\n  // For multi-tile buildings, pipes will be drawn in a separate pass after all buildings\n  const shouldDrawPipeOverlay = c.pipe && showWaterOverlay && (w === 1 && h === 1);\n  if (shouldDrawPipeOverlay) {\n    const nb=getPipeNb(x,y);\n    const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);\n    ctx.fillStyle='rgba(96,165,250,0.4)'; // Brighter blue with higher opacity\n    ctx.fillRect(px,py,CL_SZ,CL_SZ);\n    ctx.fillStyle='rgba(59,130,246,0.7)'; // Brighter blue for pipe connections\n    \n    // Draw pipe connections similar to roads\n    if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else if (rc===3) {\n      if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }\n      else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }\n      else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }\n      else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    } else if (rc===2) {\n      if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); }\n      else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); }\n      else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n      else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n      else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }\n      else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }\n    } else if (rc===1) {\n      if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); }\n      else { ctx.fillRect(px,py+6,CL_SZ,4); }\n    } else { ctx.fillRect(px+6,py,4,CL_SZ); }\n  }\n  else if (tp==='residential') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,124,89,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-6, bh=ht-6; \n      ctx.fillRect(px+3,py+5,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+3,py+5,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+Math.floor(5+bh*0.35),2,2); \n      ctx.fillRect(px+9,py+Math.floor(5+bh*0.35),2,2); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(5+bh*0.35),2,2); \n    }\n    else {\n      // For 2x2 buildings, make them grow taller with level\n      const sz=w===2&&h===2?(lv===3?wd-3:(lv===2?wd-3.5:wd-4)):w===2?wd-4:(lv===1?8:(lv===3?10:10));\n      const of=w===2&&h===2?(lv===3?1.5:(lv===2?1.75:2)):w===2?2:(lv===1?4:(lv===3?3:3));\n      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-7)):w===2?ht-7:(lv===1?8:(lv===3?12:(lv===2?14:11)));\n      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:6)):w===1&&h===1?(lv===3?2:(lv===2?1:7)):6;\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#22c55e':(lv===2?'#16a34a':'#15803d')):w===2?'#16a34a':(lv===3?'#1a9e4a':(lv===2?'#16a34a':'#15803d')); \n      ctx.fillRect(px+of,py+yo,sz,bh);\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#16a34a':(lv===2?'#15803d':'#166534')):w===2?'#15803d':(lv===3?'#15803d':'#15803d'); \n      const roofHeight=w===2&&h===2&&lv===1?0.18:0.25;\n      ctx.fillRect(px+of,py+yo,sz,Math.floor(bh*roofHeight));\n      if (lv>=2 || w===2) {\n        ctx.fillStyle='#4ade80';\n        const wh=2, ww=2, gap=1;\n        const floors=w===2&&h===2?(lv===3?4:(lv===2?3:2)):w===2&&h===1?1:(lv===3?2:(lv===2?2:1));\n        const winStart=w===2&&h===2?0.35:0.4;\n        for (let f=0; f<floors; f++) {\n          const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));\n          ctx.fillRect(px+5,wy,ww,wh); \n          ctx.fillRect(px+9,wy,ww,wh);\n          if (w===2) { \n            ctx.fillRect(px+20,wy,ww,wh); \n            ctx.fillRect(px+24,wy,ww,wh); \n          }\n        }\n      } else if (lv===1) {\n        ctx.fillStyle='#4ade80';\n        const winStart=w===2&&h===2?0.35:0.4;\n        const wy = py+Math.floor(yo+bh*winStart);\n        ctx.fillRect(px+5,wy,2,2); \n        ctx.fillRect(px+9,wy,2,2);\n      }\n      ctx.fillStyle='#166534'; \n      if (w===1&&h===1&&lv===1) {\n        ctx.fillRect(px+7,py+ht-3,2,3);\n      } else if (w===1&&h===2) {\n        // For 1x2 buildings, position door at bottom of building, centered\n        ctx.fillRect(px+7,py+yo+bh-3,2,3);\n      } else {\n        ctx.fillRect(px+6,py+ht-3,3,3); \n      }\n      if (w===2) ctx.fillRect(px+21,py+ht-3,3,3);\n      // Add yard decorations for 1x2 tiles\n      if (w===1&&h===2&&!ab) {\n        ctx.fillStyle='#15803d';\n        ctx.fillRect(px+3,py+ht-6,2,2); // Small bush left\n        ctx.fillRect(px+11,py+ht-6,2,2); // Small bush right\n        // Add more for higher levels\n        if (lv>=2) {\n          ctx.fillStyle='#16a34a';\n          ctx.fillRect(px+1,py+ht-8,2,2); // Extra bush left\n          ctx.fillRect(px+13,py+ht-8,2,2); // Extra bush right\n        }\n        if (lv>=3) {\n          ctx.fillStyle='#4ade80';\n          ctx.fillRect(px+7,py+ht-7,2,1); // Accent center\n        }\n      }\n    }\n  } else if (tp==='commercial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,107,138,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-4; \n      ctx.fillRect(px+2,py+4,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+4,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+4,py+Math.floor(4+bh*0.4),3,3); \n      ctx.fillRect(px+9,py+Math.floor(4+bh*0.4),3,3); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(4+bh*0.4),3,3); \n    }\n    else {\n      // For 2x2 buildings, make them grow taller with level\n      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-9)):w===2||h===2?ht-3:(lv===1?9:(lv===2?11:13));\n      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:8)):w===2||h===2?2:(lv===1?6:(lv===2?4:1));\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')):w===2||h===2?'#2563eb':(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')); \n      ctx.fillRect(px+2,py+yo,wd-4,bh);\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#2563eb':(lv===2?'#1e40af':'#1d4ed8')):w===2||h===2?'#1e40af':(lv===3?'#2563eb':'#1e40af'); \n      ctx.fillRect(px+2,py+yo,wd-4,Math.floor(bh*0.25));\n      ctx.fillStyle='#87ceeb';\n      const wh=3, ww=3, gap=1;\n      const floors=w===2&&h===2?(lv===3?3:(lv===2?3:1)):w===2&&h===1?1:(w===2||h===2?2:1);\n      const winStart=w===2&&h===2?0.35:0.4;\n      for (let f=0; f<floors; f++) {\n        const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));\n        ctx.fillRect(px+4,wy,ww,wh); \n        ctx.fillRect(px+9,wy,ww,wh);\n        if (w===2) { \n          ctx.fillRect(px+20,wy,ww,wh); \n          ctx.fillRect(px+25,wy,ww,wh); \n        }\n      }\n      ctx.fillStyle='#1e3a8a'; \n      ctx.fillRect(px+6,py+ht-4,4,4); \n      if (w===2) ctx.fillRect(px+22,py+ht-4,4,4);\n    }\n  } else if (tp==='industrial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(138,124,74,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-6; \n      ctx.fillRect(px+2,py+6,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+6,bw,Math.floor(bh*0.4)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+11,2,2); \n      ctx.fillRect(px+9,py+11,2,2); \n      if (w===2) ctx.fillRect(px+21,py+11,2,2); \n    }\n    else {\n      // For 2x2 buildings, grow taller with level\n      const bh=w===2&&h===2?(lv===3?ht-2:(lv===2?ht-3:ht-4)):w===2?ht-4:(lv===1?8:(lv===2?10:11));\n      const yo=w===2&&h===2?(lv===3?2:(lv===2?2.5:3)):w===2?3:(lv===1?5:(lv===2?4:3));\n      // Main building body\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')):w===2?'#ca8a04':(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')); \n      ctx.fillRect(px+2,py+yo+1,wd-4,bh);\n      // Slanted roof (darker top section)\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#ca8a04':(lv===2?'#a16207':'#854d0e')):w===2?'#a16207':(lv===3?'#ca8a04':'#854d0e'); \n      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));\n      // Chimney structure\n      ctx.fillStyle='#6b4423'; \n      const ch=w===2&&h===2?(lv===3?8:(lv===2?7:6)):lv===3?6:5; \n      ctx.fillRect(px+4,py+yo-ch+1,2,ch); \n      if (w===2) ctx.fillRect(px+26,py+yo-ch+1,2,ch);\n      // Chimney top cap\n      ctx.fillStyle='#854d0e'; \n      ctx.fillRect(px+3,py+yo-ch+1,4,1); \n      if (w===2) ctx.fillRect(px+25,py+yo-ch+1,4,1);\n      // Smoke from chimney\n      ctx.fillStyle='#9ca3af'; \n      ctx.fillRect(px+4,py+yo-ch,1,1); \n      ctx.fillRect(px+5,py+yo-ch-1,1,1); \n      if (w===2) { \n        ctx.fillRect(px+26,py+yo-ch,1,1); \n        ctx.fillRect(px+27,py+yo-ch-1,1,1); \n      }\n      // Windows\n      ctx.fillStyle='#fde047'; \n      if (w===2 && h===2) {\n        // More windows for higher level 2x2 buildings\n        const rows=lv===3?3:(lv===2?2:2);\n        for (let r=0; r<rows; r++) {\n          const wy = py+yo+Math.floor(bh*0.35)+(r*5);\n          ctx.fillRect(px+5,wy,2,2); \n          ctx.fillRect(px+9,wy,2,2); \n          ctx.fillRect(px+21,wy,2,2); \n          ctx.fillRect(px+25,wy,2,2);\n        }\n      } else {\n        // Single row of windows for smaller buildings\n        ctx.fillRect(px+5,py+yo+Math.floor(bh*0.55),2,2); \n        ctx.fillRect(px+9,py+yo+Math.floor(bh*0.55),2,2); \n        if (w===2) { \n          ctx.fillRect(px+21,py+yo+Math.floor(bh*0.55),2,2); \n          ctx.fillRect(px+25,py+yo+Math.floor(bh*0.55),2,2); \n        }\n      }\n      // Entrance/door\n      ctx.fillStyle='#713f12'; \n      ctx.fillRect(px+6,py+ht-3,4,3); \n      if (w===2) ctx.fillRect(px+22,py+ht-3,4,3);\n    }\n  } else if (tp.startsWith('park')) {\n    const bc=tp==='park'?'#1d6b2e':(tp==='park2'?'#2a5a3a':(tp==='park3'?'#1a5a2a':'#2d6b1e'));\n    ctx.fillStyle=bc; ctx.fillRect(px,py,wd,ht);\n    if (tp==='park') { \n      ctx.fillStyle='#2a8f3f'; \n      ctx.fillRect(px+4,py+3,3,3); \n      ctx.fillRect(px+9,py+8,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+5,3,3); \n        ctx.fillRect(px+15,py+20,3,3); \n      } \n      ctx.fillStyle='#165a24'; \n      ctx.fillRect(px+2,py+9,2,2); \n      ctx.fillRect(px+11,py+4,2,2); \n      ctx.fillStyle='#6b4423'; \n      ctx.fillRect(px+7,py+6,2,4); \n      if (w===2||h===2) ctx.fillRect(px+23,py+10,2,4); \n    }\n    else if (tp==='park2') { \n      ctx.fillStyle='#ff69b4'; \n      ctx.fillRect(px+4,py+4,2,2); \n      ctx.fillRect(px+9,py+7,2,2); \n      ctx.fillRect(px+6,py+10,2,2); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+6,2,2); \n        ctx.fillRect(px+25,py+9,2,2); \n        ctx.fillRect(px+17,py+20,2,2); \n      } \n      ctx.fillStyle='#ffc0cb'; \n      ctx.fillRect(px+11,py+5,1,1); \n      ctx.fillRect(px+3,py+8,1,1); \n    }\n    else if (tp==='park3') { \n      ctx.fillStyle='#2d5016'; \n      ctx.fillRect(px+5,py+2,3,4); \n      ctx.fillRect(px+10,py+8,3,4); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+4,3,4); \n        ctx.fillRect(px+16,py+20,3,4); \n      } \n      ctx.fillStyle='#1a4010'; \n      ctx.fillRect(px+3,py+10,2,3); \n      ctx.fillRect(px+12,py+5,2,3); \n    }\n    else { \n      ctx.fillStyle='#ffd700'; \n      ctx.fillRect(px+5,py+5,3,3); \n      ctx.fillRect(px+10,py+9,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+7,3,3); \n        ctx.fillRect(px+16,py+20,3,3); \n      } \n      ctx.fillStyle='#8b4513'; \n      ctx.fillRect(px+6,py+8,1,3); \n      ctx.fillRect(px+11,py+12,1,3); \n    }\n  } else if (tp==='police') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#000080'; ctx.fillRect(px+2,py+6,12,10); \n    ctx.fillStyle='#0000a0'; ctx.fillRect(px+2,py+6,12,4); \n    ctx.fillStyle='#ff0000'; ctx.fillRect(px+6,py+7,4,1); \n    ctx.fillStyle='#0000ff'; ctx.fillRect(px+6,py+8,4,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+13,4,3); \n  }\n  else if (tp==='fire') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#8b0000'; ctx.fillRect(px+2,py+6,12,10); \n    ctx.fillStyle='#a00000'; ctx.fillRect(px+2,py+6,12,4); \n    ctx.fillStyle='#5a2a2a'; ctx.fillRect(px+6,py+13,4,3);\n    \n    // Animated flame on top\n    const flameAnim = (Date.now() / 150) % 6;\n    const flameFrame = Math.floor(flameAnim);\n    \n    // Base flame (orange/red) - flickers\n    const baseHeight = flameFrame < 3 ? 3 : 2;\n    ctx.fillStyle = flameFrame % 2 === 0 ? '#ff4500' : '#ff6600';\n    ctx.beginPath();\n    ctx.moveTo(px+6, py+8);\n    ctx.lineTo(px+7, py+8-baseHeight);\n    ctx.lineTo(px+8, py+8-baseHeight+1);\n    ctx.lineTo(px+9, py+8-baseHeight);\n    ctx.lineTo(px+10, py+8);\n    ctx.lineTo(px+8, py+9);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Inner flame (yellow) - smaller flicker\n    const innerHeight = flameFrame < 2 ? 2 : 1;\n    ctx.fillStyle = flameFrame < 4 ? '#ffd700' : '#ffaa00';\n    ctx.beginPath();\n    ctx.moveTo(px+7, py+8);\n    ctx.lineTo(px+8, py+8-innerHeight);\n    ctx.lineTo(px+9, py+8);\n    ctx.lineTo(px+8, py+9);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Hot core (white/yellow)\n    if (flameFrame < 3) {\n      ctx.fillStyle = '#ffff00';\n      ctx.fillRect(px+8, py+7, 1, 1);\n    }\n  }\n  else if (tp==='school') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#daa520'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#b8860b'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+9,py+10,3,3); \n    ctx.fillStyle='#8b4513'; ctx.fillRect(px+4,py+11,3,3); \n  }\n  else if (tp==='hospital') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#d1d5db'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#ff0000'; ctx.fillRect(px+7,py+5,2,5); ctx.fillRect(px+5,py+6,6,2); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='coal') {\n    // Background - industrial ground\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-4,wd-2,3);\n    \n    // Main building - dark brown brick structure (2x2)\n    ctx.fillStyle='#5a3a2a'; ctx.fillRect(px+3,py+12,wd-6,ht-13);\n    \n    // Darker roof\n    ctx.fillStyle='#3a2a1a'; ctx.fillRect(px+3,py+12,wd-6,4);\n    \n    // Two smaller brick smoke stacks\n    ctx.fillStyle='#5a3a2a'; \n    ctx.fillRect(px+8,py+6,2,7);\n    ctx.fillRect(px+22,py+6,2,7);\n    \n    // Stack tops/caps\n    ctx.fillStyle='#6a6a6a';\n    ctx.fillRect(px+7,py+6,4,1);\n    ctx.fillRect(px+21,py+6,4,1);\n    \n    // Animated smoke from stacks\n    const smokeAnim = (Date.now() / 300) % 4; // Animate every 300ms\n    const smokeOffset1 = Math.floor(smokeAnim);\n    const smokeOffset2 = Math.floor((smokeAnim + 2) % 4);\n    \n    // Smoke from left stack\n    ctx.fillStyle='rgba(80,80,80,0.6)'; \n    ctx.fillRect(px+8,py+4-smokeOffset1,2,2);\n    ctx.fillStyle='rgba(100,100,100,0.4)';\n    ctx.fillRect(px+7,py+2-smokeOffset1,3,2);\n    ctx.fillStyle='rgba(120,120,120,0.2)';\n    ctx.fillRect(px+6,py+1-smokeOffset1,4,1);\n    \n    // Smoke from right stack\n    ctx.fillStyle='rgba(80,80,80,0.6)'; \n    ctx.fillRect(px+22,py+4-smokeOffset2,2,2);\n    ctx.fillStyle='rgba(100,100,100,0.4)';\n    ctx.fillRect(px+21,py+2-smokeOffset2,3,2);\n    ctx.fillStyle='rgba(120,120,120,0.2)';\n    ctx.fillRect(px+20,py+1-smokeOffset2,4,1);\n    \n    // Windows (dark) - moved down\n    ctx.fillStyle='#2a2a2a'; \n    ctx.fillRect(px+6,py+18,2,2);\n    ctx.fillRect(px+12,py+18,2,2);\n    ctx.fillRect(px+18,py+18,2,2);\n    ctx.fillRect(px+24,py+18,2,2);\n    ctx.fillRect(px+6,py+24,2,2);\n    ctx.fillRect(px+12,py+24,2,2);\n    ctx.fillRect(px+18,py+24,2,2);\n    ctx.fillRect(px+24,py+24,2,2);\n    \n    // Door at bottom center\n    ctx.fillStyle='#1a1a1a';\n    ctx.fillRect(px+14,py+ht-4,4,3);\n  }\n  else if (tp==='nuclear') {\n    // Background - concrete pad\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#6a6a6a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);\n    \n    // Animated steam from cooling tower (draw FIRST, behind dome)\n    const steamAnim = (Date.now() / 400) % 5;\n    const steamOffset = Math.floor(steamAnim);\n    \n    ctx.fillStyle='rgba(255,255,255,0.7)';\n    ctx.fillRect(px+14,py+6-steamOffset,6,3);\n    ctx.fillStyle='rgba(255,255,255,0.5)';\n    ctx.fillRect(px+13,py+3-steamOffset,8,3);\n    ctx.fillStyle='rgba(255,255,255,0.3)';\n    ctx.fillRect(px+12,py+1-steamOffset,10,2);\n    \n    // Large cooling tower dome (2x2) - gray (draw AFTER steam)\n    ctx.fillStyle='#8a8a8a'; \n    ctx.beginPath(); \n    ctx.arc(px+wd/2,py+14,9,0,Math.PI*2); \n    ctx.fill();\n    // Shading on dome\n    ctx.fillStyle='#6a6a6a';\n    ctx.beginPath();\n    ctx.arc(px+wd/2,py+14,9,Math.PI*0.3,Math.PI*0.7);\n    ctx.fill();\n    \n    // Cooling tower base\n    ctx.fillStyle='#7a7a7a'; \n    ctx.fillRect(px+7,py+21,wd-14,7);\n    \n    // Reactor containment building (left) - gray\n    ctx.fillStyle='#7a7a7a'; \n    ctx.fillRect(px+2,py+18,12,10);\n    ctx.fillStyle='#6a6a6a';\n    ctx.fillRect(px+2,py+18,12,4);\n    \n    // Control building (right) - gray\n    ctx.fillStyle='#8a8a8a';\n    ctx.fillRect(px+wd-13,py+20,11,8);\n    ctx.fillStyle='#7a7a7a';\n    ctx.fillRect(px+wd-13,py+20,11,3);\n    \n    // White line accents on buildings\n    ctx.strokeStyle='#ffffff';\n    ctx.lineWidth=1;\n    // Vertical lines on reactor\n    ctx.beginPath();\n    ctx.moveTo(px+6,py+18);\n    ctx.lineTo(px+6,py+28);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(px+10,py+18);\n    ctx.lineTo(px+10,py+28);\n    ctx.stroke();\n    // Horizontal line on control building\n    ctx.beginPath();\n    ctx.moveTo(px+wd-13,py+23);\n    ctx.lineTo(px+wd-2,py+23);\n    ctx.stroke();\n    \n    // Dark windows\n    ctx.fillStyle='#2a2a2a';\n    ctx.fillRect(px+4,py+22,2,2);\n    ctx.fillRect(px+8,py+22,2,2);\n    ctx.fillRect(px+wd-10,py+23,2,2);\n    ctx.fillRect(px+wd-6,py+23,2,2);\n  }\n  else if (tp==='waterplant') {\n    // Water treatment plant - 2x2 building with realistic clarifier pools\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#3b82f6'; ctx.fillRect(px+1,py+ht-3,wd-2,2);\n    \n    // Calculate rotation angle for pools - using wind turbine animation pattern\n    const rotationSpeed1 = 0.00125; // Slow rotation - 4x slower than before\n    const rotationSpeed2 = 0.001; // Slightly different speed\n    const angle1 = (Date.now() * rotationSpeed1) % (Math.PI * 2);\n    const angle2 = (Date.now() * rotationSpeed2) % (Math.PI * 2);\n    \n    // Left clarifier pool (large circular pool)\n    const pool1CenterX = px + 11;\n    const pool1CenterY = py + 9;\n    const pool1Radius = 7;\n    \n    // Pool 1 - outer concrete rim (blue)\n    ctx.fillStyle='#60a5fa';\n    ctx.beginPath();\n    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 1 - water (deep blue)\n    ctx.fillStyle='#1e40af';\n    ctx.beginPath();\n    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius - 1.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 1 - water surface reflection (lighter blue with gradient effect)\n    ctx.fillStyle='#2563eb';\n    ctx.beginPath();\n    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius - 2.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 1 - rotating arm (clarifier rake)\n    ctx.save();\n    ctx.translate(pool1CenterX, pool1CenterY);\n    ctx.rotate(angle1);\n    ctx.fillStyle='#d0d0d0';\n    ctx.fillRect(-1, -0.5, pool1Radius - 2, 1); // Arm\n    ctx.fillStyle='#b0b0b0';\n    ctx.beginPath();\n    ctx.arc(0, 0, 1.5, 0, Math.PI * 2); // Center hub\n    ctx.fill();\n    ctx.restore();\n    \n    // Right clarifier pool (large circular pool)\n    const pool2CenterX = px + 23;\n    const pool2CenterY = py + 21;\n    const pool2Radius = 7;\n    \n    // Pool 2 - outer concrete rim (blue)\n    ctx.fillStyle='#60a5fa';\n    ctx.beginPath();\n    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 2 - water (deep blue)\n    ctx.fillStyle='#1e40af';\n    ctx.beginPath();\n    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius - 1.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 2 - water surface reflection (lighter blue)\n    ctx.fillStyle='#2563eb';\n    ctx.beginPath();\n    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius - 2.5, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Pool 2 - rotating arm (clarifier rake) - rotates opposite direction\n    ctx.save();\n    ctx.translate(pool2CenterX, pool2CenterY);\n    ctx.rotate(-angle2);\n    ctx.fillStyle='#d0d0d0';\n    ctx.fillRect(-1, -0.5, pool2Radius - 2, 1); // Arm\n    ctx.fillStyle='#b0b0b0';\n    ctx.beginPath();\n    ctx.arc(0, 0, 1.5, 0, Math.PI * 2); // Center hub\n    ctx.fill();\n    ctx.restore();\n    \n    // Small control building on the left side - drawn AFTER pools so it appears in front (blue)\n    ctx.fillStyle='#3b82f6'; ctx.fillRect(px+3,py+ht-12,11,11);\n    ctx.fillStyle='#2563eb'; ctx.fillRect(px+3,py+ht-12,11,3);\n    ctx.fillStyle='#1e40af';\n    ctx.fillRect(px+5,py+ht-8,2,2);\n    ctx.fillRect(px+9,py+ht-8,2,2);\n  }\n  else if (tp==='watertower') {\n    // Water tower - elevated tank on support structure\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ);\n    \n    // Support structure (metal frame)\n    ctx.fillStyle='#5a5a5a';\n    ctx.fillRect(px+6,py+8,4,8); // Center column\n    \n    // Support legs\n    ctx.fillStyle='#4a4a4a';\n    ctx.fillRect(px+4,py+12,2,4);\n    ctx.fillRect(px+10,py+12,2,4);\n    \n    // Cross braces\n    ctx.fillRect(px+5,py+10,6,1);\n    ctx.fillRect(px+5,py+14,6,1);\n    \n    // Large water tank on top\n    ctx.fillStyle='#6a6a6a'; // Tank body\n    ctx.beginPath();\n    ctx.arc(px+8,py+6,5,0,Math.PI*2);\n    ctx.fill();\n    \n    // Water inside tank (visible) - bright blue\n    ctx.fillStyle='#2563eb';\n    ctx.beginPath();\n    ctx.arc(px+8,py+7,3.5,0,Math.PI*2);\n    ctx.fill();\n    \n    // Water surface reflection (lighter)\n    ctx.fillStyle='#3b82f6';\n    ctx.fillRect(px+5,py+6,6,1);\n    \n    // Tank rim/top\n    ctx.fillStyle='#7a7a7a';\n    ctx.fillRect(px+3,py+4,10,2);\n    \n    // Access ladder\n    ctx.fillStyle='#3a3a3a';\n    ctx.fillRect(px+11,py+8,1,8);\n    ctx.fillRect(px+10,py+10,2,1);\n    ctx.fillRect(px+10,py+12,2,1);\n    ctx.fillRect(px+10,py+14,2,1);\n  }\n  else if (tp==='wind') {\n    // Background - grass with service road\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);\n    \n    // Thin tall tower (1x2 building, so ht = 32)\n    ctx.fillStyle='#d0d0d0'; \n    // Thin tower that gets slightly wider at bottom\n    ctx.fillRect(px+7,py+6,2,ht-9);\n    ctx.fillRect(px+6,py+ht-8,4,5);\n    \n    // Tower shading\n    ctx.fillStyle='#b0b0b0';\n    ctx.fillRect(px+7,py+6,1,ht-9);\n    \n    // Concrete base\n    ctx.fillStyle='#8a8a8a';\n    ctx.fillRect(px+5,py+ht-3,6,2);\n    \n    // Hub at top\n    const hubX = px+8;\n    const hubY = py+6;\n    ctx.fillStyle='#c0c0c0';\n    ctx.beginPath();\n    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);\n    ctx.fill();\n    \n    // Rotating turbine blades\n    // Use Date.now() for smooth continuous animation\n    const rotationSpeed = 0.002; // Adjust for faster/slower rotation\n    const rotation = (Date.now() * rotationSpeed) % (Math.PI * 2);\n    \n    ctx.save();\n    ctx.translate(hubX, hubY);\n    ctx.rotate(rotation);\n    \n    // Three large turbine blades (white) - drawn at 120 degree intervals\n    ctx.fillStyle='#ffffff';\n    ctx.strokeStyle='#b0b0b0';\n    ctx.lineWidth=0.8;\n    \n    for (let i=0; i<3; i++) {\n      ctx.save();\n      ctx.rotate((i * Math.PI * 2 / 3));\n      // Blade pointing upward\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-1, -6);\n      ctx.lineTo(1, -6);\n      ctx.lineTo(0, 0);\n      ctx.fill();\n      ctx.stroke();\n      ctx.restore();\n    }\n    \n    ctx.restore();\n    \n    // Redraw hub on top of blades\n    ctx.fillStyle='#c0c0c0';\n    ctx.beginPath();\n    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);\n    ctx.fill();\n  }\n  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,wd,ht);\n  \n  // Draw power/water warning indicators if building needs them but doesn't have them\n  if (needsPowerButNoPower && !ab) {\n    // Flash effect - show bolt every other half-second\n    const flashOn = Math.floor(Date.now() / 500) % 2 === 0;\n    if (flashOn) {\n      ctx.save();\n      // Draw a yellow lightning bolt in the top-right corner\n      const indicatorSize = 10;\n      const indicatorX = px + wd - indicatorSize - 1;\n      const indicatorY = py + 1;\n      \n      // Draw yellow lightning bolt\n      ctx.fillStyle = '#ffff00';\n      ctx.beginPath();\n      // Lightning bolt shape\n      ctx.moveTo(indicatorX + indicatorSize/2 + 2, indicatorY);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 2, indicatorY + indicatorSize/2);\n      ctx.lineTo(indicatorX + indicatorSize/2 + 1, indicatorY + indicatorSize/2);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 3, indicatorY + indicatorSize);\n      ctx.lineTo(indicatorX + indicatorSize/2 + 2, indicatorY + indicatorSize/2 + 2);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 1, indicatorY + indicatorSize/2 + 2);\n      ctx.closePath();\n      ctx.fill();\n      \n      ctx.restore();\n    }\n  }\n  \n  if (needsWaterButNoWater && !ab) {\n    // Animated water drop indicator - drips down\n    const dropAnim = (Date.now() / 400) % 4; // 4-frame animation\n    const dropFrame = Math.floor(dropAnim);\n    \n    ctx.save();\n    const indicatorX = px + 2;\n    const indicatorY = py + 2;\n    \n    // Water drop animates falling down\n    const yOffset = dropFrame; // 0, 1, 2, 3 pixels down\n    const dropY = indicatorY + yOffset;\n    \n    // Draw water drop shape (teardrop)\n    if (dropFrame < 3) {\n      // Main drop body (bright blue matching water tile hue)\n      ctx.fillStyle = dropFrame % 2 === 0 ? '#3b82f6' : '#60a5fa';\n      ctx.beginPath();\n      // Top curve\n      ctx.arc(indicatorX + 3, dropY + 2, 2.5, Math.PI, 0, false);\n      // Point at bottom\n      ctx.lineTo(indicatorX + 5.5, dropY + 6);\n      ctx.lineTo(indicatorX + 3, dropY + 7);\n      ctx.lineTo(indicatorX + 0.5, dropY + 6);\n      ctx.closePath();\n      ctx.fill();\n      \n      // Highlight/shine\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.fillRect(indicatorX + 2, dropY + 3, 1, 2);\n    } else {\n      // Splash effect at bottom (frame 3)\n      ctx.fillStyle = '#3b82f6';\n      // Small splash particles\n      ctx.fillRect(indicatorX, dropY + 6, 2, 1);\n      ctx.fillRect(indicatorX + 4, dropY + 6, 2, 1);\n      ctx.fillRect(indicatorX + 2, dropY + 5, 2, 1);\n    }\n    \n    ctx.restore();\n  }\n}\n\nfunction drGr() {\n  ctx.clearRect(0,0,cvs.width,cvs.height); const drn={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (drn[k]) continue;\n    const c=st.grid[y][x]; drTl(x,y,c.type,c.level||0,c.abandoned||false,c.w||1,c.h||1);\n    for (let dy=0; dy<(c.h||1); dy++) for (let dx=0; dx<(c.w||1); dx++) drn[`${x+dx},${y+dy}`]=true;\n  }\n  \n  // Draw pipes on multi-tile buildings after all buildings are drawn to avoid black tiles\n  if (showWaterOverlay) {\n    for (let y=0; y<GR_SZ; y++) {\n      for (let x=0; x<GR_SZ; x++) {\n        const c = st.grid[y][x];\n        if (c.pipe && (c.w > 1 || c.h > 1)) {\n          const px = x * CL_SZ, py = y * CL_SZ;\n          const nb = getPipeNb(x, y);\n          const ht = nb.top, hr = nb.right, hb = nb.bottom, hl = nb.left;\n          const rc = (ht ? 1 : 0) + (hr ? 1 : 0) + (hb ? 1 : 0) + (hl ? 1 : 0);\n          ctx.fillStyle = 'rgba(96,165,250,0.4)'; // Brighter blue with higher opacity\n          ctx.fillRect(px, py, CL_SZ, CL_SZ);\n          ctx.fillStyle = 'rgba(59,130,246,0.7)'; // Brighter blue for pipe connections\n          \n          // Draw pipe connections similar to roads\n          if (rc === 4) { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px, py+6, CL_SZ, 4); }\n          else if (rc === 3) {\n            if (!ht) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px, py+6, CL_SZ, 4); }\n            else if (!hr) { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px, py+6, 10, 4); }\n            else if (!hb) { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px, py+6, CL_SZ, 4); }\n            else { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }\n          } else if (rc === 2) {\n            if ((ht && hb) || (!hl && !hr)) { ctx.fillRect(px+6, py, 4, CL_SZ); }\n            else if ((hl && hr) || (!ht && !hb)) { ctx.fillRect(px, py+6, CL_SZ, 4); }\n            else if (ht && hr) { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }\n            else if (hr && hb) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }\n            else if (hb && hl) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px, py+6, 10, 4); }\n            else { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px, py+6, 10, 4); }\n          } else if (rc === 1) {\n            if (ht || hb) { ctx.fillRect(px+6, py, 4, CL_SZ); }\n            else { ctx.fillRect(px, py+6, CL_SZ, 4); }\n          } else { ctx.fillRect(px+6, py, 4, CL_SZ); }\n        }\n      }\n    }\n  }\n  \n  if (showLandValueOverlay) drawLandValueOverlay();\n  if (showCrimeOverlay) drawCrimeOverlay();\n  if (showWaterOverlay) drawWaterOverlay();\n  \n  // Draw placement preview when hovering (skip on mobile/touch devices)\n  if (hoverPos && st.selectedTool && !showLandValueOverlay && !showCrimeOverlay && !isMobile) {\n    const x = hoverPos.x, y = hoverPos.y;\n    if (x >= 0 && x < GR_SZ && y >= 0 && y < GR_SZ) {\n      if (st.selectedTool === 'bulldoze') {\n        // Bulldoze mode - highlight target in red\n        cvs.style.cursor = 'crosshair';\n        const c = st.grid[y][x];\n        let bx = x, by = y, bw = 1, bh = 1;\n        \n        // If hovering over a building, highlight the whole building\n        if (c && c.type !== 'empty') {\n          const bounds = getBuildingBoundsFromCell(x, y);\n          bx = bounds.startX;\n          by = bounds.startY;\n          bw = bounds.w;\n          bh = bounds.h;\n        }\n        \n        ctx.strokeStyle = 'rgba(248, 113, 113, 0.8)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(bx * CL_SZ, by * CL_SZ, bw * CL_SZ, bh * CL_SZ);\n        ctx.fillStyle = 'rgba(248, 113, 113, 0.3)';\n        ctx.fillRect(bx * CL_SZ, by * CL_SZ, bw * CL_SZ, bh * CL_SZ);\n      } else {\n        // Normal tool placement preview\n        // Determine building size\n        let bw = 1, bh = 1;\n      if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {\n        bw = 2; bh = 2;\n      } else if (st.selectedTool === 'wind') {\n        bw = 1; bh = 2;\n      } else if (st.selectedTool === 'waterplant') {\n        bw = 2; bh = 2;\n      } else if (st.selectedTool === 'watertower') {\n        bw = 1; bh = 1;\n      } else if (st.selectedTool === 'pipe') {\n        bw = 1; bh = 1;\n      }\n      \n      // Check if placement is valid\n      let valid = true;\n      const c = st.grid[y][x];\n      const tr = st.terrain[y][x];\n      // Pipes can be on water tiles, but not cliffs. Other buildings can't be on water or cliffs.\n      if (st.selectedTool === 'pipe') {\n        if (tr === 'cliff') valid = false;\n      } else {\n        if (tr === 'water' || tr === 'cliff') valid = false;\n      }\n      \n      const isPk = st.selectedTool.startsWith('park');\n      const isWaterTool = st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower';\n      \n      if (bw > 1 || bh > 1) {\n        for (let dy=0; dy<bh; dy++) {\n          for (let dx=0; dx<bw; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (nx >= GR_SZ || ny >= GR_SZ) { valid = false; break; }\n            const nc = st.grid[ny][nx];\n            const ntr = st.terrain[ny][nx];\n            // Pipes can be on water tiles, but not cliffs. Other buildings can't be on water or cliffs.\n            if (st.selectedTool === 'pipe') {\n              if (ntr === 'cliff') { valid = false; break; }\n            } else {\n              if (ntr === 'water' || ntr === 'cliff') { valid = false; break; }\n            }\n            const isZone = nc.type === 'residential' || nc.type === 'commercial' || nc.type === 'industrial';\n            const isEmptyZone = isZone && (nc.level === 0 || nc.abandoned);\n            if (isPk) {\n              if (nc.type !== 'empty' && !isEmptyZone) { valid = false; break; }\n            } else if (isWaterTool) {\n              // Pipes can overlay on any tile except water plants/towers\n              if (st.selectedTool === 'pipe' && (nc.type === 'waterplant' || nc.type === 'watertower')) { valid = false; break; }\n              // Water plants/towers need empty or abandoned tiles\n              if (st.selectedTool !== 'pipe' && nc.type !== 'empty' && !nc.abandoned) { valid = false; break; }\n            } else {\n              if (nc.type !== 'empty' && !nc.abandoned) { valid = false; break; }\n            }\n          }\n          if (!valid) break;\n        }\n        // Water plants must be within 2 tiles of water\n        if (valid && (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower')) {\n          let nearWater = false;\n          for (let dy=0; dy<bh; dy++) {\n            for (let dx=0; dx<bw; dx++) {\n              const nx = x + dx, ny = y + dy;\n              if (isNearWaterTile(nx, ny, 2)) {\n                nearWater = true;\n                break;\n              }\n            }\n            if (nearWater) break;\n          }\n          if (!nearWater) valid = false;\n        }\n      } else {\n        const isZone = c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial';\n        const isEmptyZone = isZone && (c.level === 0 || c.abandoned);\n        if (isPk) {\n          if (c.type !== 'empty' && !isEmptyZone) valid = false;\n        } else if (isWaterTool) {\n          // Pipes can overlay on any tile except water plants/towers\n          if (st.selectedTool === 'pipe' && (c.type === 'waterplant' || c.type === 'watertower')) valid = false;\n          // Water plants/towers need empty or abandoned tiles\n          if (st.selectedTool !== 'pipe' && c.type !== 'empty' && !c.abandoned) valid = false;\n          // Water towers must be within 4 tiles of water\n          if (st.selectedTool === 'watertower' && !isNearWaterTile(x, y, 4)) valid = false;\n        } else {\n          if (c.type !== 'empty' && !c.abandoned) valid = false;\n        }\n      }\n      \n      // Set cursor based on validity\n      if (valid) {\n        cvs.style.cursor = 'crosshair';\n      } else {\n        // Use default cursor for roads, help cursor for other invalid placements\n        const c = st.grid[y][x];\n        if (c && c.type === 'road') {\n          cvs.style.cursor = 'default';\n        } else {\n          cvs.style.cursor = 'help'; // Info cursor when invalid (implies clicking will inspect)\n        }\n      }\n      \n      // Draw placement preview if valid\n      if (valid) {\n        ctx.save();\n        const px = x * CL_SZ, py = y * CL_SZ;\n        \n        // Draw the actual tile design semi-transparently\n        ctx.globalAlpha = 0.6;\n        drTl(x, y, st.selectedTool, 0, false, bw, bh);\n        ctx.globalAlpha = 1.0;\n        \n        // Draw semi-transparent white border around the building footprint\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(px, py, bw * CL_SZ, bh * CL_SZ);\n        ctx.restore();\n      }\n      // Note: Invalid placement red highlight removed as per request\n    }\n  } else if (hoverPos && (showLandValueOverlay || showCrimeOverlay)) {\n    // Stat view mode - set cursor based on building type\n    const x = hoverPos.x, y = hoverPos.y;\n    if (x >= 0 && x < GR_SZ && y >= 0 && y < GR_SZ) {\n      const c = st.grid[y][x];\n      if (c && c.type !== 'empty' && c.type !== 'road') {\n        cvs.style.cursor = 'pointer'; // Pointer cursor for buildings (not roads)\n      } else {\n        cvs.style.cursor = 'default'; // Default cursor for roads and empty tiles\n      }\n    } else {\n      cvs.style.cursor = 'default';\n    }\n  } else {\n    // Reset cursor if no hover or no tool\n    cvs.style.cursor = 'default';\n  }\n}\n  \n  // Draw highlighted building border\n  if (highlightedBuilding) {\n    ctx.save();\n    ctx.strokeStyle = '#ffffff';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(\n      highlightedBuilding.x * CL_SZ + 1,\n      highlightedBuilding.y * CL_SZ + 1,\n      highlightedBuilding.w * CL_SZ - 2,\n      highlightedBuilding.h * CL_SZ - 2\n    );\n    ctx.restore();\n  }\n  \n  // Draw highlighted workplace border\n  if (highlightedWorkplace) {\n    ctx.save();\n    ctx.strokeStyle = '#3b82f6';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(\n      highlightedWorkplace.x * CL_SZ + 1,\n      highlightedWorkplace.y * CL_SZ + 1,\n      highlightedWorkplace.w * CL_SZ - 2,\n      highlightedWorkplace.h * CL_SZ - 2\n    );\n    ctx.restore();\n  }\n  \n  st.fires.forEach(f => {\n    if (f.age < 20) {\n      const fx = f.x * CL_SZ;\n      const fy = f.y * CL_SZ;\n\n      // Time-based animation for smooth flicker and wobble\n      const t = Date.now() / 160 + (f.x * 0.7 + f.y * 0.3);\n      const wobble = Math.sin(t) * 1.5;\n      const heightPulse = 1 + Math.sin(t * 1.7) * 0.6;\n\n      // Base positions (slightly offset down on Y)\n      const yOffset = 1; // move flame a bit lower in the tile\n      const baseY = fy + 14 + yOffset;\n      const centerX = fx + 8;\n\n      ctx.save();\n\n      // --- Outer glow (soft red/orange halo) ---\n      ctx.fillStyle = 'rgba(255, 80, 0, 0.25)';\n      ctx.beginPath();\n      ctx.ellipse(centerX, fy + 9 + yOffset, 7 + Math.abs(wobble), 7 * heightPulse, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // --- Base flame (deep orange) ---\n      ctx.fillStyle = '#ff4b1f';\n      ctx.beginPath();\n      ctx.moveTo(centerX - (4 + wobble), baseY);\n      ctx.lineTo(centerX - 2.5, fy + 10 + yOffset);\n      ctx.lineTo(centerX - 3, fy + 8 + yOffset);\n      ctx.lineTo(centerX - 0.5 + wobble, fy + yOffset + 5 * heightPulse);\n      ctx.lineTo(centerX, fy + yOffset + 3 * heightPulse);\n      ctx.lineTo(centerX + 0.5 + wobble, fy + yOffset + 5 * heightPulse);\n      ctx.lineTo(centerX + 3, fy + 8 + yOffset);\n      ctx.lineTo(centerX + 2.5, fy + 10 + yOffset);\n      ctx.lineTo(centerX + (4 - wobble), baseY);\n      ctx.closePath();\n      ctx.fill();\n\n      // --- Mid flame (bright orange/yellow, slightly narrower) ---\n      const midPhase = (Math.sin(t * 1.3) + 1) / 2; // 0..1\n      const midColor = midPhase < 0.5 ? '#ffb347' : '#ffd166';\n      ctx.fillStyle = midColor;\n      ctx.beginPath();\n      ctx.moveTo(centerX - 2.5, baseY - 2);\n      ctx.lineTo(centerX - 1.5, fy + 10 + yOffset);\n      ctx.lineTo(centerX - 1, fy + 8 + yOffset);\n      ctx.lineTo(centerX, fy + yOffset + 5 * heightPulse - 1);\n      ctx.lineTo(centerX + 1, fy + 8 + yOffset);\n      ctx.lineTo(centerX + 1.5, fy + 10 + yOffset);\n      ctx.lineTo(centerX + 2.5, baseY - 2);\n      ctx.closePath();\n      ctx.fill();\n\n      // --- Inner flame (white/hot core, animated height) ---\n      const innerHeight = 4 * heightPulse;\n      ctx.fillStyle = '#fff8c6';\n      ctx.beginPath();\n      ctx.moveTo(centerX - 0.8, baseY - 2);\n      ctx.lineTo(centerX - 0.6, fy + 10 + yOffset);\n      ctx.lineTo(centerX, fy + 10 + yOffset - innerHeight);\n      ctx.lineTo(centerX + 0.6, fy + 10 + yOffset);\n      ctx.lineTo(centerX + 0.8, baseY - 2);\n      ctx.closePath();\n      ctx.fill();\n\n      // --- Small sparks/flickers above the flame ---\n      const sparkPhase = (Math.floor(t / 4) % 3);\n      ctx.fillStyle = '#ffff66';\n      if (sparkPhase === 0) {\n        ctx.fillRect(centerX - 2, fy + 3 + yOffset, 1, 1);\n        ctx.fillRect(centerX + 1, fy + 4 + yOffset, 1, 1);\n      } else if (sparkPhase === 1) {\n        ctx.fillRect(centerX - 1, fy + 2 + yOffset, 1, 1);\n        ctx.fillRect(centerX + 2, fy + 3 + yOffset, 1, 1);\n      } else {\n        ctx.fillRect(centerX - 3, fy + 4 + yOffset, 1, 1);\n        ctx.fillRect(centerX + 0, fy + 2 + yOffset, 1, 1);\n      }\n\n      ctx.restore();\n    }\n  });\n  st.crimeEvents.forEach(evt => {\n    if (evt.age<20) {\n      const cx = evt.x * CL_SZ;\n      const cy = evt.y * CL_SZ;\n      const anim = evt.age % 4;\n      \n      ctx.save();\n      \n      // Draw pulsing circle (siren effect)\n      const pulseSize = anim < 2 ? 1 : 0.7;\n      ctx.fillStyle = anim < 2 ? 'rgba(220, 20, 60, 0.6)' : 'rgba(255, 0, 0, 0.4)';\n      ctx.beginPath();\n      ctx.arc(cx + 8, cy + 8, 6 * pulseSize, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw siren light (alternating red/blue)\n      ctx.fillStyle = anim < 2 ? '#dc143c' : '#0066ff';\n      ctx.beginPath();\n      ctx.arc(cx + 8, cy + 8, 3, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw exclamation mark\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(cx + 7.5, cy + 6, 1, 3);\n      ctx.fillRect(cx + 7.5, cy + 10, 1, 1);\n      \n      // Draw light rays\n      if (anim < 2) {\n        ctx.strokeStyle = 'rgba(220, 20, 60, 0.5)';\n        ctx.lineWidth = 1;\n        for (let i = 0; i < 8; i++) {\n          const angle = (i * Math.PI / 4) + (evt.age * 0.3);\n          ctx.beginPath();\n          ctx.moveTo(cx + 8, cy + 8);\n          ctx.lineTo(cx + 8 + Math.cos(angle) * 8, cy + 8 + Math.sin(angle) * 8);\n          ctx.stroke();\n        }\n      }\n      \n      ctx.restore();\n    }\n  });\n  st.cars.forEach(c => {\n    ctx.save();\n    \n    // Check if this is a followed resident's car\n    const isFollowed = c.residentId && c.residentId === followedResident;\n    \n    // Determine car direction for rotation\n    let angle = 0; // Default: horizontal (0 degrees)\n    const isReturning = c.mission && c.mission.returning;\n    \n    if (c.path && c.path.length > 1 && c.pathIdx < c.path.length - 1) {\n      const curNode = c.path[c.pathIdx];\n      const nextNode = c.path[c.pathIdx + 1];\n      const dx = nextNode.x - curNode.x;\n      const dy = nextNode.y - curNode.y;\n      \n      // If moving vertically (more vertical than horizontal), rotate 90 degrees\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2; // 90 degrees\n      }\n      // If returning, reverse the direction (add 180 degrees)\n      if (isReturning) {\n        angle += Math.PI;\n      }\n    } else if (c.entering && c.entryTarget) {\n      // Check direction to entry target\n      const dx = c.entryTarget.x - c.x;\n      const dy = c.entryTarget.y - c.y;\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2;\n      }\n      // If returning, reverse the direction\n      if (isReturning) {\n        angle += Math.PI;\n      }\n    } else if (c.exiting && c.exitTarget) {\n      // Check direction to exit target\n      const dx = c.exitTarget.x - c.x;\n      const dy = c.exitTarget.y - c.y;\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2;\n      }\n      // If returning, reverse the direction\n      if (isReturning) {\n        angle += Math.PI;\n      }\n    } else if (c.path && c.path.length > 0 && c.pathIdx < c.path.length) {\n      // Fallback: check movement direction from current position\n      const nextTarget = getCarSegmentTarget(c);\n      if (nextTarget) {\n        const dx = nextTarget.tx - c.x;\n        const dy = nextTarget.ty - c.y;\n        if (Math.abs(dy) > Math.abs(dx)) {\n          angle = Math.PI / 2;\n        }\n        // If returning, reverse the direction\n        if (isReturning) {\n          angle += Math.PI;\n        }\n      }\n    }\n    \n    // Special handling for returning vehicles when path is very short or at end\n    // Use direction to station when station is adjacent to scene\n    if (isReturning && c.stationRoad && angle === 0) {\n      // Check if we need to calculate angle based on direction to station\n      // This handles cases where path is very short (station adjacent to scene)\n      const pathTooShort = !c.path || c.path.length <= 1;\n      const atPathEnd = c.path && c.pathIdx >= c.path.length - 1;\n      const noClearDirection = !c.entering && !c.exiting && !c.entryTarget && !c.exitTarget;\n      \n      if (pathTooShort || (atPathEnd && noClearDirection)) {\n        // Try to get direction from path if available (even if at end)\n        if (c.path && c.path.length >= 2 && c.pathIdx < c.path.length) {\n          const curNode = c.path[Math.min(c.pathIdx, c.path.length - 1)];\n          const prevNode = c.pathIdx > 0 ? c.path[c.pathIdx - 1] : null;\n          const nextNode = c.pathIdx < c.path.length - 1 ? c.path[c.pathIdx + 1] : null;\n          \n          if (nextNode) {\n            // Use next node direction\n            const dx = nextNode.x - curNode.x;\n            const dy = nextNode.y - curNode.y;\n            if (Math.abs(dy) > Math.abs(dx)) {\n              angle = Math.PI / 2;\n            }\n            angle += Math.PI; // Reverse for returning\n          } else if (prevNode) {\n            // Use previous node direction (we're moving from prev to current)\n            const dx = curNode.x - prevNode.x;\n            const dy = curNode.y - prevNode.y;\n            if (Math.abs(dy) > Math.abs(dx)) {\n              angle = Math.PI / 2;\n            }\n            angle += Math.PI; // Reverse for returning\n          }\n        }\n        \n        // Fallback: use direction to station\n        if (angle === 0) {\n          const stationCenter = getRoadCenterCoords(c.stationRoad);\n          const dx = stationCenter.x - c.x;\n          const dy = stationCenter.y - c.y;\n          // Only update if we have a meaningful direction\n          if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {\n            // Calculate base angle based on direction to station\n            if (Math.abs(dy) > Math.abs(dx)) {\n              angle = Math.PI / 2;\n            } else {\n              angle = 0;\n            }\n            // For returning vehicles, reverse the direction (face backward/away from station)\n            angle += Math.PI;\n          }\n        }\n      }\n    }\n    \n      // Translate to car center, rotate, then translate back\n      let carWidth = 3, carHeight = 2;\n      if (c.type === 'fire') {\n        carWidth = 7; // Fire trucks are longer\n        carHeight = 4;\n      } else if (c.type === 'police') {\n        carWidth = 5;\n        carHeight = 4;\n      }\n      const halfWidth = carWidth / 2;\n      const halfHeight = carHeight / 2;\n      let drawX = c.x;\n      let drawY = c.y;\n      let carCenterX = drawX + halfWidth;\n      let carCenterY = drawY + halfHeight;\n      const isVertical = Math.abs(Math.abs(angle) - Math.PI / 2) < 0.001;\n      if (isVertical) {\n        const snappedCenterX = snapCenterToPixelGrid(carCenterX, halfHeight);\n        const snappedCenterY = snapCenterToPixelGrid(carCenterY, halfWidth);\n        drawX += snappedCenterX - carCenterX;\n        drawY += snappedCenterY - carCenterY;\n        carCenterX = snappedCenterX;\n        carCenterY = snappedCenterY;\n      }\n      ctx.translate(carCenterX, carCenterY);\n      ctx.rotate(angle);\n      ctx.translate(-carCenterX, -carCenterY);\n    \n    // Draw emergency vehicles with special styling\n    if (c.type === 'police') {\n      // Police car: dark gray body with single red/blue siren\n      ctx.fillStyle = '#1a1a1a'; // Very dark gray, almost black\n      // Body centered on the same lane center as regular cars\n      ctx.fillRect(drawX, drawY, carWidth, carHeight);\n\n      // Single red/blue alternating siren on top center\n      const time = Date.now() / 200; // Blinking effect\n      const redOn = Math.floor(time) % 2 === 0;\n      ctx.fillStyle = redOn ? '#ff0000' : '#0066ff'; // Red or blue\n\n      const sirenWidth = 2;\n      const sirenHeight = 1;\n      const sirenX = drawX + (carWidth - sirenWidth) / 2;\n      const sirenY = drawY - 1;\n      ctx.fillRect(Math.round(sirenX), sirenY, sirenWidth, sirenHeight);\n    } else if (c.type === 'fire') {\n      // Fire truck: longer body with single side-mounted flashing siren\n      ctx.fillStyle = '#8b0000';\n      // Body centered on the same lane center as regular cars\n      ctx.fillRect(drawX, drawY, carWidth, carHeight);\n\n      // Single side siren (left side) alternating bright red/yellow\n      const time = Date.now() / 200; // Blinking effect\n      const redOn = Math.floor(time) % 2 === 0;\n      ctx.fillStyle = redOn ? '#ff3333' : '#ffff00';\n\n      const sirenWidth = 1;\n      const sirenHeight = 2;\n      const sirenX = drawX - sirenWidth; // Just to the left of the truck body\n      const sirenY = drawY + (carHeight - sirenHeight) / 2;\n      ctx.fillRect(sirenX, Math.round(sirenY), sirenWidth, sirenHeight);\n    } else {\n      // Regular cars\n      ctx.fillStyle = c.color;\n      ctx.fillRect(drawX, drawY, 3, 2);\n    }\n    \n    // Draw highlight for followed resident's car\n    if (isFollowed) {\n      ctx.save();\n      // Determine car dimensions\n      let carW = 3, carH = 2;\n      if (c.type === 'fire') {\n        carW = 7; carH = 4;\n      } else if (c.type === 'police') {\n        carW = 5; carH = 4;\n      }\n      \n      ctx.strokeStyle = '#ffeb3b';\n      ctx.lineWidth = 2;\n      ctx.shadowBlur = 8;\n      ctx.shadowColor = '#ffeb3b';\n      ctx.strokeRect(drawX - 1, drawY - 1, carW + 2, carH + 2);\n      \n      // Draw a pulsing circle indicator above the car\n      const pulseTime = Date.now() / 500;\n      const pulseSize = 0.5 + Math.sin(pulseTime) * 0.3;\n      ctx.fillStyle = 'rgba(255, 235, 59, 0.8)';\n      ctx.beginPath();\n      ctx.arc(carCenterX, drawY - 4, 3 * pulseSize, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n    \n    ctx.restore();\n  });\n}\n\nfunction drawLandValueOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getLandValueOverlayColor(st.landValue[y][x]);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getLandValueOverlayColor(value) {\n  const ratio=Math.max(0,Math.min(1,(value||0)/100));\n  const r=Math.round(LAND_VALUE_LOW_COLOR.r+(LAND_VALUE_HIGH_COLOR.r-LAND_VALUE_LOW_COLOR.r)*ratio);\n  const g=Math.round(LAND_VALUE_LOW_COLOR.g+(LAND_VALUE_HIGH_COLOR.g-LAND_VALUE_LOW_COLOR.g)*ratio);\n  const b=Math.round(LAND_VALUE_LOW_COLOR.b+(LAND_VALUE_HIGH_COLOR.b-LAND_VALUE_LOW_COLOR.b)*ratio);\n  return `rgba(${r},${g},${b},0.4)`;\n}\n\nfunction setLandValueOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showLandValueOverlay=true;\n    updLV();\n    drGr();\n    // Update status text to indicate stats mode\n    const sTx = document.getElementById('statusText');\n    sTx.textContent = 'click buildings to view details';\n    return;\n  }\n  if (showLandValueOverlay) {\n    showLandValueOverlay=false;\n    hideBuildingInfo();\n    drGr();\n    // Restore status text\n    const sTx = document.getElementById('statusText');\n    if (st.selectedTool) {\n      const tl = st.selectedTool;\n      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';\n      else {\n        const dn = tl.startsWith('park') ? 'park' : tl;\n        sTx.textContent = `placing ${dn}`;\n      }\n    } else {\n      sTx.textContent = 'select a tool to start building';\n    }\n  }\n}\n\nfunction drawCrimeOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getCrimeOverlayColor(st.crime[y][x]||30);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getCrimeOverlayColor(value) {\n  const crimeLevel=Math.max(0,Math.min(100,value||30));\n  let r, g, b;\n  if (crimeLevel>=70) {\n    // High crime: red (255,0,0) to dark red (200,0,0)\n    const ratio=(crimeLevel-70)/30;\n    r=Math.round(200+55*ratio);\n    g=0;\n    b=0;\n  } else if (crimeLevel>=30) {\n    // Medium crime: yellow (255,255,0) to red (255,0,0)\n    const ratio=(crimeLevel-30)/40;\n    r=255;\n    g=Math.round(255*(1-ratio));\n    b=0;\n  } else {\n    // Low crime: green (0,255,0) to yellow (255,255,0)\n    const ratio=crimeLevel/30;\n    r=Math.round(255*ratio);\n    g=255;\n    b=0;\n  }\n  return `rgba(${r},${g},${b},0.5)`;\n}\n\nfunction setCrimeOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showCrimeOverlay=true;\n    updCrime();\n    drGr();\n    // Update status text to indicate stats mode\n    const sTx = document.getElementById('statusText');\n    sTx.textContent = 'click buildings to view details';\n    return;\n  }\n  if (showCrimeOverlay) {\n    showCrimeOverlay=false;\n    hideBuildingInfo();\n    drGr();\n    // Restore status text\n    const sTx = document.getElementById('statusText');\n    if (st.selectedTool) {\n      const tl = st.selectedTool;\n      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';\n      else {\n        const dn = tl.startsWith('park') ? 'park' : tl;\n        sTx.textContent = `placing ${dn}`;\n      }\n    } else {\n      sTx.textContent = 'select a tool to start building';\n    }\n  }\n}\n\nfunction drawWaterOverlay() {\n  // Only show overlay when water tools are active\n  if (st.selectedTool !== 'pipe' && st.selectedTool !== 'waterplant' && st.selectedTool !== 'watertower' && st.selectedTool !== 'bulldoze') {\n    return;\n  }\n  \n  ctx.save();\n  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) {\n    calculateWaterGrid();\n  }\n  \n  // Show allowed placement range around water tiles when water plant tools are selected\n  if (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {\n    for (let y=0; y<GR_SZ; y++) {\n      for (let x=0; x<GR_SZ; x++) {\n        const terrain=st.terrain[y][x];\n        // Skip water and cliff tiles themselves\n        if (terrain==='water'||terrain==='cliff') continue;\n        \n        // Check if this tile is within 4 tiles of water\n        if (isNearWaterTile(x, y, 4)) {\n          // Use a blue tint to show valid placement area\n          ctx.fillStyle='rgba(59,130,246,0.15)'; // Blue tint for valid placement range\n          ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n        }\n      }\n    }\n  }\n  \n  // First pass: show coverage areas around pipes (lighter blue)\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      \n      // Only show coverage for non-pipe tiles\n      if (st.waterGrid[y][x] && !st.grid[y][x].pipe) {\n        // Check if there's a connected pipe nearby (within 2-tile range to match actual coverage)\n        let hasNearbyPipe = false;\n        for (let dy=-2; dy<=2; dy++) {\n          for (let dx=-2; dx<=2; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n              if (st.grid[ny][nx].pipe && st.waterGrid[ny][nx]) {\n                hasNearbyPipe = true;\n                break;\n              }\n            }\n          }\n          if (hasNearbyPipe) break;\n        }\n        \n        if (hasNearbyPipe) {\n          ctx.fillStyle='rgba(59,130,246,0.2)'; // Bright blue with transparency for coverage\n          ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n        }\n      }\n    }\n  }\n  \n  // Second pass: highlight water infrastructure\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      \n      // Highlight water plants/towers with border\n      if (st.grid[y][x].type === 'waterplant' || st.grid[y][x].type === 'watertower') {\n        // Check if connected to pipe network\n        let isConnected = false;\n        const directions = [[0,-1], [0,1], [-1,0], [1,0]];\n        for (const [dx, dy] of directions) {\n          const nx = x + dx, ny = y + dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.grid[ny][nx].pipe && st.waterGrid[ny][nx]) {\n              isConnected = true;\n              break;\n            }\n          }\n        }\n        \n        if (isConnected) {\n          ctx.fillStyle='rgba(59,130,246,0.25)'; // Bright blue for connected plants\n        } else {\n          ctx.fillStyle='rgba(239,68,68,0.3)'; // Red tint for disconnected plants\n        }\n        ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n      }\n    }\n  }\n  ctx.restore();\n}\n\nfunction setWaterOverlay(active) {\n  const enable=!!active;\n  // Only allow overlay if water tool is selected\n  if (enable && st.selectedTool !== 'pipe' && st.selectedTool !== 'waterplant' && st.selectedTool !== 'watertower') {\n    return;\n  }\n  \n  if (enable) {\n    showWaterOverlay=true;\n    calculateWaterGrid();\n    drGr();\n    // Update status text\n    const sTx = document.getElementById('statusText');\n    sTx.textContent = 'water overlay active - click buildings to view details';\n    return;\n  }\n  if (showWaterOverlay) {\n    showWaterOverlay=false;\n    hideBuildingInfo();\n    drGr();\n    // Restore status text\n    const sTx = document.getElementById('statusText');\n    if (st.selectedTool) {\n      const tl = st.selectedTool;\n      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';\n      else {\n        const dn = tl.startsWith('park') ? 'park' : tl;\n        sTx.textContent = `placing ${dn}`;\n      }\n    } else {\n      sTx.textContent = 'select a tool to start building';\n    }\n  }\n}\n\nfunction findPath(sx,sy,ex,ey, maxLength=50) {\n  const q=[{x:sx,y:sy,path:[{x:sx,y:sy}]}], vis=new Set();\n  while(q.length>0) {\n    const cur=q.shift(), k=`${cur.x},${cur.y}`;\n    if (vis.has(k)) continue;\n    vis.add(k);\n    if (cur.x===ex && cur.y===ey) return cur.path;\n    if (cur.path.length>maxLength) continue;\n    const dirs=[[0,-1],[1,0],[0,1],[-1,0]];\n    for (const [dx,dy] of dirs) {\n      const nx=cur.x+dx, ny=cur.y+dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && !vis.has(`${nx},${ny}`)) {\n        if (st.grid[ny][nx].type==='road') {\n          q.push({x:nx,y:ny,path:[...cur.path,{x:nx,y:ny}]});\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction ensureStationDispatchMap() {\n  if (!st.stationDispatches) st.stationDispatches={};\n}\n\nfunction getStationKeyFromCoords(x,y) {\n  return `${x},${y}`;\n}\n\nfunction getStationDispatchCount(key) {\n  ensureStationDispatchMap();\n  return st.stationDispatches[key]||0;\n}\n\nfunction incrementStationDispatchCount(key) {\n  ensureStationDispatchMap();\n  st.stationDispatches[key]=(st.stationDispatches[key]||0)+1;\n}\n\nfunction releaseStationSlot(car) {\n  if (!car || !car.stationKey) return;\n  ensureStationDispatchMap();\n  if (st.stationDispatches[car.stationKey]) {\n    st.stationDispatches[car.stationKey]--;\n    if (st.stationDispatches[car.stationKey]<0) st.stationDispatches[car.stationKey]=0;\n  }\n  car.stationKey=null;\n}\n\nfunction getCurrentRoadNode(car) {\n  if (car && car.path && car.path[car.pathIdx]) return car.path[car.pathIdx];\n  if (car && car.sceneRoad) return car.sceneRoad;\n  if (car && car.stationRoad) return car.stationRoad;\n  return null;\n}\n\nfunction findPreferredAdjacentRoad(x,y) {\n  const primaryDirs = [\n    {dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}\n  ];\n  const diagonalDirs = [\n    {dx:-1,dy:-1},{dx:1,dy:-1},{dx:1,dy:1},{dx:-1,dy:1}\n  ];\n  for (const dirs of [primaryDirs, diagonalDirs]) {\n    for (const {dx,dy} of dirs) {\n      const nx = x + dx, ny = y + dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        if (st.grid[ny][nx].type === 'road') {\n          return {x:nx,y:ny};\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction isWithinCoverageRange(targetX, targetY, checkX, checkY) {\n  // Check if checkX,checkY is within 2 tiles of targetX,targetY\n  // This covers 2x2, 2x1, 1x2 buildings\n  const dx = Math.abs(checkX - targetX);\n  const dy = Math.abs(checkY - targetY);\n  return dx <= 2 && dy <= 2;\n}\n\nfunction findNearestStation(targetX, targetY, stationType) {\n  // Find nearest road to target location - check up to 2 tiles away\n  const targetRoads = [];\n  \n  // Check all roads within 2 tiles (orthogonal and diagonal)\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      if (dx === 0 && dy === 0) continue;\n      const nx = targetX + dx, ny = targetY + dy;\n      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {\n        if (st.grid[ny][nx].type === 'road') {\n          const dist = Math.abs(dx) + Math.abs(dy);\n          targetRoads.push({x: nx, y: ny, distToBuilding: dist});\n        }\n      }\n    }\n  }\n  \n  // Sort by distance (closest first)\n  targetRoads.sort((a, b) => a.distToBuilding - b.distToBuilding);\n  \n  if (targetRoads.length === 0) return null;\n  \n  // Find all stations of the requested type\n  const stations = [];\n  for (let y = 0; y < GR_SZ; y++) {\n    for (let x = 0; x < GR_SZ; x++) {\n      const c = st.grid[y][x];\n      if (c.type === stationType && hasRdAcc(x, y)) {\n        const adjacentRoad = findPreferredAdjacentRoad(x,y);\n        if (adjacentRoad) {\n          stations.push({stationX: x, stationY: y, roadX: adjacentRoad.x, roadY: adjacentRoad.y});\n        }\n      }\n    }\n  }\n  if (stations.length === 0) return null;\n  \n  // Find nearest station - prioritize closest road to building\n  // Try each target road in order (closest to building first)\n  for (const targetRoad of targetRoads) {\n    let bestStationForThisRoad = null;\n    let minPathLength = Infinity;\n    \n    // Find the nearest station that can reach this specific target road\n    for (const station of stations) {\n      const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);\n      if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) continue;\n      \n      const manhattanDist = Math.abs(station.roadX - targetRoad.x) + Math.abs(station.roadY - targetRoad.y);\n      if (manhattanDist > 100) continue; // Skip stations that are clearly too far\n      \n      const path = findPath(station.roadX, station.roadY, targetRoad.x, targetRoad.y, 100);\n      if (path && path.length < minPathLength) {\n        minPathLength = path.length;\n        bestStationForThisRoad = {\n          stationX: station.stationX,\n          stationY: station.stationY,\n          roadX: station.roadX,\n          roadY: station.roadY,\n          targetRoadX: targetRoad.x,\n          targetRoadY: targetRoad.y,\n          path: path\n        };\n      }\n    }\n    \n    // If we found a station that can reach this road, use it\n    // This ensures we park at the closest road to the building\n    if (bestStationForThisRoad) {\n      return bestStationForThisRoad;\n    }\n  }\n  \n  return null;\n}\n\nfunction dispatchEmergencyVehicle(stationType, targetX, targetY, missionType) {\n  const station = findNearestStation(targetX, targetY, stationType);\n  if (!station || !station.path || station.path.length < 2) return false;\n  const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);\n  if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) return false;\n  \n  const start = {x: station.roadX, y: station.roadY};\n  const end = {x: station.targetRoadX, y: station.targetRoadY};\n  const path = station.path;\n  \n  // Determine lane offset\n  let laneOffset = 0;\n  const startCenterX = path[0].x * CL_SZ + 7;\n  const startCenterY = path[0].y * CL_SZ + 7;\n  let startX = startCenterX;\n  let startY = startCenterY;\n  \n  if (path.length >= 2) {\n    const dx = path[1].x - path[0].x;\n    const dy = path[1].y - path[0].y;\n    if (Math.abs(dx) > Math.abs(dy)) {\n      laneOffset = dx > 0 ? 5 : -5;\n      startY += laneOffset;\n    } else {\n      laneOffset = dy > 0 ? -5 : 5;\n      startX += laneOffset;\n    }\n  }\n  \n  const stationBuilding = {x: station.stationX, y: station.stationY};\n  const roadCenter = getRoadCenterCoords(start);\n  const entryDir = getEdgeDirection(stationBuilding, start);\n  let entryTarget = null;\n  let entering = false;\n  let spawnX = roadCenter.x;\n  let spawnY = roadCenter.y;\n  \n  if (entryDir.x !== 0 || entryDir.y !== 0) {\n    entering = true;\n    entryTarget = {x: startX, y: startY};\n  } else if (startX !== roadCenter.x || startY !== roadCenter.y) {\n    entering = true;\n    entryTarget = {x: startX, y: startY};\n  }\n  \n  // Fire trucks: red (will be styled with lights), Police cars: very dark gray (will be styled with lights)\n  const color = stationType === 'fire' ? '#ff0000' : '#1a1a1a';\n  const vehicleType = stationType === 'fire' ? 'fire' : 'police';\n  \n  // Scene road is the last node in the path (where vehicle will actually arrive)\n  const sceneRoadNode = path[path.length - 1];\n  const sceneParkingCenter = getRoadCenterCoords(sceneRoadNode);\n  \n  st.cars.push({\n    x: spawnX,\n    y: spawnY,\n    path: path,\n    pathIdx: 0,\n    color: color,\n    type: vehicleType,\n    laneOffset: laneOffset,\n    reverse: false,\n    entering: entering,\n    entryTarget: entryTarget,\n    exiting: false,\n    exitLaneTarget: null,\n    exitTarget: null,\n    positioningForExit: false,\n    stationRoad: { x: start.x, y: start.y },\n    sceneRoad: { x: sceneRoadNode.x, y: sceneRoadNode.y },\n    sceneParkingTarget: sceneParkingCenter,\n    scenePositioning: false,\n    missionPhase: 'enroute',\n    stationKey: stationKey,\n    stationCoords: { x: station.stationX, y: station.stationY },\n    mission: {\n      type: missionType,\n      targetX: targetX,\n      targetY: targetY,\n      arrived: false,\n      returning: false\n    }\n  });\n  incrementStationDispatchCount(stationKey);\n  \n  return true;\n}\n\nfunction getRoadCenterCoords(node) {\n  if (!node) return { x: 0, y: 0 };\n  return { x: node.x * CL_SZ + 7, y: node.y * CL_SZ + 7 };\n}\n\nfunction prepareEmergencyVehicleReturn(car, opts={}) {\n  if (!car || !car.mission || car.mission.returning) return;\n  \n  // Use sceneRoad (where vehicle parked) as the starting point for return path\n  const startRoad = car.sceneRoad || getCurrentRoadNode(car);\n  const stationRoad = car.stationRoad;\n  if (!startRoad || !stationRoad) {\n    car.removeOnNextTick = true;\n    releaseStationSlot(car);\n    return;\n  }\n  \n  if (!opts.skipSceneDecrement && car.mission.arrived) {\n    if (car.mission.type === 'fire') {\n      const fire = st.fires.find(f => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, f.x, f.y));\n      if (fire && fire.fireTrucksAtScene>0) fire.fireTrucksAtScene--;\n    } else if (car.mission.type === 'crime') {\n      const crime = st.crimeEvents.find(evt => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, evt.x, evt.y));\n      if (crime && crime.policeCarsAtScene>0) crime.policeCarsAtScene--;\n    }\n  }\n  \n  const returnPath = findPath(startRoad.x, startRoad.y, stationRoad.x, stationRoad.y, 100);\n  if (!returnPath || returnPath.length<2) {\n    car.removeOnNextTick = true;\n    releaseStationSlot(car);\n    return;\n  }\n  \n  car.path = returnPath;\n  car.pathIdx = 0;\n  car.mission.returning = true;\n  car.mission.arrived = false;\n  car.missionPhase = 'returning';\n  car.entering = true;\n  car.exiting = false;\n  car.exitTarget = null;\n  car.reverse = false;\n  car.holdPosition = null;\n  car.scenePositioning = false;\n  car.sceneParkingTarget = null;\n  \n  const startCenter = getRoadCenterCoords(returnPath[0]);\n  car.x = startCenter.x;\n  car.y = startCenter.y;\n  let entryX = startCenter.x;\n  let entryY = startCenter.y;\n  car.laneOffset = 0;\n  if (returnPath.length>=2) {\n    const dx = returnPath[1].x - returnPath[0].x;\n    const dy = returnPath[1].y - returnPath[0].y;\n    if (Math.abs(dx)>Math.abs(dy)) {\n      car.laneOffset = dx>0 ? 5 : -5;\n      entryY += car.laneOffset;\n    } else {\n      car.laneOffset = dy>0 ? -5 : 5;\n      entryX += car.laneOffset;\n    }\n  }\n  car.entryTarget = { x: entryX, y: entryY };\n\n  const stationBuilding = car.stationCoords || { x: car.stationRoad.x, y: car.stationRoad.y };\n  const parkingCenter = car.stationRoad ? getRoadCenterCoords(car.stationRoad) : getRoadCenterCoords(endNode);\n  const endIdx = returnPath.length - 1;\n  const endNode = returnPath[endIdx];\n  const endCenterX = endNode.x * CL_SZ + 7;\n  const endCenterY = endNode.y * CL_SZ + 7;\n  let exitLaneX = endCenterX;\n  let exitLaneY = endCenterY;\n  if (returnPath.length >= 2) {\n    const dxLast = returnPath[endIdx].x - returnPath[endIdx - 1].x;\n    const dyLast = returnPath[endIdx].y - returnPath[endIdx - 1].y;\n    if (Math.abs(dxLast) > Math.abs(dyLast)) {\n      exitLaneY += dxLast > 0 ? 5 : -5;\n    } else {\n      exitLaneX += dyLast > 0 ? -5 : 5;\n    }\n  }\n  const exitDir = getEdgeDirection(stationBuilding, stationRoad);\n  let exitTarget = parkingCenter;\n  if (!exitTarget || Number.isNaN(exitTarget.x) || Number.isNaN(exitTarget.y)) {\n    exitTarget = { x: exitLaneX, y: exitLaneY };\n  }\n  if (exitDir.x !== 0 || exitDir.y !== 0) {\n    exitTarget = parkingCenter;\n  }\n  car.exitLaneTarget = { x: exitLaneX, y: exitLaneY };\n  car.exitTarget = exitTarget;\n  car.positioningForExit = false;\n}\n\nfunction sendEmergencyVehiclesHome(missionType, targetX, targetY) {\n  st.cars.forEach(car => {\n    if (!car.mission || car.mission.returning) return;\n    if (car.mission.type===missionType && isWithinCoverageRange(car.mission.targetX, car.mission.targetY, targetX, targetY)) {\n      prepareEmergencyVehicleReturn(car);\n    }\n  });\n}\n  \nfunction attemptMissionArrival(car) {\n  if (!car || !car.mission || car.mission.returning) return false;\n  const buildingTarget = {\n    x: car.mission.targetX * CL_SZ + CL_SZ / 2,\n    y: car.mission.targetY * CL_SZ + CL_SZ / 2\n  };\n  const roadTarget = car.sceneRoad ? getRoadCenterCoords(car.sceneRoad) : null;\n  // Fire and police cars should always stop at the road tile center, no offsets\n  const targetToUse = roadTarget || buildingTarget;\n  if (!targetToUse) return false;\n  const dx = targetToUse.x - car.x;\n  const dy = targetToUse.y - car.y;\n  const dist = Math.sqrt(dx*dx + dy*dy);\n  const threshold = CL_SZ * 2.5;\n  if (dist < threshold) {\n    if (!car.mission.arrived) {\n      car.mission.arrived = true;\n      car.missionPhase = 'onscene';\n        // Police and fire vehicles stop exactly at road tile center, no lane offsets\n        const holdTarget = roadTarget || buildingTarget;\n        if (holdTarget) {\n          car.holdPosition = { x: holdTarget.x, y: holdTarget.y };\n          car.x = car.holdPosition.x;\n          car.y = car.holdPosition.y;\n          // Clear any lane offsets for emergency vehicles\n          if (car.type === 'police' || car.type === 'fire') {\n            car.laneOffset = 0;\n          }\n        } else {\n          car.holdPosition = { x: car.x, y: car.y };\n        }\n      if (!car.arrivalLogged) {\n        if (car.mission.type === 'fire') {\n          const fire = st.fires.find(f => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, f.x, f.y));\n          if (fire) fire.fireTrucksAtScene = (fire.fireTrucksAtScene || 0) + 1;\n        } else if (car.mission.type === 'crime') {\n          const crime = st.crimeEvents.find(evt => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, evt.x, evt.y));\n          if (crime) crime.policeCarsAtScene = (crime.policeCarsAtScene || 0) + 1;\n        }\n        car.arrivalLogged = true;\n      }\n    } else if (!car.holdPosition) {\n      car.holdPosition = { x: car.x, y: car.y };\n    }\n    return true;\n  }\n  return false;\n}\n \nfunction countActiveResponders(missionType, targetX, targetY) {\n  if (!st.cars) return 0;\n  return st.cars.reduce((sum, car) => {\n    if (car.mission && !car.mission.returning && car.mission.type===missionType) {\n      // Check if vehicle's target is within 2 tiles of the requested location\n      if (isWithinCoverageRange(car.mission.targetX, car.mission.targetY, targetX, targetY)) {\n        return sum+1;\n      }\n    }\n    return sum;\n  },0);\n}\n\nfunction ensureEmergencyCoverage() {\n  if (st.fires) {\n    st.fires.forEach(fire => {\n      if (countActiveResponders('fire', fire.x, fire.y)===0) {\n        dispatchEmergencyVehicle('fire', fire.x, fire.y, 'fire');\n      }\n    });\n  }\n  if (st.crimeEvents) {\n    st.crimeEvents.forEach(evt => {\n      if (countActiveResponders('crime', evt.x, evt.y)===0) {\n        dispatchEmergencyVehicle('police', evt.x, evt.y, 'crime');\n      }\n    });\n  }\n}\n \nfunction getEdgeDirection(structCell,roadCell) {\n  if (!structCell || !roadCell) return {x:0,y:0};\n  const dx=structCell.x-roadCell.x;\n  const dy=structCell.y-roadCell.y;\n  if (dx===0 && dy===0) return {x:0,y:0};\n  if (Math.abs(dx)>Math.abs(dy)) return {x:dx>0?1:-1,y:0};\n  if (Math.abs(dy)>Math.abs(dx)) return {x:0,y:dy>0?1:-1};\n  if (dx!==0) return {x:dx>0?1:-1,y:0};\n  return {x:0,y:dy>0?1:-1};\n}\n\nfunction spawnCar() {\n  const res=[], com=[], ind=[], pol=[], fir=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && !c.abandoned && hasRdAcc(x,y)) res.push({x,y});\n    else if (c.type==='commercial' && !c.abandoned && hasRdAcc(x,y)) com.push({x,y});\n    else if (c.type==='industrial' && !c.abandoned && hasRdAcc(x,y)) ind.push({x,y});\n    else if (c.type==='police' && hasRdAcc(x,y)) pol.push({x,y});\n    else if (c.type==='fire' && hasRdAcc(x,y)) fir.push({x,y});\n  }\n  if (res.length===0) return;\n  \n  let tp='normal', src, dst, clr;\n  // Emergency vehicles are now dispatched via dispatchEmergencyVehicle(), not spawned randomly\n  // So we only spawn normal civilian cars here\n  {\n    src=res[Math.floor(Math.random()*res.length)];\n    const dests=[...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);\n    if (dests.length===0) return;\n    dst=dests[Math.floor(Math.random()*dests.length)];\n    const rnd=Math.random();\n    if (rnd<0.7) clr='#808080';\n    else if (rnd<0.85) clr='#a0a0a0';\n    else if (rnd<0.95) clr='#606060';\n    else clr=['#ffeb3b','#4caf50','#9c27b0'][Math.floor(Math.random()*3)];\n  }\n  \n  const rdNear=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=src.x+dx, ny=src.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdNear.push({x:nx,y:ny});\n  }\n  if (rdNear.length===0) return;\n  const start=rdNear[Math.floor(Math.random()*rdNear.length)];\n  \n  const rdEnd=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=dst.x+dx, ny=dst.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdEnd.push({x:nx,y:ny});\n  }\n  if (rdEnd.length===0) return;\n  const end=rdEnd[Math.floor(Math.random()*rdEnd.length)];\n  \n  const path=findPath(start.x,start.y,end.x,end.y);\n  if (!path || path.length<2) return;\n  \n    // Determine direction: randomly choose forward or reverse\n    const reverse=Math.random()<0.5;\n    const carPath=reverse ? [...path].reverse() : path;\n    const spawnRoad=reverse ? end : start;\n    const exitRoad=reverse ? start : end;\n    const spawnBuilding=reverse ? dst : src;\n    const exitBuilding=reverse ? src : dst;\n    \n    // Determine lane offset based on first segment direction\n    // Cars going in opposite directions should be in opposite lanes\n    let laneOffset=0;\n    const startCenterX=carPath[0].x*CL_SZ+7;\n    const startCenterY=carPath[0].y*CL_SZ+7;\n    let startX=startCenterX;\n    let startY=startCenterY;\n    \n    if (carPath.length>=2) {\n      const dx=carPath[1].x-carPath[0].x;\n      const dy=carPath[1].y-carPath[0].y;\n      \n      if (Math.abs(dx)>Math.abs(dy)) {\n        // Horizontal movement: use y offset for lanes\n        // Left-to-right (dx > 0): bottom lane (+5)\n        // Right-to-left (dx < 0): top lane (-5)\n        laneOffset=dx>0 ? 5 : -5;\n        startY+=laneOffset;\n      } else {\n        // Vertical movement: use x offset for lanes\n        // Ensure right-hand traffic: southbound (dy > 0) stays to the viewer's left (laneOffset = -5)\n        laneOffset=dy>0 ? -5 : 5;\n        startX+=laneOffset;\n      }\n    }\n    \n    const entryDir=getEdgeDirection(spawnBuilding,spawnRoad);\n    let entryTarget=null;\n    let entering=false;\n    let spawnX=startX;\n    let spawnY=startY;\n    if (entryDir.x!==0 || entryDir.y!==0) {\n      entering=true;\n      entryTarget={x:startX,y:startY};\n      if (Math.abs(entryDir.x)>=Math.abs(entryDir.y) && entryDir.x!==0) {\n        spawnX=startCenterX+entryDir.x*CAR_EDGE_OFFSET;\n        spawnY=startY;\n      } else if (entryDir.y!==0) {\n        spawnY=startCenterY+entryDir.y*CAR_EDGE_OFFSET;\n        spawnX=startX;\n      }\n    }\n    \n    const endIdx=carPath.length-1;\n    const endNode=carPath[endIdx];\n    const endCenterX=endNode.x*CL_SZ+7;\n    const endCenterY=endNode.y*CL_SZ+7;\n    let exitLaneX=endCenterX;\n    let exitLaneY=endCenterY;\n    if (carPath.length>=2) {\n      const dxLast=carPath[endIdx].x-carPath[endIdx-1].x;\n      const dyLast=carPath[endIdx].y-carPath[endIdx-1].y;\n      if (Math.abs(dxLast)>Math.abs(dyLast)) {\n        exitLaneY+=dxLast>0 ? 5 : -5;\n      } else {\n        exitLaneX+=dyLast>0 ? -5 : 5;\n      }\n    }\n    const exitDir=getEdgeDirection(exitBuilding,exitRoad);\n    let exitLaneTarget={x:exitLaneX,y:exitLaneY};\n    let exitTarget=null;\n    if (exitDir.x!==0 || exitDir.y!==0) {\n      exitTarget={x:exitLaneX,y:exitLaneY};\n      if (Math.abs(exitDir.x)>=Math.abs(exitDir.y) && exitDir.x!==0) {\n        exitTarget.x=endCenterX+exitDir.x*CAR_EDGE_OFFSET;\n      } else if (exitDir.y!==0) {\n        exitTarget.y=endCenterY+exitDir.y*CAR_EDGE_OFFSET;\n      }\n    }\n    \n    st.cars.push({\n      x:spawnX,\n      y:spawnY,\n      path:carPath,\n      pathIdx:0,\n      color:clr,\n      type:tp,\n      laneOffset:laneOffset,\n      reverse:reverse,\n      entering:entering,\n      entryTarget:entryTarget,\n      exiting:false,\n      exitLaneTarget:exitLaneTarget,\n      exitTarget:exitTarget\n    });\n}\n  \nfunction updCars() {\n  st.cars=st.cars.filter(c => {\n      const finalizeRemoval = () => {\n        if (c.mission && c.mission.returning) releaseStationSlot(c);\n        return false;\n      };\n      if (c.removeOnNextTick) return finalizeRemoval();\n    \n      if (c.mission && !c.mission.returning) {\n      const targetGridX = c.mission.targetX;\n      const targetGridY = c.mission.targetY;\n      let targetExists = false;\n      if (c.mission.type === 'fire') {\n        targetExists = st.fires.some(f => isWithinCoverageRange(targetGridX, targetGridY, f.x, f.y));\n      } else if (c.mission.type === 'crime') {\n        targetExists = st.crimeEvents.some(evt => isWithinCoverageRange(targetGridX, targetGridY, evt.x, evt.y));\n      }\n      \n        if (!targetExists) {\n        prepareEmergencyVehicleReturn(c);\n        } else if (!c.mission.arrived) {\n          if (attemptMissionArrival(c)) return true;\n      } else {\n        return true;\n      }\n    }\n    \n    if (c.mission && c.mission.arrived && !c.mission.returning) {\n      if (c.holdPosition) {\n        c.x = c.holdPosition.x;\n        c.y = c.holdPosition.y;\n        // Ensure emergency vehicles stay at exact road center, no offsets\n        if ((c.type === 'police' || c.type === 'fire') && c.sceneRoad) {\n          const exactCenter = getRoadCenterCoords(c.sceneRoad);\n          c.x = exactCenter.x;\n          c.y = exactCenter.y;\n          c.holdPosition = exactCenter;\n          c.laneOffset = 0;\n        }\n      } else if (c.sceneRoad) {\n        const center = getRoadCenterCoords(c.sceneRoad);\n        c.holdPosition = center;\n        c.x = center.x;\n        c.y = center.y;\n        if (c.type === 'police' || c.type === 'fire') {\n          c.laneOffset = 0;\n        }\n      } else {\n        c.holdPosition = { x: c.x, y: c.y };\n      }\n      return true;\n    }\n    \n    let remainingDist=getCarSpeedPerFrame(c);\n    if (remainingDist<=0) return true;\n    \n    // Helper to check if car reached end of path\n    const isAtPathEnd = () => c.pathIdx >= c.path.length - 1;\n    \n    // Helper to initiate exit sequence\n    const startExitSequence = () => {\n        if (c.exitLaneTarget) {\n        c.positioningForExit = true;\n      } else if (c.exitTarget) {\n        c.exiting = true;\n      } else {\n        return false; // No exit sequence available\n      }\n      return true;\n    };\n    \n    while (remainingDist>0) {\n      // Determine target based on current car state\n      let targetStage, tx, ty;\n      \n        if (c.entering && c.entryTarget) {\n        targetStage = 'entry';\n        tx = c.entryTarget.x;\n        ty = c.entryTarget.y;\n      } else if (c.exiting && c.exitTarget) {\n        targetStage = 'exit';\n        tx = c.exitTarget.x;\n        ty = c.exitTarget.y;\n      } else if (c.positioningForExit && c.exitLaneTarget) {\n        targetStage = 'positioning';\n        tx = c.exitLaneTarget.x;\n        ty = c.exitLaneTarget.y;\n      } else {\n        // Handle path-following and end-of-path logic\n        if (isAtPathEnd()) {\n          // Mission vehicles that haven't arrived yet\n          if (c.mission && !c.mission.returning) {\n            // For emergency vehicles, move to exact center of scene road tile\n            if (c.sceneRoad && (c.type === 'police' || c.type === 'fire')) {\n              const sceneCenter = getRoadCenterCoords(c.sceneRoad);\n              // Set this as our target for final approach\n              targetStage = 'finalApproach';\n              tx = sceneCenter.x;\n              ty = sceneCenter.y;\n              // Continue to movement logic below\n            } else {\n              // Non-emergency vehicles\n              if (attemptMissionArrival(c)) return true;\n              c.holdPosition = c.holdPosition || { x: c.x, y: c.y };\n              c.x = c.holdPosition.x;\n              c.y = c.holdPosition.y;\n              return true;\n            }\n          } else {\n            // Start exit sequence or despawn\n            if (!startExitSequence()) {\n              return finalizeRemoval();\n            }\n            continue;\n          }\n        } else {\n          // Normal path following\n          targetStage = 'path';\n          const nextTarget = getCarSegmentTarget(c);\n          tx = nextTarget.tx;\n          ty = nextTarget.ty;\n        }\n      }\n      \n      // Move toward target\n      const dx = tx - c.x;\n      const dy = ty - c.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      // Snap to target when very close\n        if (dist < CAR_SNAP_THRESHOLD) {\n        c.x = tx;\n        c.y = ty;\n        \n        // Handle state transitions\n        if (targetStage === 'entry') {\n          c.entering = false;\n          c.entryTarget = null;\n        } else if (targetStage === 'positioning') {\n          c.positioningForExit = false;\n          if (c.exitTarget) {\n            c.exiting = true;\n          } else {\n            return finalizeRemoval();\n          }\n        } else if (targetStage === 'exit') {\n          return finalizeRemoval();\n        } else if (targetStage === 'finalApproach') {\n          // Emergency vehicle reached exact parking position\n          c.laneOffset = 0; // Clear lane offset for clean parking\n          if (attemptMissionArrival(c)) return true;\n          c.holdPosition = { x: c.x, y: c.y };\n          return true;\n        } else {\n          // Advance path\n          c.pathIdx++;\n          if (isAtPathEnd()) {\n            // Will be handled in next iteration\n          } else {\n            updateCarLaneOffset(c);\n          }\n        }\n        continue;\n      }\n      \n      // Move step toward target\n      const step = Math.min(dist, remainingDist);\n      c.x += dx / dist * step;\n      c.y += dy / dist * step;\n      remainingDist -= step;\n      \n      if (step < dist) break; // Not enough distance remaining\n    }\n    return true;\n  });\n  \n  const maxCars=Math.min(60,Math.floor(st.population/18)+8);\n  const populationFactor=Math.min(1,st.population/4000);\n  const totalDemand=\n    Math.max(0,(st.rDemand||0))+\n    Math.max(0,(st.cDemand||0))+\n    Math.max(0,(st.iDemand||0));\n  const demandFactor=Math.min(1,totalDemand/400);\n  const spawnChance=Math.min(0.25,0.02+0.1*populationFactor+0.08*demandFactor);\n  if (st.speed>0 && st.population>10 && st.cars.length<maxCars && Math.random()<spawnChance) {\n    spawnCar();\n    if (st.cars.length<maxCars && Math.random()<0.15) spawnCar();\n  }\n}\n\n// ===== UI Updates =====\nfunction updInpWd() {\n  const inp=document.getElementById('cityName'), tmp=document.createElement('span');\n  tmp.style.font=window.getComputedStyle(inp).font; tmp.style.visibility='hidden'; tmp.style.position='absolute'; tmp.style.whiteSpace='pre';\n  tmp.textContent=inp.value||inp.placeholder||'new city'; document.body.appendChild(tmp); inp.style.width=(tmp.offsetWidth+8)+'px'; document.body.removeChild(tmp);\n}\n\nfunction shwNxtNws() {\n  if (nwsQ.length>0 && !trans) {\n    const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=nwsQ.shift();\n    if (ot===nt) return;\n    trans=true; tk.classList.add('ticker-roll');\n    setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n      setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n        setTimeout(() => { trans=false; if (nwsQ.length>0) setTimeout(shwNxtNws,100); },500);\n      },10);\n    },500);\n    return;\n  }\n  if (st.newsEvents.length===0||trans) return;\n  const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=st.newsEvents[nwsIdx];\n  if (ot===nt) { nwsIdx=(nwsIdx+1)%st.newsEvents.length; return; }\n  trans=true; tk.classList.add('ticker-roll');\n  setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n    setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n      setTimeout(() => { trans=false; },500);\n    },10);\n  },500);\n  nwsIdx=(nwsIdx+1)%st.newsEvents.length;\n}\n\nfunction updNwsTk() {\n  if (tkrTmr) clearInterval(tkrTmr);\n  if (st.newsEvents.length>0 && st.speed>0) {\n    nwsIdx=st.newsEvents.length-1; const tk=document.getElementById('newsTicker');\n    tk.textContent=st.newsEvents[nwsIdx]; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n    nwsIdx=(nwsIdx+1)%st.newsEvents.length; tkrTmr=setInterval(shwNxtNws,5000);\n  } else {\n    const tk=document.getElementById('newsTicker');\n    if (st.speed===0) tk.textContent=st.newsEvents.length>0?st.newsEvents[st.newsEvents.length-1]:'';\n    else if (st.newsEvents.length===0) tk.textContent='';\n    tk.classList.remove('ticker-roll');\n  }\n}\n\nfunction shwInfo(title,content,infoType) {\n  plySnd('click');\n  const pnl=document.getElementById('infoPanel');\n  \n  // If clicking the same stat, toggle it off\n  if (currentInfoType === infoType && !pnl.classList.contains('hidden')) {\n    pnl.classList.add('hidden');\n    currentInfoType = null;\n    setLandValueOverlay(false);\n    setCrimeOverlay(false);\n    setWaterOverlay(false);\n    return;\n  }\n  \n  // Otherwise, show the new panel\n  document.getElementById('menu').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoTitle').textContent=title;\n  document.getElementById('infoContent').innerHTML=content;\n  pnl.classList.remove('hidden');\n  currentInfoType = infoType;\n  if (infoType === 'happy') {\n    setLandValueOverlay(false);\n    setCrimeOverlay(true);\n    setWaterOverlay(false);\n  } else if (infoType === 'water') {\n    setLandValueOverlay(false);\n    setCrimeOverlay(false);\n    // Only show water overlay if a water tool is selected\n    if (st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {\n      setWaterOverlay(true);\n    } else {\n      setWaterOverlay(false);\n    }\n  } else {\n    setCrimeOverlay(false);\n    setWaterOverlay(false);\n    setLandValueOverlay(STAT_INFO_TYPES.includes(infoType));\n  }\n}\n\n// Format numbers compactly (e.g., $1.5M, $234.5K)\nfunction fmtCompact(num) {\n  const absNum = Math.abs(num);\n  if (absNum >= 1000000) {\n    return `${(num/1000000).toFixed(1)}M`;\n  } else if (absNum >= 1000) {\n    return `${(num/1000).toFixed(1)}K`;\n  }\n  return num.toString();\n}\n\nfunction updUI() {\n  const inp=document.getElementById('cityName'); if (!edtNm) { inp.value=st.cityName; updInpWd(); }\n  document.getElementById('population').textContent=fmtCompact(st.population);\n  document.getElementById('money').textContent=fmtCompact(st.money);\n  document.getElementById('happiness').textContent=st.happiness;\n  \n  // Calculate and update power/water shortage indicators (only show when negative)\n  const powerStats = calculatePowerStats();\n  const powerSurplus = powerStats.powerSurplus;\n  const powerShortageIndicator = document.getElementById('powerShortageIndicator');\n  const powerShortageValue = document.getElementById('powerShortageValue');\n  if (powerSurplus < 0) {\n    powerShortageIndicator.style.display = 'flex';\n    powerShortageValue.textContent = powerSurplus.toString();\n  } else {\n    powerShortageIndicator.style.display = 'none';\n  }\n  \n  const waterStats = calculateWaterStats();\n  const waterSurplus = waterStats.waterSurplus;\n  const waterShortageIndicator = document.getElementById('waterShortageIndicator');\n  const waterShortageValue = document.getElementById('waterShortageValue');\n  if (waterSurplus < 0) {\n    waterShortageIndicator.style.display = 'flex';\n    waterShortageValue.textContent = waterSurplus.toString();\n  } else {\n    waterShortageIndicator.style.display = 'none';\n  }\n  \n    if (!edtNm) {\n      document.getElementById('yearDisplay').textContent=`${st.year}`;\n    }\n  const mEl=document.getElementById('money');\n  if (st.money<0) { mEl.classList.remove('text-white'); mEl.classList.add('text-red-400'); }\n  else { mEl.classList.remove('text-red-400'); mEl.classList.add('text-white'); }\n  const rB=document.getElementById('rDemand'), cB=document.getElementById('cDemand'), iB=document.getElementById('iDemand');\n  rB.style.height=`${st.rDemand}%`; cB.style.height=`${st.cDemand}%`; iB.style.height=`${st.iDemand}%`;\n  [rB,cB,iB].forEach(el => { el.parentElement.style.display='flex'; el.parentElement.style.flexDirection='column'; el.parentElement.style.justifyContent='flex-end'; });\n  const sBtn=document.getElementById('speedToggle');\n  if (st.speed===0) sBtn.textContent='‚è∏';\n  else if (st.speed===3000) sBtn.textContent='1x';\n  else if (st.speed===1500) sBtn.textContent='2x';\n  else if (st.speed===500) sBtn.textContent='3x';\n}\n\nfunction selTl(tl) {\n  // Check if we're in water tool mode (water submenu is open or water tool was selected)\n  const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';\n  const wasWaterTool = st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower';\n  \n  // Auto-show water overlay when water tools are selected, hide otherwise\n  if (tl === 'pipe' || tl === 'waterplant' || tl === 'watertower') {\n    setWaterOverlay(true);\n  } else if (tl === 'bulldoze' && (isWaterToolMode || wasWaterTool)) {\n    // Keep water overlay when switching to bulldoze from water tools\n    setWaterOverlay(true);\n  } else {\n    // Always hide water overlay when switching to non-water tools (unless coming from water mode)\n    if (!isWaterToolMode && !wasWaterTool) {\n      setWaterOverlay(false);\n    }\n  }\n  st.selectedTool=tl;\n  updateToolSelection();\n  const c=COSTS[tl]||0, cTx=document.getElementById('costText'), sTx=document.getElementById('statusText');\n  if (tl==='bulldoze') {\n    // Check if we're in water tool mode\n    const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';\n    if (isWaterToolMode) {\n      sTx.textContent='click to demolish water infrastructure'; \n    } else {\n      sTx.textContent='click to demolish buildings';\n    }\n    cTx.textContent='';\n  }\n  else if (tl) {\n    const dn=tl.startsWith('park')?'park':tl;\n    sTx.textContent=`placing ${dn}`;\n    cTx.textContent=c>0?`$${fmtCompact(c)}`:'';\n  }\n  else { sTx.textContent='select a tool to start building'; cTx.textContent=''; }\n}\n\n// ===== Building Placement =====\nfunction canPlLg(x,y,w,h,zt) {\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=GR_SZ||ny>=GR_SZ) return false;\n    const c=st.grid[ny][nx]; \n    // Normalize empty cells to ensure they're 1x1\n    if (c.type==='empty') normalizeEmptyCell(nx,ny);\n    // Prevent merging through roads and other incompatible tiles\n    if (c.type==='road') return false;\n    if (c.type!=='empty' && c.type!==zt && !c.abandoned) return false;\n    const tr=st.terrain[ny][nx]; if (tr==='water'||tr==='cliff') return false;\n  }\n  return true;\n}\n\n// Helper: given any cell in a building, find the building's top-left and size\nfunction getBuildingBoundsFromCell(x,y) {\n  const c=st.grid[y][x];\n  if (!c) return {startX:x,startY:y,w:1,h:1};\n  // If this cell has a buildingId, use it as the primary way to find bounds\n  if (c.buildingId != null && c.type!=='empty') {\n    const targetId = c.buildingId;\n    const visited = new Set();\n    const queue = [{x,y}];\n    let minX = x, maxX = x, minY = y, maxY = y;\n\n    while (queue.length>0) {\n      const cur = queue.shift();\n      const key = `${cur.x},${cur.y}`;\n      if (visited.has(key)) continue;\n      visited.add(key);\n      if (cur.x<0 || cur.x>=GR_SZ || cur.y<0 || cur.y>=GR_SZ) continue;\n      const cell = st.grid[cur.y][cur.x];\n      if (!cell || cell.buildingId!==targetId) continue;\n\n      if (cur.x<minX) minX=cur.x;\n      if (cur.x>maxX) maxX=cur.x;\n      if (cur.y<minY) minY=cur.y;\n      if (cur.y>maxY) maxY=cur.y;\n\n      queue.push({x:cur.x-1,y:cur.y});\n      queue.push({x:cur.x+1,y:cur.y});\n      queue.push({x:cur.x,y:cur.y-1});\n      queue.push({x:cur.x,y:cur.y+1});\n    }\n\n    const w = maxX-minX+1;\n    const h = maxY-minY+1;\n    return {startX:minX,startY:minY,w,h};\n  }\n\n  // Fallback: legacy logic based on w/h only\n  const baseW=c.w||1, baseH=c.h||1;\n\n  // Single-tile structures (including empty zones) should never sweep across\n  // adjacent tiles just because they share the same zone type. Treat them as\n  // isolated cells so bulldozing/park placement only affects the clicked tile.\n  if (baseW===1 && baseH===1) return {startX:x,startY:y,w:1,h:1};\n\n  let startX = x;\n  let startY = y;\n\n  let stepsLeft = 0;\n  while (startX > 0 && stepsLeft < baseW-1) {\n    const left = st.grid[y][startX-1];\n    if (left && left.type === c.type && (left.w||1) === baseW && (left.h||1) === baseH) {\n      startX--;\n      stepsLeft++;\n    } else {\n      break;\n    }\n  }\n\n  let stepsUp = 0;\n  while (startY > 0 && stepsUp < baseH-1) {\n    const above = st.grid[startY-1][startX];\n    if (above && above.type === c.type && (above.w||1) === baseW && (above.h||1) === baseH) {\n      startY--;\n      stepsUp++;\n    } else {\n      break;\n    }\n  }\n\n  let consistent = true;\n  for (let dy=0; dy<baseH && consistent; dy++) {\n    for (let dx=0; dx<baseW; dx++) {\n      const nx=startX+dx, ny=startY+dy;\n      if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { consistent=false; break; }\n      const cell=st.grid[ny][nx];\n      if (!cell || cell.type!==c.type || (cell.w||1)!==baseW || (cell.h||1)!==baseH) {\n        consistent=false;\n        break;\n      }\n    }\n  }\n  if (!consistent) return {startX:x,startY:y,w:1,h:1};\n\n  return {startX:startX, startY:startY, w:baseW, h:baseH};\n}\n\nfunction isTopLeftCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false;\n  const cell=st.grid[y][x];\n  if (!cell) return false;\n  const w=cell.w||1, h=cell.h||1;\n  if (w===1 && h===1) return true;\n  if (x>0) {\n    const left=st.grid[y][x-1];\n    if (left && left.type===cell.type && (left.w||1)===w && (left.h||1)===h) return false;\n  }\n  if (y>0) {\n    const above=st.grid[y-1][x];\n    if (above && above.type===cell.type && (above.w||1)===w && (above.h||1)===h) return false;\n  }\n  return true;\n}\n\n// Recompute buildingId metadata for all non-empty cells based on rectangular buildings\nfunction rebuildBuildingIdsFromGrid() {\n  nextBuildingId = 1;\n  const visited = [];\n\n  for (let y=0; y<GR_SZ; y++) {\n    const row = [];\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (cell && cell.type === 'empty') {\n        cell.buildingId = null;\n      } else if (cell) {\n        cell.buildingId = undefined;\n      }\n      row.push(false);\n    }\n    visited.push(row);\n  }\n\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      if (visited[y][x]) continue;\n      const cell = st.grid[y][x];\n      if (!cell || cell.type === 'empty') {\n        visited[y][x] = true;\n        continue;\n      }\n\n      const w = cell.w || 1;\n      const h = cell.h || 1;\n      const buildingId = nextBuildingId++;\n\n      let isRectangular = true;\n      for (let dy=0; dy<h && isRectangular; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx = x+dx;\n          const ny = y+dy;\n          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { isRectangular=false; break; }\n          const target = st.grid[ny][nx];\n          if (!target || target.type !== cell.type || (target.w||1)!==w || (target.h||1)!==h || visited[ny][nx]) {\n            isRectangular = false;\n            break;\n          }\n        }\n      }\n\n      if (!isRectangular) {\n        cell.buildingId = buildingId;\n        visited[y][x] = true;\n        continue;\n      }\n\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx = x+dx;\n          const ny = y+dy;\n          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) continue;\n          const target = st.grid[ny][nx];\n          if (!target) continue;\n          target.buildingId = buildingId;\n          visited[ny][nx] = true;\n        }\n      }\n    }\n  }\n}\n\nfunction plcTl(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return; if (!st.selectedTool) return;\n  const c=st.grid[y][x], tr=st.terrain[y][x];\n  \n  // Allow pipes on water, but nothing else on water/cliff\n  if (st.selectedTool === 'pipe') {\n    if (tr === 'cliff') { plySnd('error'); return; }\n  } else {\n    if (tr === 'water' || tr === 'cliff') { plySnd('error'); return; }\n  }\n\n  if (st.selectedTool==='bulldoze') {\n    // Check if we're in water tool mode\n    const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';\n    \n    if (isWaterToolMode) {\n      // In water tool mode, only allow demolishing water-related items\n      let removedWaterItem = false;\n      \n      // Remove pipes (can be on any tile)\n      if (c.pipe) {\n        delete c.pipe;\n        normalizeEmptyCell(x,y);\n        calculateWaterGrid();\n        removedWaterItem = true;\n      }\n      \n      // Remove water plants/towers (check the clicked cell)\n      if (c.type === 'waterplant' || c.type === 'watertower') {\n        const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n        for (let dy=0; dy<h; dy++) {\n          for (let dx=0; dx<w; dx++) {\n            const nx=startX+dx, ny=startY+dy;\n            if (nx<GR_SZ && ny<GR_SZ) {\n              const hadPipe = st.grid[ny][nx].pipe;\n              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n              if (hadPipe) st.grid[ny][nx].pipe = true;\n              normalizeEmptyCell(nx,ny);\n            }\n          }\n        }\n        calculateWaterGrid();\n        removedWaterItem = true;\n      }\n      \n      if (removedWaterItem) {\n        plySnd('bulldoze');\n        drGr(); sv();\n      } else {\n        plySnd('error');\n      }\n      return;\n    }\n    \n    // Normal bulldoze mode (not in water tool mode)\n    if (c.type!=='empty') {\n      plySnd('bulldoze');\n\n      // Roads: always bulldoze a single tile only\n      if (c.type==='road') {\n        const hadPipe = st.grid[y][x].pipe;\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n        if (hadPipe) st.grid[y][x].pipe = true;\n        normalizeEmptyCell(x,y);\n        calculatePowerGrid();\n        calculateWaterGrid(); // Recalculate power grid when roads are removed\n        drGr(); sv();\n        return;\n      }\n      \n      // Pipes: remove pipe property (pipes overlay on tiles)\n      if (c.pipe) {\n        delete c.pipe;\n        normalizeEmptyCell(x,y);\n        calculateWaterGrid(); // Recalculate water grid when pipes are removed\n        drGr(); sv();\n        return;\n      }\n      \n      // Check if removing a water plant\n      const wasWaterPlant = c.type === 'waterplant' || c.type === 'watertower';\n      \n\n        const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n        const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n        const isMultiTileBuilding=(w>1 || h>1);\n        const isEmptyZoneCell=isZone && (c.level===0 || c.abandoned) && !isMultiTileBuilding;\n\n        // Single-tile empty zones (fresh or abandoned) can be cleared one cell at a time.\n        // Any merged/multi-tile structure should always clear its entire footprint to avoid \"shifting\" artifacts.\n        if (isEmptyZoneCell) {\n          const hadPipe = st.grid[y][x].pipe;\n          st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n          if (hadPipe) st.grid[y][x].pipe = true;\n          normalizeEmptyCell(x,y);\n        } else if (isMultiTileBuilding) {\n          for (let dy=0; dy<h; dy++) {\n            for (let dx=0; dx<w; dx++) {\n              const nx=startX+dx, ny=startY+dy;\n              if (nx<GR_SZ && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n                normalizeEmptyCell(nx,ny);\n              }\n            }\n          }\n        } else {\n          // All other buildings: only bulldoze the clicked cell\n          const hadPipe = st.grid[y][x].pipe;\n          st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n          if (hadPipe) st.grid[y][x].pipe = true;\n          normalizeEmptyCell(x,y);\n        }\n      \n      // Recalculate power grid if a power plant was removed\n      const wasPowerPlant = c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind';\n      if (wasPowerPlant) {\n        calculatePowerGrid();\n        calculateWaterGrid();\n      }\n      \n      // Recalculate water grid if a water plant was removed\n      if (wasWaterPlant) {\n        calculateWaterGrid();\n      }\n\n      drGr(); sv();\n    }\n    return;\n  }\n  const isPk=st.selectedTool.startsWith('park');\n  \n  // For parks: allow placing on empty zones (level 0 or abandoned zones)\n  if (isPk) {\n    const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n    const isEmptyZone=isZone && (c.level===0 || c.abandoned);\n    if (c.type!=='empty' && !isEmptyZone) return;\n    \n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    \n    plySnd('place'); \n    st.money-=cs;\n    \n    // If replacing an empty zone, replace the entire building\n    if (isEmptyZone) {\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      // Replace all cells of the zone building with park\n      const parkBuildingId = nextBuildingId++;\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=startX+dx, ny=startY+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            const hadPipe = st.grid[ny][nx].pipe;\n            st.grid[ny][nx]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};\n            if (hadPipe) st.grid[ny][nx].pipe = true;\n          }\n        }\n      }\n      // Try to merge parks after placement (from the top-left)\n      tryMrgPark(startX,startY);\n    } else {\n      // Normal placement on empty terrain\n      const parkBuildingId = nextBuildingId++;\n      const hadPipe = st.grid[y][x].pipe;\n      st.grid[y][x]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};\n      if (hadPipe) st.grid[y][x].pipe = true;\n      // Try to merge with adjacent parks of the same type\n      tryMrgPark(x,y);\n    }\n  } else {\n    // For non-park tools: only allow empty or abandoned\n    // Determine building size\n    let bw = 1, bh = 1;\n    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {\n      bw = 2; bh = 2; // 2x2 for coal and nuclear\n    } else if (st.selectedTool === 'wind') {\n      bw = 1; bh = 2; // 1x2 for wind\n    } else if (st.selectedTool === 'waterplant') {\n      bw = 2; bh = 2; // 2x2 for water treatment plant\n    } else if (st.selectedTool === 'watertower') {\n      bw = 1; bh = 1; // 1x1 for water tower\n    } else if (st.selectedTool === 'pipe') {\n      bw = 1; bh = 1; // 1x1 for pipes\n    }\n    \n    // Check if we can place a multi-tile building\n    if (bw > 1 || bh > 1) {\n      // Check all cells are empty or abandoned\n      let canPlace = true;\n      for (let dy=0; dy<bh; dy++) {\n        for (let dx=0; dx<bw; dx++) {\n          const nx = x + dx, ny = y + dy;\n          if (nx >= GR_SZ || ny >= GR_SZ) { canPlace = false; break; }\n          const nc = st.grid[ny][nx];\n          const ntr = st.terrain[ny][nx];\n          if (ntr === 'water' || ntr === 'cliff') { canPlace = false; break; }\n          if (nc.type !== 'empty' && !nc.abandoned) { canPlace = false; break; }\n        }\n        if (!canPlace) break;\n      }\n      // Water plants must be within 4 tiles of water\n      if (canPlace && (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower')) {\n        let nearWater = false;\n        for (let dy=0; dy<bh; dy++) {\n          for (let dx=0; dx<bw; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (isNearWaterTile(nx, ny, 4)) {\n              nearWater = true;\n              break;\n            }\n          }\n          if (nearWater) break;\n        }\n        if (!nearWater) { canPlace = false; }\n      }\n      if (!canPlace) { plySnd('error'); return; }\n    } else {\n      // For single-tile buildings, check if pipe can overlay\n      if (st.selectedTool === 'pipe') {\n        // Pipes can overlay on any tile except cliff terrain and water plants\n        if (tr === 'cliff') {\n          plySnd('error');\n          return;\n        }\n        // Cannot place pipes on water plants/towers\n        if (c.type === 'waterplant' || c.type === 'watertower') {\n          plySnd('error');\n          return;\n        }\n        // Add pipe property to the cell\n        if (!st.grid[y][x].pipe) {\n          const cs=COSTS.pipe||0; \n          if (st.money<cs) { plySnd('error'); return; }\n          st.grid[y][x].pipe = true;\n          plySnd('place');\n          st.money -= cs;\n          calculateWaterGrid();\n          drGr(); updUI(); sv();\n        }\n        return;\n      }\n      // Water towers must be within 4 tiles of water\n      if (st.selectedTool === 'watertower' && !isNearWaterTile(x, y, 4)) {\n        plySnd('error');\n        return;\n      }\n      if (c.type!=='empty' && !c.abandoned) return;\n    }\n    \n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    plySnd('place'); \n    st.money-=cs;\n\n    // Pre-pass: Clear any abandoned multi-tile buildings that will be partially or fully overwritten\n    for (let dy=0; dy<bh; dy++) {\n      for (let dx=0; dx<bw; dx++) {\n        const nx = x + dx, ny = y + dy;\n        if (nx < GR_SZ && ny < GR_SZ) {\n          const cell = st.grid[ny][nx];\n          if (cell.type !== 'empty' && cell.abandoned && (cell.w > 1 || cell.h > 1)) {\n            const {startX, startY, w, h} = getBuildingBoundsFromCell(nx, ny);\n            for (let bdy=0; bdy<h; bdy++) {\n              for (let bdx=0; bdx<w; bdx++) {\n                const bx = startX + bdx;\n                const by = startY + bdy;\n                if (bx >= 0 && bx < GR_SZ && by >= 0 && by < GR_SZ) {\n                  const bCell = st.grid[by][bx];\n                  const hadPipe = bCell.pipe;\n                  st.grid[by][bx] = {type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                  if (hadPipe) st.grid[by][bx].pipe = true;\n                  normalizeEmptyCell(bx, by);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const buildingId = nextBuildingId++;\n    \n    // Place the building across all its cells\n    for (let dy=0; dy<bh; dy++) {\n      for (let dx=0; dx<bw; dx++) {\n        const nx = x + dx, ny = y + dy;\n        if (nx < GR_SZ && ny < GR_SZ) {\n          const hadPipe = st.grid[ny][nx].pipe;\n          st.grid[ny][nx]={type:st.selectedTool,age:0,level:0,w:bw,h:bh,buildingId:buildingId};\n          if (hadPipe) st.grid[ny][nx].pipe = true;\n        }\n      }\n    }\n    \n    // Recalculate power grid if a power plant or road was placed\n    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear' || st.selectedTool === 'wind' || st.selectedTool === 'road') {\n      calculatePowerGrid();\n      calculateWaterGrid();\n    }\n    \n    // Recalculate water grid if a water plant or water tower was placed\n    if (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {\n      calculateWaterGrid();\n    }\n  }\n  drGr(); updUI(); sv();\n}\n\nfunction getCarSpeedMultiplier() {\n  if (st.speed<=0) return 0;\n  if (st.speed===500) return 3;\n  if (st.speed===1500) return 2;\n  return 1;\n}\n\nfunction getCarSpeedPerFrame(car) {\n  const baseSpeed = CAR_BASE_SPEED * getCarSpeedMultiplier();\n  // Police and fire cars move faster than normal cars\n  if (car && (car.type === 'police' || car.type === 'fire')) {\n    return baseSpeed * EMERGENCY_SPEED_MULTIPLIER;\n  }\n  return baseSpeed;\n}\n\nfunction updateCarLaneOffset(car) {\n  if (car.pathIdx>=car.path.length-1) return;\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    if (Math.abs(dxSeg)>Math.abs(dySeg)) {\n      car.laneOffset=dxSeg>0 ? 5 : -5;\n    } else {\n      car.laneOffset=dySeg>0 ? -5 : 5;\n    }\n}\n\nfunction getCarSegmentTarget(car) {\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  let tx=nextNode.x*CL_SZ+7;\n  let ty=nextNode.y*CL_SZ+7;\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    const horizontal=Math.abs(dxSeg)>Math.abs(dySeg);\n    if (horizontal) ty+=car.laneOffset;\n    else tx+=car.laneOffset;\n    \n    const hasNextTurn=car.pathIdx+2<car.path.length;\n    if (hasNextTurn) {\n      const afterNode=car.path[car.pathIdx+2];\n      const dxNext=afterNode.x-nextNode.x;\n      const dyNext=afterNode.y-nextNode.y;\n      const nextHorizontal=Math.abs(dxNext)>Math.abs(dyNext);\n      if (horizontal && !nextHorizontal) {\n        const nextLaneOffset=dyNext>0 ? -5 : 5;\n        tx+=nextLaneOffset;\n      } else if (!horizontal && nextHorizontal) {\n        const nextLaneOffset=dxNext>0 ? 5 : -5;\n        ty+=nextLaneOffset;\n      }\n    }\n  return {tx,ty};\n}\n\nfunction getCanvasPos(e) {\n  const r = cvs.getBoundingClientRect();\n  const sx = cvs.width / r.width, sy = cvs.height / r.height;\n  let clientX, clientY;\n  \n  if (e.touches && e.touches.length > 0) {\n    clientX = e.touches[0].clientX;\n    clientY = e.touches[0].clientY;\n    lastTouchPos = { x: clientX, y: clientY };\n  } else if (e.changedTouches && e.changedTouches.length > 0) {\n    // For touchend events\n    clientX = e.changedTouches[0].clientX;\n    clientY = e.changedTouches[0].clientY;\n  } else if (lastTouchPos) {\n    // Fallback to last known touch position\n    clientX = lastTouchPos.x;\n    clientY = lastTouchPos.y;\n  } else {\n    clientX = e.clientX;\n    clientY = e.clientY;\n  }\n  \n  const x = Math.floor((clientX - r.left) * sx / CL_SZ);\n  const y = Math.floor((clientY - r.top) * sy / CL_SZ);\n  return { x, y };\n}\n\nfunction placeLine(x0, y0, x1, y1) {\n  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;\n  let err = dx - dy, x = x0, y = y0;\n  const placed = new Set();\n  \n  while (true) {\n    const key = `${x},${y}`;\n    if (!placed.has(key)) {\n      placed.add(key);\n      plcTl(x, y);\n    }\n    if (x === x1 && y === y1) break;\n    const e2 = 2 * err;\n    if (e2 > -dy) { err -= dy; x += sx; }\n    if (e2 < dx) { err += dx; y += sy; }\n  }\n}\n\nfunction placeZone(x0, y0, x1, y1) {\n  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);\n  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);\n  const currentBounds = `${minX},${minY},${maxX},${maxY}`;\n  \n  // Only place if bounds changed to avoid redundant work\n  if (currentBounds === lastZoneBounds) return;\n  lastZoneBounds = currentBounds;\n  \n  for (let y = minY; y <= maxY; y++) {\n    for (let x = minX; x <= maxX; x++) {\n      plcTl(x, y);\n    }\n  }\n}\n\nfunction handleDragStart(e) {\n  // On mobile (touch events), allow scrolling and only handle taps\n  if (e.touches) {\n    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n    isDragging = false;\n    isScrolling = false;\n    hoverPos = null; // Clear hover position on mobile to prevent highlight\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  // Don't start drag if stats view is active\n  if (!st.selectedTool || showLandValueOverlay || showCrimeOverlay) return;\n  \n  const pos = getCanvasPos(e);\n  dragStart = pos;\n  lastPlaced = { x: pos.x, y: pos.y };\n  lastZoneBounds = null; // Reset zone bounds tracking\n  isDragging = true;\n  isScrolling = false;\n}\n\nfunction handleDragMove(e) {\n  // On mobile (touch events), allow native scrolling - don't place tiles while dragging\n  if (e.touches) {\n    if (touchStartPos) {\n      const dx = Math.abs(e.touches[0].clientX - touchStartPos.x);\n      const dy = Math.abs(e.touches[0].clientY - touchStartPos.y);\n      // If moved significantly, mark as scrolling (not a tap)\n      if (dx > 5 || dy > 5) {\n        isScrolling = true;\n      }\n    }\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  // Don't drag if stats view is active\n  if (!st.selectedTool || !isDragging || !dragStart || showLandValueOverlay || showCrimeOverlay) return;\n  \n  const pos = getCanvasPos(e);\n  \n  // For roads: place as line\n  if (st.selectedTool === 'road') {\n    placeLine(dragStart.x, dragStart.y, pos.x, pos.y);\n    dragStart = pos; // Update start for continuous line\n  }\n  // For RCI zones: place as zone\n  else if (st.selectedTool === 'residential' || st.selectedTool === 'commercial' || st.selectedTool === 'industrial') {\n    placeZone(dragStart.x, dragStart.y, pos.x, pos.y);\n  }\n  // For other tools: place individual tiles\n  else {\n    const key = `${pos.x},${pos.y}`;\n    const lastKey = `${lastPlaced.x},${lastPlaced.y}`;\n    if (key !== lastKey) {\n      plcTl(pos.x, pos.y);\n      lastPlaced = pos;\n    }\n  }\n}\n\nfunction handleDragEnd(e) {\n  // Handle mobile tap (touch without scrolling)\n  if (e.changedTouches && touchStartPos && !isScrolling) {\n    const pos = getCanvasPos(e);\n    \n    // If stat view is active, show building info instead of placing tool\n    if (showLandValueOverlay || showCrimeOverlay) {\n      showBuildingInfo(pos.x, pos.y);\n    } else {\n      const c = st.grid[pos.y][pos.x];\n      const isOccupied = c && c.type !== 'empty';\n      const isAbandoned = c && c.abandoned;\n      const isPipeTool = st.selectedTool === 'pipe';\n      \n      // On mobile, when placing tiles, don't show building info panel\n      // Just place the tile directly\n      if (st.selectedTool === 'bulldoze') {\n        plcTl(pos.x, pos.y);\n        justPlacedTileOnMobile = true;\n        setTimeout(() => { justPlacedTileOnMobile = false; }, 300); // Prevent building info for 300ms after placing\n      } else if (isPipeTool) {\n        plcTl(pos.x, pos.y);\n        justPlacedTileOnMobile = true;\n        setTimeout(() => { justPlacedTileOnMobile = false; }, 300);\n      } else if (st.selectedTool) {\n        // Always place tile when tool is selected on mobile (no building info panel)\n        plcTl(pos.x, pos.y);\n        justPlacedTileOnMobile = true;\n        setTimeout(() => { justPlacedTileOnMobile = false; }, 300);\n      } else if (isOccupied && !justPlacedTileOnMobile) {\n        // Only show building info when no tool is selected and we didn't just place a tile\n        showBuildingInfo(pos.x, pos.y);\n      }\n    }\n  }\n  // Handle desktop mouse drag end\n  else if (isDragging && !isScrolling && dragStart && !e.touches) {\n    const pos = getCanvasPos(e);\n    // If we didn't move much (or at all), treat as click\n    const moved = Math.abs(pos.x - dragStart.x) > 0 || Math.abs(pos.y - dragStart.y) > 0;\n    if (!moved) {\n      // If stat view is active, show building info instead of placing tool\n      if (showLandValueOverlay || showCrimeOverlay) {\n        showBuildingInfo(pos.x, pos.y);\n      } else {\n        const c = st.grid[pos.y][pos.x];\n        const isOccupied = c && c.type !== 'empty';\n        const isAbandoned = c && c.abandoned;\n        const isPipeTool = st.selectedTool === 'pipe';\n        \n        if (st.selectedTool === 'bulldoze') {\n          plcTl(pos.x, pos.y);\n        } else if (isPipeTool) {\n          plcTl(pos.x, pos.y);\n        } else if (isOccupied && !isAbandoned) {\n          showBuildingInfo(pos.x, pos.y);\n        } else if (st.selectedTool) {\n          plcTl(pos.x, pos.y);\n        } else if (isOccupied) {\n          showBuildingInfo(pos.x, pos.y);\n        }\n      }\n    }\n  }\n  \n  isDragging = false;\n  isScrolling = false;\n  dragStart = null;\n  lastPlaced = null;\n  touchStartPos = null;\n  lastTouchPos = null;\n  lastZoneBounds = null;\n}\n\n// Mouse events\ncvs.addEventListener('mousedown', handleDragStart);\ncvs.addEventListener('mousemove', handleDragMove);\ncvs.addEventListener('mouseup', handleDragEnd);\ncvs.addEventListener('mouseleave', (e) => {\n  hoverPos = null;\n  handleDragEnd(e);\n});\n\n// Track hover for placement preview\ncvs.addEventListener('mousemove', (e) => {\n  if (!isDragging && (st.selectedTool || showLandValueOverlay || showCrimeOverlay)) {\n    const pos = getCanvasPos(e);\n    hoverPos = pos;\n  } else {\n    hoverPos = null;\n  }\n});\n\n// Touch events - passive for smooth scrolling on mobile\ncvs.addEventListener('touchstart', handleDragStart, { passive: true });\ncvs.addEventListener('touchmove', handleDragMove, { passive: true });\ncvs.addEventListener('touchend', handleDragEnd, { passive: true });\ncvs.addEventListener('touchcancel', handleDragEnd, { passive: true });\n\n// Click handler for mouse only (touch events are handled separately)\ncvs.addEventListener('click', e => {\n  // Only handle mouse clicks, not touch-generated clicks\n  if (e.detail === 0) return; // Touch events have detail = 0\n  if (!isDragging && !isScrolling) {\n    const r = cvs.getBoundingClientRect(), sx = cvs.width / r.width, sy = cvs.height / r.height;\n    const x = Math.floor((e.clientX - r.left) * sx / CL_SZ), y = Math.floor((e.clientY - r.top) * sy / CL_SZ);\n    \n    // If stat view is active, show building info instead of placing tool\n    if (showLandValueOverlay || showCrimeOverlay) {\n      showBuildingInfo(x, y);\n    } else if (st.selectedTool) {\n      plcTl(x, y);\n    }\n  }\n});\n\nconst submenuItems = {\n  park: [\n    { tool: 'park', icon: 'üå≥', tooltip: 'park', shortcut: '1' },\n    { tool: 'park2', icon: 'üå∏', tooltip: 'park', shortcut: '2' },\n    { tool: 'park3', icon: 'üå≤', tooltip: 'park', shortcut: '3' },\n    { tool: 'park4', icon: 'üåª', tooltip: 'park', shortcut: '4' }\n  ],\n  services: [\n    { tool: 'police', icon: 'üöì', tooltip: 'police station', shortcut: '1' },\n    { tool: 'fire', icon: 'üöí', tooltip: 'fire station', shortcut: '2' },\n    { tool: 'school', icon: 'üè´', tooltip: 'school', shortcut: '3' },\n    { tool: 'hospital', icon: 'üè•', tooltip: 'hospital', shortcut: '4' }\n  ],\n  water: [\n    { tool: 'pipe', icon: 'üíß', tooltip: 'water pipe', shortcut: '1' },\n    { tool: 'waterplant', icon: 'üè≠', tooltip: 'water treatment plant', shortcut: '2' },\n    { tool: 'watertower', icon: 'üóº', tooltip: 'water tower', shortcut: '3' }\n  ],\n  power: [\n    { tool: 'coal', icon: '‚ö°', tooltip: 'coal plant', shortcut: '1' },\n    { tool: 'nuclear', icon: '‚ò¢Ô∏è', tooltip: 'nuclear plant', shortcut: '2' },\n    { tool: 'wind', icon: 'üí®', tooltip: 'wind plant', shortcut: '3' }\n  ],\n  disaster: [\n    { disaster: 'fire', icon: 'üî•', tooltip: 'fire', shortcut: '1' },\n    { disaster: 'crime', icon: 'üö®', tooltip: 'crime', shortcut: '2' },\n    { disaster: 'earthquake', icon: 'üåç', tooltip: 'earthquake', shortcut: '3' }\n  ]\n};\n\nfunction openSubmenu(button, submenuKey) {\n  // Don't close water submenu if switching to bulldoze\n  if (activeSubmenu && activeSubmenu.submenuKey === 'water' && st.selectedTool === 'bulldoze') {\n    // Keep water submenu open\n  } else {\n    // Close any existing submenu\n    closeSubmenu();\n  }\n  \n  // Store reference to the button\n  activeSubmenu = { button, submenuKey };\n  \n  // Change button to X\n  const originalContent = button.innerHTML;\n  button.dataset.originalContent = originalContent;\n  button.innerHTML = '‚úï';\n  button.classList.add('submenu-active');\n  \n  // Get sub-toolbar\n  const subToolbar = document.getElementById('subToolbar');\n  \n  // Populate sub-toolbar with items (but keep hidden for now)\n  subToolbar.innerHTML = '';\n  const items = submenuItems[submenuKey];\n  items.forEach(item => {\n    const subBtn = document.createElement('button');\n    subBtn.className = 'tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center';\n    if (item.tool) {\n      subBtn.dataset.tool = item.tool;\n    }\n    if (item.disaster) {\n      subBtn.dataset.disaster = item.disaster;\n    }\n    if (item.tooltip) {\n      subBtn.dataset.tooltip = item.tooltip;\n      if (item.shortcut) {\n        subBtn.dataset.shortcut = item.shortcut;\n      }\n      subBtn.addEventListener('mouseenter', () => {\n        showTooltip(subBtn, item.tooltip);\n      });\n      subBtn.addEventListener('mouseleave', () => {\n        hideTooltip();\n      });\n    }\n    subBtn.textContent = item.icon;\n    subBtn.addEventListener('click', (e) => {\n      e.stopPropagation();\n      plySnd('click');\n      if (item.tool) {\n        selTl(item.tool);\n        // Don't close submenu - keep it open so user can switch tools\n      } else if (item.disaster) {\n        // Trigger disaster and close submenu\n        if (item.disaster === 'fire') {\n          startFire();\n        } else if (item.disaster === 'crime') {\n          startCrimeEvent();\n        } else if (item.disaster === 'earthquake') {\n          startQuake();\n        }\n        closeSubmenu();\n      }\n    });\n    subToolbar.appendChild(subBtn);\n  });\n  \n  // Auto-select the first tool in the submenu (only for tools, not disasters)\n  if (items.length > 0 && items[0].tool) {\n    selTl(items[0].tool);\n  }\n  \n  // Show water overlay when water submenu opens\n  if (submenuKey === 'water') {\n    setWaterOverlay(true);\n  }\n  \n  // Make submenu invisible but rendered to measure it\n  subToolbar.style.visibility = 'hidden';\n  subToolbar.classList.remove('hidden');\n  \n  // Position submenu vertically centered on the toggle button\n  requestAnimationFrame(() => {\n    const parentContainer = button.closest('.flex.flex-shrink-0.relative');\n    const parentRect = parentContainer.getBoundingClientRect();\n    const buttonRect = button.getBoundingClientRect();\n    const subToolbarRect = subToolbar.getBoundingClientRect();\n    \n    // Calculate positions relative to parent container\n    const buttonTopRelative = buttonRect.top - parentRect.top;\n    const buttonCenterY = buttonTopRelative + buttonRect.height / 2;\n    const submenuHeight = subToolbarRect.height;\n    const submenuCenterY = submenuHeight / 2;\n    \n    // Calculate top position to center submenu on button\n    const topPosition = buttonCenterY - submenuCenterY;\n    subToolbar.style.top = `${topPosition}px`;\n    \n    // Now make it visible\n    subToolbar.style.visibility = '';\n    \n    updateToolSelection();\n  });\n}\n\nfunction closeSubmenu() {\n  if (activeSubmenu) {\n    // Don't close water submenu if bulldoze is selected (water tool mode)\n    if (activeSubmenu.submenuKey === 'water' && st.selectedTool === 'bulldoze') {\n      return;\n    }\n    \n    // Restore original button content\n    if (activeSubmenu.button.dataset.originalContent) {\n      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;\n      activeSubmenu.button.classList.remove('submenu-active');\n    }\n    const wasWaterSubmenu = activeSubmenu.submenuKey === 'water';\n    activeSubmenu = null;\n    \n    // Always hide water overlay when water submenu closes (unless bulldoze is selected)\n    if (wasWaterSubmenu && st.selectedTool !== 'bulldoze') {\n      setWaterOverlay(false);\n    }\n  }\n  \n  // Hide sub-toolbar and reset position\n  const subToolbar = document.getElementById('subToolbar');\n  subToolbar.classList.add('hidden');\n  subToolbar.style.top = '';\n  subToolbar.style.visibility = '';\n}\n\nfunction forceCloseSubmenu() {\n  if (activeSubmenu) {\n    // Restore original button content\n    if (activeSubmenu.button.dataset.originalContent) {\n      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;\n      activeSubmenu.button.classList.remove('submenu-active');\n    }\n    const wasWaterSubmenu = activeSubmenu.submenuKey === 'water';\n    activeSubmenu = null;\n    \n    // Always hide water overlay when water submenu closes\n    if (wasWaterSubmenu) {\n      setWaterOverlay(false);\n    }\n  }\n  \n  // Hide sub-toolbar and reset position\n  const subToolbar = document.getElementById('subToolbar');\n  subToolbar.classList.add('hidden');\n  subToolbar.style.top = '';\n  subToolbar.style.visibility = '';\n}\n\nfunction updateToolSelection() {\n  // Update all tool buttons including sub-toolbar buttons\n  document.querySelectorAll('.tool-btn').forEach(b => {\n    const bt = b.dataset.tool;\n    b.style.borderColor = '';\n    b.style.opacity = '';\n    if (bt === st.selectedTool) {\n      b.style.borderColor = '#666';\n      b.style.opacity = '1';\n    } else {\n      // All other unselected buttons get reduced opacity (including submenu toggle showing X and disaster buttons)\n      b.style.opacity = '0.5';\n    }\n  });\n}\n\n// Create tooltip element\nlet tooltipEl = null;\nfunction createTooltip() {\n  if (!tooltipEl) {\n    tooltipEl = document.createElement('div');\n    tooltipEl.className = 'tooltip';\n    document.body.appendChild(tooltipEl);\n  }\n  return tooltipEl;\n}\n\nfunction showTooltip(button, text) {\n  // Only show on devices that support hover\n  if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {\n    const tooltip = createTooltip();\n    const shortcut = button.dataset.shortcut;\n    if (shortcut) {\n      tooltip.innerHTML = `${text}<span class=\"tooltip-shortcut\">${shortcut}</span>`;\n    } else {\n      tooltip.textContent = text;\n    }\n    tooltip.classList.add('show');\n    \n    const rect = button.getBoundingClientRect();\n    tooltip.style.left = `${rect.left - tooltip.offsetWidth - 8}px`;\n    tooltip.style.top = `${rect.top + rect.height / 2}px`;\n    tooltip.style.transform = 'translateY(-50%)';\n    \n    // Recalculate position after tooltip is rendered\n    setTimeout(() => {\n      const tooltipRect = tooltip.getBoundingClientRect();\n      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;\n    }, 0);\n  }\n}\n\nfunction hideTooltip() {\n  if (tooltipEl) {\n    tooltipEl.classList.remove('show');\n  }\n}\n\n// Keyboard shortcut mapping\nconst keyToTool = {\n  'r': 'road',\n  'R': 'road',\n  'h': 'residential',\n  'H': 'residential',\n  'c': 'commercial',\n  'C': 'commercial',\n  'i': 'industrial',\n  'I': 'industrial',\n  'p': 'park',\n  'P': 'park',\n  's': 'services',\n  'S': 'services',\n  'e': 'power',\n  'E': 'power',\n  'q': 'water',\n  'Q': 'water',\n  'd': 'bulldoze',\n  'D': 'bulldoze',\n  'w': 'disaster',\n  'W': 'disaster'\n};\n\nfunction triggerToolByKey(key) {\n  const tool = keyToTool[key];\n  if (!tool) return false;\n  \n  // Find the button for this tool\n  if (tool === 'disaster') {\n    const disasterBtn = document.querySelector('[data-submenu=\"disaster\"]');\n    if (disasterBtn && st.disastersEnabled) {\n      if (activeSubmenu && activeSubmenu.button === disasterBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(disasterBtn, 'disaster');\n      }\n      return true;\n    }\n  } else if (tool === 'park') {\n    const parkBtn = document.querySelector('[data-submenu=\"park\"]');\n    if (parkBtn) {\n      if (activeSubmenu && activeSubmenu.button === parkBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(parkBtn, 'park');\n      }\n      return true;\n    }\n  } else if (tool === 'services') {\n    const servicesBtn = document.querySelector('[data-submenu=\"services\"]');\n    if (servicesBtn) {\n      if (activeSubmenu && activeSubmenu.button === servicesBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(servicesBtn, 'services');\n      }\n      return true;\n    }\n  } else if (tool === 'power') {\n    const powerBtn = document.querySelector('[data-submenu=\"power\"]');\n    if (powerBtn) {\n      if (activeSubmenu && activeSubmenu.button === powerBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(powerBtn, 'power');\n      }\n      return true;\n    }\n  } else if (tool === 'water') {\n    const waterBtn = document.querySelector('[data-submenu=\"water\"]');\n    if (waterBtn) {\n      if (activeSubmenu && activeSubmenu.button === waterBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(waterBtn, 'water');\n      }\n      return true;\n    }\n  } else {\n    const toolBtn = document.querySelector(`[data-tool=\"${tool}\"]`);\n    if (toolBtn) {\n      toolBtn.click();\n      return true;\n    }\n  }\n  return false;\n}\n\n// Handle submenu shortcuts when submenu is open\nfunction handleSubmenuShortcut(key) {\n  if (!activeSubmenu) return false;\n  \n  if (activeSubmenu.submenuKey === 'disaster') {\n    const shortcuts = { '1': 'fire', '2': 'crime', '3': 'earthquake' };\n    const disaster = shortcuts[key];\n    if (disaster) {\n      const subBtn = document.querySelector(`[data-disaster=\"${disaster}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'park') {\n    const shortcuts = { '1': 'park', '2': 'park2', '3': 'park3', '4': 'park4' };\n    const parkTool = shortcuts[key];\n    if (parkTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${parkTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'services') {\n    const shortcuts = { '1': 'police', '2': 'fire', '3': 'school', '4': 'hospital' };\n    const servicesTool = shortcuts[key];\n    if (servicesTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${servicesTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'power') {\n    const shortcuts = { '1': 'coal', '2': 'nuclear', '3': 'wind' };\n    const powerTool = shortcuts[key];\n    if (powerTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${powerTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction setSpeedByNumber(num) {\n  plySnd('click');\n  if (num === 0) {\n    st.speed = 0;\n  } else if (num === 1) {\n    st.speed = 3000;\n  } else if (num === 2) {\n    st.speed = 1500;\n  } else if (num === 3) {\n    st.speed = 500;\n  }\n  sv();\n  if (tkTmr) clearInterval(tkTmr);\n  if (st.speed > 0) {\n    TK_INT = st.speed;\n    tkTmr = setInterval(simTk, TK_INT);\n    updNwsTk();\n  } else {\n    updNwsTk();\n  }\n  updUI();\n}\n\ndocument.addEventListener('keydown', (e) => {\n  // Don't trigger if user is typing in an input field\n  const activeElement = document.activeElement;\n  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {\n    return;\n  }\n  \n  // Handle speed controls (0-3) only if no submenu is open\n  if (!activeSubmenu && (e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3')) {\n    const num = parseInt(e.key);\n    setSpeedByNumber(num);\n    e.preventDefault();\n    return;\n  }\n  \n  // Handle submenu shortcuts when submenu is open\n  if (handleSubmenuShortcut(e.key)) {\n    e.preventDefault();\n    return;\n  }\n  \n  // Handle main tool shortcuts\n  if (triggerToolByKey(e.key)) {\n    e.preventDefault();\n  }\n});\n\ndocument.querySelectorAll('.tool-btn').forEach(b => {\n  const tooltipText = b.dataset.tooltip;\n  if (tooltipText) {\n    b.addEventListener('mouseenter', () => {\n      showTooltip(b, tooltipText);\n    });\n    b.addEventListener('mouseleave', () => {\n      hideTooltip();\n    });\n  }\n  \n  b.addEventListener('click', (e) => {\n    plySnd('click');\n    hideTooltip();\n    \n    // Check if this button has a submenu\n    if (b.dataset.submenu) {\n      // If submenu is already open, close it (force close to handle water+bulldoze case)\n      if (activeSubmenu && activeSubmenu.button === b) {\n        forceCloseSubmenu();\n      } else {\n        // Open submenu\n        openSubmenu(b, b.dataset.submenu);\n      }\n    } else if (b.dataset.tool) {\n      // Regular tool selection\n      selTl(b.dataset.tool);\n      closeSubmenu();\n    }\n  });\n});\n\nfunction updateDisasterButtonsVisibility() {\n  const disasterButtons = document.querySelectorAll('.disaster-btn');\n  disasterButtons.forEach(btn => {\n    btn.style.display = st.disastersEnabled ? 'flex' : 'none';\n  });\n}\n\nfunction centerCanvas() {\n  const gridContainer = document.getElementById('grid');\n  if (!gridContainer) return;\n  \n  // Wait for next frame to ensure layout is calculated\n  requestAnimationFrame(() => {\n    const zoom = st.zoom || 1;\n    const canvasWidth = cvs.width * zoom;\n    const canvasHeight = cvs.height * zoom;\n    const containerWidth = gridContainer.clientWidth;\n    const containerHeight = gridContainer.clientHeight;\n    \n    // If canvas is smaller than container, center it with CSS\n    if (canvasWidth <= containerWidth && canvasHeight <= containerHeight) {\n      // Center using flexbox or margin auto\n      gridContainer.style.display = 'flex';\n      gridContainer.style.justifyContent = 'center';\n      gridContainer.style.alignItems = 'center';\n      gridContainer.scrollLeft = 0;\n      gridContainer.scrollTop = 0;\n    } else {\n      // Canvas is larger, use scroll positioning\n      gridContainer.style.display = 'block';\n      gridContainer.style.justifyContent = '';\n      gridContainer.style.alignItems = '';\n      \n      // Calculate scroll position to center the canvas\n      const scrollLeft = Math.max(0, (canvasWidth - containerWidth) / 2);\n      const scrollTop = Math.max(0, (canvasHeight - containerHeight) / 2);\n      \n      gridContainer.scrollLeft = scrollLeft;\n      gridContainer.scrollTop = scrollTop;\n    }\n  });\n}\n\nfunction applyZoom() {\n  if (!st.zoom) st.zoom = 1;\n  cvs.style.transform = `scale(${st.zoom})`;\n  cvs.style.transformOrigin = 'top left';\n  document.getElementById('zoomLevel').textContent = Math.round(st.zoom * 100) + '%';\n  sv();\n  centerCanvas();\n}\n\nfunction zoomIn() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.min(3, st.zoom + 0.25);\n  applyZoom();\n}\n\nfunction zoomOut() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.max(0.25, st.zoom - 0.25);\n  applyZoom();\n}\n\nfunction zoomReset() {\n  st.zoom = 1;\n  applyZoom();\n}\n\ndocument.getElementById('zoomInBtn').addEventListener('click', () => { plySnd('click'); zoomIn(); });\ndocument.getElementById('zoomOutBtn').addEventListener('click', () => { plySnd('click'); zoomOut(); });\n\nconst inpNm=document.getElementById('cityName');\ninpNm.addEventListener('focus', () => edtNm=true);\ninpNm.addEventListener('blur', () => { edtNm=false; st.cityName=inpNm.value||'new city'; sv(); updUI(); });\ninpNm.addEventListener('input', () => updInpWd());\ninpNm.addEventListener('change', e => { st.cityName=e.target.value||'new city'; sv(); });\ninpNm.addEventListener('click', e => e.target.select());\n\ndocument.getElementById('menuBtn').addEventListener('click', () => {\n  plySnd('click'); const m=document.getElementById('menu'); m.classList.toggle('hidden');\n  document.getElementById('newGamePanel').classList.add('hidden'); \n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n});\n\ndocument.getElementById('speedToggle').addEventListener('click', () => {\n  plySnd('click');\n  if (st.speed===0) st.speed=3000; else if (st.speed===3000) st.speed=1500; else if (st.speed===1500) st.speed=500; else st.speed=0;\n  sv(); if (tkTmr) clearInterval(tkTmr);\n  if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); updNwsTk(); }\n  else updNwsTk();\n  updUI();\n});\n\nconst exportBtn = document.getElementById('exportBtn');\nif (exportBtn) {\n  exportBtn.addEventListener('click', () => {\n    try { plySnd('click'); } catch(e) {}\n    try {\n      const stateJson = JSON.stringify(st, null, 2);\n      const cityName = (st.cityName || 'city').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n      const dateStr = new Date().toISOString().split('T')[0];\n      const filename = `${cityName}_${dateStr}.json`;\n      \n      let url;\n      let useBlob = true;\n      try {\n        const blob = new Blob([stateJson], { type: 'application/json' });\n        url = URL.createObjectURL(blob);\n      } catch (e) {\n        useBlob = false;\n        url = 'data:application/json;charset=utf-8,' + encodeURIComponent(stateJson);\n      }\n      \n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      a.click();\n      setTimeout(() => {\n        document.body.removeChild(a);\n        if (useBlob && url) URL.revokeObjectURL(url);\n      }, 100);\n    } catch (e) {\n      console.error('Export failed:', e);\n      alert('Export failed: ' + (e.message || String(e)));\n    }\n  });\n}\n\ndocument.getElementById('importBtn').addEventListener('click', () => {\n  plySnd('click');\n  document.getElementById('importFileInput').click();\n});\n\ndocument.getElementById('importFileInput').addEventListener('change', (e) => {\n  const file = e.target.files[0];\n  if (!file) return;\n  \n  const reader = new FileReader();\n    reader.onload = (event) => {\n      try {\n        const importedState = JSON.parse(event.target.result);\n        if (followedResident !== null) stopFollowingResident();\n        highlightedBuilding = null;\n        highlightedWorkplace = null;\n        lastBuildingView = null;\n        if (applyLoadedState(importedState)) {\n        if (tkTmr) clearInterval(tkTmr);\n        if (st.speed > 0) {\n          TK_INT = st.speed;\n          tkTmr = setInterval(simTk, TK_INT);\n        }\n        nwsQ = [];\n        trans = false;\n        const buildingInfoPanel = document.getElementById('buildingInfoPanel');\n        if (buildingInfoPanel) buildingInfoPanel.classList.add('hidden');\n        forceCloseSubmenu();\n        document.getElementById('menu').classList.add('hidden');\n        document.getElementById('aiPanel').classList.add('hidden');\n        document.getElementById('infoPanel').classList.add('hidden');\n        currentInfoType = null;\n        setLandValueOverlay(false);\n        setCrimeOverlay(false);\n        setWaterOverlay(false);\n        drGr();\n        updUI();\n        updNwsTk();\n        const savedTool = st.selectedTool || 'road';\n        selTl(savedTool);\n        sv();\n        setTimeout(centerCanvas, 100);\n      } else {\n        alert('Invalid city file format');\n      }\n    } catch (error) {\n      console.error('Import failed:', error);\n      alert('Failed to import city file');\n    }\n    e.target.value = '';\n  };\n  reader.readAsText(file);\n});\n\ndocument.getElementById('newCityBtn').addEventListener('click', () => { \n  plySnd('click'); \n  document.getElementById('newCityName').value = '';\n  document.getElementById('menu').classList.add('hidden'); \n  document.getElementById('newGamePanel').classList.remove('hidden'); \n});\n\nfunction generateRandomCityName() {\n  const prefixes = ['new', 'port', 'lake', 'river', 'green', 'sun', 'oak', 'maple', 'pine', 'cedar', 'spring', 'summer', 'winter', 'bay', 'hill', 'valley', 'mountain', 'forest', 'park', 'bridge', 'mill', 'brook', 'rock', 'stone', 'bright', 'fair', 'grand', 'royal', 'silver', 'golden'];\n  const suffixes = ['ville', 'burg', 'ton', 'field', 'wood', 'dale', 'brook', 'haven', 'port', 'shore', 'view', 'ridge', 'crest', 'peak', 'falls', 'springs', 'beach', 'bay', 'city', 'town', 'land', 'ford', 'bridge', 'mill', 'park', 'grove', 'heights', 'hills', 'valley', 'creek'];\n  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];\n  const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];\n  const cityName = prefix + suffix;\n  return cityName.charAt(0).toUpperCase() + cityName.slice(1);\n}\n\ndocument.getElementById('startGameBtn').addEventListener('click', () => {\n  plySnd('click');\n  const inputValue = document.getElementById('newCityName').value.trim();\n  const nm = inputValue || generateRandomCityName(), tr=document.getElementById('terrainType').value, df=document.getElementById('difficulty').value;\n  let mn=50000; if (df==='easy') mn=100000; else if (df==='hard') mn=20000;\n  if (followedResident!==null) stopFollowingResident();\n  highlightedBuilding=null;\n  highlightedWorkplace=null;\n  lastBuildingView=null;\n  aiReq=false; initGr(tr); st.money=mn; st.population=0; st.happiness=70; st.tickCount=0; st.cityName=nm; st.rDemand=50; st.cDemand=50; st.iDemand=50; st.year=1950; st.newsEvents=['Welcome to '+nm+'!']; st.ticksSinceNews=0; st.employment=0; st.taxRate=10;\n  nwsQ=[]; trans=false;\n  if (!st.zoom) st.zoom=1;\n  const buildingInfoPanel=document.getElementById('buildingInfoPanel');\n  if (buildingInfoPanel) buildingInfoPanel.classList.add('hidden');\n  forceCloseSubmenu();\n  document.getElementById('menu').classList.add('hidden');\n  document.getElementById('newGamePanel').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  setWaterOverlay(false);\n  drGr(); updUI(); updNwsTk();\n  selTl('road'); sv();\n  setTimeout(centerCanvas, 100);\n});\n\ndocument.getElementById('aiSuggestBtn').addEventListener('click', async () => {\n  plySnd('click'); document.getElementById('menu').classList.add('hidden'); document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  setWaterOverlay(false);\n  const pnl=document.getElementById('aiPanel'), msg=document.getElementById('aiMessage');\n  pnl.classList.remove('hidden'); msg.innerHTML='<span class=\"text-neutral-500\">thinking...</span>';\n  const cnts=getBuildingCounts();\n  const prm=`You are an AI mayor advisor for a SimCity-like game. Analyze the current city state and give 2-3 SHORT, actionable suggestions (1-2 sentences total).\\n\\nCurrent city stats:\\n- Money: $${st.money.toLocaleString()}\\n- Population: ${st.population}\\n- Happiness: ${st.happiness}/100\\n- Buildings: ${JSON.stringify(cnts)}\\n- RCI Demand: R=${st.rDemand}% C=${st.cDemand}% I=${st.iDemand}%\\n\\nAvailable building types: road, residential, commercial, industrial, park, police, fire, school, hospital\\n\\nGive practical advice based on what's missing or unbalanced. Keep it brief and conversational.`;\n  try {\n    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n    if (!r.ok) throw new Error('AI request failed');\n    const d=await r.json(), rp=d.reply||'everything looks good!';\n    msg.textContent=''; let i=0;\n    const tw=setInterval(() => { if (i<rp.length) { msg.textContent+=rp.charAt(i); i++; } else clearInterval(tw); },20);\n  } catch(e) { console.error('AI error:',e); msg.textContent='could not reach AI mayor. try building more infrastructure!'; }\n});\n\ndocument.getElementById('closeAiBtn').addEventListener('click', () => { plySnd('click'); document.getElementById('aiPanel').classList.add('hidden'); });\ndocument.getElementById('closeInfoBtn').addEventListener('click', () => {\n  plySnd('click');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  setWaterOverlay(false);\n});\n\n// ESC key to close panels\ndocument.addEventListener('keydown', (e) => {\n  if (e.key === 'Escape') {\n    const buildingInfoPanel = document.getElementById('buildingInfoPanel');\n    const infoPanel = document.getElementById('infoPanel');\n    \n    // Close building info panel if open\n    if (buildingInfoPanel && !buildingInfoPanel.classList.contains('hidden')) {\n      hideBuildingInfo();\n      e.preventDefault();\n      return;\n    }\n    \n    // Close stat info panel if open\n    if (infoPanel && !infoPanel.classList.contains('hidden')) {\n      plySnd('click');\n      infoPanel.classList.add('hidden');\n      currentInfoType = null;\n      setLandValueOverlay(false);\n      setCrimeOverlay(false);\n      setWaterOverlay(false);\n      e.preventDefault();\n    }\n  }\n});\n\n  function statItem(label, value, colorClass = '') {\n    return `<div class=\"flex flex-col flex-shrink-0\"><div class=\"text-xs text-neutral-400\">${label}</div><div class=\"${colorClass}\">${value}</div></div>`;\n  }\n  \n  function getBuildingCounts() {\n    const counts = {};\n    for (let y = 0; y < GR_SZ; y++) {\n      for (let x = 0; x < GR_SZ; x++) {\n        const cell = st.grid?.[y]?.[x];\n        if (!cell || !cell.type || cell.type === 'empty') continue;\n        if (!isTopLeftCell(x, y)) continue;\n        counts[cell.type] = (counts[cell.type] || 0) + 1;\n      }\n    }\n    const totalParks = Object.entries(counts).reduce((sum, [type, count]) => {\n      return (typeof type === 'string' && type.startsWith('park')) ? sum + count : sum;\n    }, 0);\n    counts.park = totalParks;\n    return counts;\n  }\n\n  function getStatsContent(infoType) {\n    const cnts = getBuildingCounts();\n    const getCount = type => cnts[type] || 0;\n  \n  let content = '';\n  let title = '';\n  \n  if (infoType === 'rci') {\n    title = 'City Stats';\n    \n    // Get power and water stats with details\n    const powerStats = calculatePowerStats(true);\n    const powerSurplus = powerStats.powerSurplus;\n    const powerColor = powerSurplus >= 0 ? 'text-green-500' : 'text-red-500';\n    const powerDisplay = powerSurplus >= 0 ? `+${powerSurplus}` : powerSurplus.toString();\n    \n    const waterStats = calculateWaterStats(true);\n    const waterSurplus = waterStats.waterSurplus;\n    const waterColor = waterSurplus >= 0 ? 'text-green-500' : 'text-red-500';\n    const waterDisplay = waterSurplus >= 0 ? `+${waterSurplus}` : waterSurplus.toString();\n    \n    content = `\n      <div class=\"space-y-3\">\n        <div>\n          <div class=\"text-xs text-neutral-500 mb-1\">RCI Demand</div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('residential', `${st.rDemand}%`, 'text-green-500')}\n            ${statItem('commercial', `${st.cDemand}%`, 'text-blue-500')}\n            ${statItem('industrial', `${st.iDemand}%`, 'text-yellow-500')}\n          </div>\n        </div>\n        <div class=\"h-px w-full bg-neutral-700\"></div>\n        <div>\n          <div class=\"text-xs text-neutral-500 mb-1\">Power</div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('generation', `+${powerStats.totalPowerGeneration}`, 'text-green-500')}\n            ${statItem('consumption', `-${powerStats.totalPowerConsumption}`, 'text-red-500')}\n            ${statItem('surplus', powerDisplay, powerColor)}\n          </div>\n          <div class=\"flex flex-wrap gap-6 py-1 text-xs\">\n            ${powerStats.coalCount > 0 ? statItem('Coal', `+${powerStats.coalGen} (${powerStats.coalCount})`, '') : ''}\n            ${powerStats.nuclearCount > 0 ? statItem('Nuclear', `+${powerStats.nuclearGen} (${powerStats.nuclearCount})`, '') : ''}\n            ${powerStats.windCount > 0 ? statItem('Wind', `+${powerStats.windGen} (${powerStats.windCount})`, '') : ''}\n          </div>\n        </div>\n        <div class=\"h-px w-full bg-neutral-700\"></div>\n        <div>\n          <div class=\"text-xs text-neutral-500 mb-1\">Water</div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('generation', `+${waterStats.totalWaterGeneration}`, 'text-green-500')}\n            ${statItem('consumption', `-${waterStats.totalWaterConsumption}`, 'text-red-500')}\n            ${statItem('surplus', waterDisplay, waterColor)}\n          </div>\n          <div class=\"flex flex-wrap gap-6 py-1 text-xs\">\n            ${waterStats.waterplantCount > 0 ? statItem('Treatment', `+${waterStats.waterplantGen} (${waterStats.waterplantCount})`, '') : ''}\n            ${waterStats.watertowerCount > 0 ? statItem('Tower', `+${waterStats.watertowerGen} (${waterStats.watertowerCount})`, '') : ''}\n          </div>\n        </div>\n      </div>\n      <div class=\"mt-3 text-xs text-neutral-400\">Power flows via roads, water via pipes. Negative values indicate shortage.</div>`;\n  } else if (infoType === 'pop') {\n    title = 'Population';\n    const bPR=10; let popL1=0, popL2=0, popL3=0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n        const sM=(c.w||1)*(c.h||1);\n        if (c.level===3) popL3+=Math.floor(bPR*sM*1.5);\n        else if (c.level===2) popL2+=Math.floor(bPR*sM*1.2);\n        else if (c.level>=1) popL1+=Math.floor(bPR*sM*1);\n      }\n    }\n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('total', fmtCompact(st.population))}${statItem('zones', cnts.residential||0)}${statItem('employment', `${st.employment}%`)}${statItem('L1', fmtCompact(popL1))}${statItem('L2', fmtCompact(popL2))}${statItem('L3', fmtCompact(popL3))}</div><div class=\"mt-3 text-xs text-neutral-400\">Build more residential zones to grow, levels upgrade with parks, services, and education</div>`;\n  } else if (infoType === 'power') {\n    title = 'Energy';\n    // Calculate power stats with detailed breakdown\n    const powerStats = calculatePowerStats(true);\n    const powerSurplus = powerStats.powerSurplus;\n    const powerColor = powerSurplus >= 0 ? 'text-green-500' : 'text-red-500';\n    const surplusDisplay = powerSurplus >= 0 ? `+${powerSurplus}` : powerSurplus.toString();\n    \n    content = `<div class=\"flex flex-wrap gap-6 py-2\">\n      ${statItem('generation', `+${powerStats.totalPowerGeneration}`, 'text-green-500')}\n      ${statItem('consumption', `-${powerStats.totalPowerConsumption}`, 'text-red-500')}\n      ${statItem('surplus', surplusDisplay, powerColor)}\n    </div>\n    <div class=\"mt-2 space-y-2\">\n      <div>\n        <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${powerStats.coalCount > 0 ? statItem('Coal', `+${powerStats.coalGen} (${powerStats.coalCount})`, '') : ''}\n          ${powerStats.nuclearCount > 0 ? statItem('Nuclear', `+${powerStats.nuclearGen} (${powerStats.nuclearCount})`, '') : ''}\n          ${powerStats.windCount > 0 ? statItem('Wind', `+${powerStats.windGen} (${powerStats.windCount})`, '') : ''}\n          ${powerStats.coalCount === 0 && powerStats.nuclearCount === 0 && powerStats.windCount === 0 ? '<div class=\"text-xs text-neutral-500\">No power plants built</div>' : ''}\n        </div>\n      </div>\n      <div>\n        <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${powerStats.residentialConsumption > 0 ? statItem('Residential', `-${powerStats.residentialConsumption}`, 'text-green-500') : ''}\n          ${powerStats.commercialConsumption > 0 ? statItem('Commercial', `-${powerStats.commercialConsumption}`, 'text-blue-500') : ''}\n          ${powerStats.industrialConsumption > 0 ? statItem('Industrial', `-${powerStats.industrialConsumption}`, 'text-yellow-500') : ''}\n          ${powerStats.totalPowerConsumption === 0 ? '<div class=\"text-xs text-neutral-500\">No buildings consuming power</div>' : ''}\n        </div>\n      </div>\n    </div>\n    <div class=\"mt-2 text-xs text-neutral-400\">Power flows via roads from power plants. L2+L3 residential, all commercial and industrial require power.</div>`;\n  } else if (infoType === 'water') {\n    title = 'Water';\n    // Calculate water stats with detailed breakdown\n    const waterStats = calculateWaterStats(true);\n    const waterSurplus = waterStats.waterSurplus;\n    const waterColor = waterSurplus >= 0 ? 'text-green-500' : 'text-red-500';\n    const surplusDisplay = waterSurplus >= 0 ? `+${waterSurplus}` : waterSurplus.toString();\n    \n    content = `<div class=\"flex flex-wrap gap-6 py-2\">\n      ${statItem('generation', `+${waterStats.totalWaterGeneration}`, 'text-green-500')}\n      ${statItem('consumption', `-${waterStats.totalWaterConsumption}`, 'text-red-500')}\n      ${statItem('surplus', surplusDisplay, waterColor)}\n    </div>\n    <div class=\"mt-2 space-y-2\">\n      <div>\n        <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${waterStats.waterplantCount > 0 ? statItem('Treatment Plant', `+${waterStats.waterplantGen} (${waterStats.waterplantCount})`, '') : ''}\n          ${waterStats.watertowerCount > 0 ? statItem('Water Tower', `+${waterStats.watertowerGen} (${waterStats.watertowerCount})`, '') : ''}\n          ${waterStats.waterplantCount === 0 && waterStats.watertowerCount === 0 ? '<div class=\"text-xs text-neutral-500\">No water infrastructure built</div>' : ''}\n        </div>\n      </div>\n      <div>\n        <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${waterStats.residentialConsumption > 0 ? statItem('Residential', `-${waterStats.residentialConsumption}`, 'text-green-500') : ''}\n          ${waterStats.commercialConsumption > 0 ? statItem('Commercial', `-${waterStats.commercialConsumption}`, 'text-blue-500') : ''}\n          ${waterStats.industrialConsumption > 0 ? statItem('Industrial', `-${waterStats.industrialConsumption}`, 'text-yellow-500') : ''}\n          ${waterStats.totalWaterConsumption === 0 ? '<div class=\"text-xs text-neutral-500\">No buildings consuming water</div>' : ''}\n        </div>\n      </div>\n    </div>\n    <div class=\"mt-2 text-xs text-neutral-400\">Water flows via pipes from water plants/towers. All L1+ buildings require water.</div>`;\n  } else if (infoType === 'money') {\n    title = 'Budget';\n    // Calculate income breakdown (same logic as simTk)\n    let residentialIncome = 0, commercialRevenue = 0, industrialRevenue = 0, tourismIncome = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseTax=2.5; // Increased to balance expenses\n        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n        const landValueMultiplier=1+(lv-50)/100;\n        const popPerCell=Math.floor(10*size*levelMultiplier);\n        residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);\n      } else if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseRevenue=18; // Increased to balance expenses\n        const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));\n        const landValueMultiplier=1+(lv-50)/80;\n        const employmentMultiplier=0.5+(st.employment/200);\n        const populationMultiplier=Math.min(2.0,1+(st.population/5000));\n        commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);\n      } else if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseRevenue=24; // Increased to balance expenses\n        const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));\n        const landValueMultiplier=1+(lv-50)/100;\n        const employmentMultiplier=0.4+(st.employment/167);\n        industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);\n      } else if (c.type && c.type.startsWith('park')) {\n        const size=(c.w||1)*(c.h||1);\n        const baseTourism=6; // Increased to balance expenses\n        const populationMultiplier=Math.min(3.0,1+(st.population/3000));\n        const happinessMultiplier=0.7+(st.happiness/143);\n        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);\n      }\n    }\n    const taxMultiplier=0.5+(st.taxRate/20);\n    const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);\n    \n    // Calculate maintenance (same logic as simTk) - UPDATED\n    let buildingMaintenance = 0, infrastructureCost = 0, serviceCosts = 0, crimeExpenses = 0, roadMaintenanceBonus = 0, powerPlantMaintenance = 0;\n    \n    // Base building maintenance\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='road') buildingMaintenance+=2;\n      else if (c.type==='residential' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n        buildingMaintenance+=Math.floor(5*levelMultiplier);\n      }\n      else if (c.type==='commercial' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));\n        buildingMaintenance+=Math.floor(8*levelMultiplier);\n      }\n      else if (c.type==='industrial' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));\n        buildingMaintenance+=Math.floor(12*levelMultiplier);\n      }\n      else if (c.type && c.type.startsWith('park')) buildingMaintenance+=4;\n      else if (c.type==='police') buildingMaintenance+=25;\n      else if (c.type==='fire') buildingMaintenance+=25;\n      else if (c.type==='school') buildingMaintenance+=40;\n      else if (c.type==='hospital') buildingMaintenance+=60;\n      else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {\n        const maint = POWER_PLANT_MAINTENANCE[c.type] || 0;\n        powerPlantMaintenance += maint;\n      }\n    }\n    \n    // Population-based costs\n    if (st.population > 0) {\n      infrastructureCost = Math.floor(st.population * 0.5);\n      \n      // Service operation costs\n      let avgCrime = 0;\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        avgCrime += st.crime[y][x] || 30;\n      }\n      avgCrime = avgCrime / (GR_SZ * GR_SZ);\n      const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100));\n      const fireOpCost = Math.floor(st.population * 0.2);\n      const educationCost = Math.floor(st.population * 0.4);\n      const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));\n      serviceCosts = policeOpCost + fireOpCost + educationCost + healthCost;\n      \n      // Crime expenses\n      if (avgCrime > 40) {\n        crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20);\n      }\n    }\n    \n    // Road maintenance bonus\n    const rdC = getCount('road');\n    roadMaintenanceBonus = Math.floor(rdC * 0.1);\n    \n    const totalMaintenance = buildingMaintenance + powerPlantMaintenance + infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;\n    const netIncome = totalIncome - totalMaintenance;\n    \n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('balance', `$${st.money.toLocaleString()}`)}${statItem('income/mo', netIncome>=0?`+$${netIncome.toLocaleString()}`:`-$${Math.abs(netIncome).toLocaleString()}`, netIncome>=0?'text-green-500':'text-red-400')}${statItem('expenses/mo', `-$${totalMaintenance.toLocaleString()}`, 'text-red-400')}</div>\n      <div class=\"mt-2 space-y-2\">\n        <div>\n          <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('Residential Tax', `$${Math.floor(residentialIncome*taxMultiplier).toLocaleString()}`, 'text-green-400')}\n            ${statItem('Commercial', `$${Math.floor(commercialRevenue*taxMultiplier).toLocaleString()}`, 'text-blue-400')}\n            ${statItem('Industrial', `$${Math.floor(industrialRevenue*taxMultiplier).toLocaleString()}`, 'text-yellow-400')}\n            ${statItem('Tourism', `$${Math.floor(tourismIncome*taxMultiplier).toLocaleString()}`, 'text-emerald-400')}\n          </div>\n        </div>\n        <div>\n          <div class=\"h-px w-full bg-neutral-700 mb-1\"></div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('Buildings', `-$${buildingMaintenance.toLocaleString()}`, 'text-red-400')}\n            ${powerPlantMaintenance > 0 ? statItem('Power', `-$${powerPlantMaintenance.toLocaleString()}`, 'text-red-400') : ''}\n            ${infrastructureCost > 0 ? statItem('Infrastructure', `-$${infrastructureCost.toLocaleString()}`, 'text-red-400') : ''}\n            ${serviceCosts > 0 ? statItem('Services', `-$${serviceCosts.toLocaleString()}`, 'text-red-400') : ''}\n            ${crimeExpenses > 0 ? statItem('Crime', `-$${crimeExpenses.toLocaleString()}`, 'text-red-400') : ''}\n            ${roadMaintenanceBonus > 0 ? statItem('Roads', `-$${roadMaintenanceBonus.toLocaleString()}`, 'text-red-400') : ''}\n          </div>\n        </div>\n        <div class=\"mt-2 pt-2 border-t border-neutral-700\">\n          <label class=\"text-xs text-neutral-400 block mb-2\" id=\"taxRateLabel\">Tax Rate: ${st.taxRate}%</label>\n          <input type=\"range\" id=\"taxRateSlider\" min=\"0\" max=\"20\" value=\"${st.taxRate}\" \n            class=\"w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-green-600\"\n            oninput=\"st.taxRate=parseInt(this.value); const lbl=document.getElementById('taxRateLabel'); if(lbl) lbl.textContent='Tax Rate: '+st.taxRate+'%'; updateStatsPanel(); sv();\">\n          <div class=\"text-xs text-neutral-500 mt-1\">Lower taxes boost happiness, higher taxes boost income</div>\n        </div>\n      </div>`;\n  } else if (infoType === 'happy') {\n    title = 'Happiness';\n    let avgCrime = 0;\n    for (let y = 0; y < GR_SZ; y++) {\n      for (let x = 0; x < GR_SZ; x++) {\n        avgCrime += st.crime[y][x] || 30;\n      }\n    }\n    avgCrime = Math.floor(avgCrime / (GR_SZ * GR_SZ));\n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('level', `${st.happiness}/100`)}${statItem('parks', cnts.park||0)}${statItem('services', (cnts.police||0)+(cnts.fire||0)+(cnts.school||0)+(cnts.hospital||0))}${statItem('crime', `${avgCrime}%`)}${statItem('crimes', st.crimeEvents.length)}</div><div class=\"mt-3 text-xs text-neutral-400\">Build parks, services, and police to increase</div>`;\n  }\n  \n  return { title, content };\n}\n\n['rciBtn','popBtn','moneyBtn','happyBtn'].forEach((btnId, idx) => {\n  const infoType = ['rci','pop','money','happy'][idx];\n  document.getElementById(btnId).addEventListener('click', () => {\n    const { title, content } = getStatsContent(infoType);\n    shwInfo(title, content, infoType);\n  });\n});\n\nfunction updateStatsPanel() {\n  if (!currentInfoType) return;\n  const pnl = document.getElementById('infoPanel');\n  if (!pnl || pnl.classList.contains('hidden')) return;\n  \n  const { title, content } = getStatsContent(currentInfoType);\n  \n  if (title && content) {\n    document.getElementById('infoTitle').innerHTML = title;\n    document.getElementById('infoContent').innerHTML = content;\n  }\n}\n\nfunction hasRdAcc(x,y) {\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const startX = bounds.startX ?? x;\n  const startY = bounds.startY ?? y;\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n\n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx = startX + dx, cy = startY + dy;\n      for (let ndy=-1; ndy<=1; ndy++) {\n        for (let ndx=-1; ndx<=1; ndx++) {\n          if (ndx===0 && ndy===0) continue;\n          const nx=cx+ndx, ny=cy+ndy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.grid[ny][nx].type==='road') return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction initPowerGrid() {\n  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) {\n    st.powerGrid = [];\n    for (let y=0; y<GR_SZ; y++) {\n      const row = [];\n      for (let x=0; x<GR_SZ; x++) row.push(false);\n      st.powerGrid.push(row);\n    }\n  } else {\n    for (let y=0; y<GR_SZ; y++) {\n      for (let x=0; x<GR_SZ; x++) st.powerGrid[y][x] = false;\n    }\n  }\n}\n\nfunction calculatePowerGrid() {\n  initPowerGrid();\n  \n  // Find all power plants\n  const powerPlants = [];\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (cell.type === 'coal' || cell.type === 'nuclear' || cell.type === 'wind') {\n        powerPlants.push({x, y});\n      }\n    }\n  }\n  \n  if (powerPlants.length === 0) {\n    allocatePowerToBuildings();\n    return;\n  }\n  \n  // BFS from each power plant along roads\n  const visited = new Set();\n  const queue = [];\n  \n  // Start BFS from each power plant's adjacent road tiles\n  for (const plant of powerPlants) {\n    // Check adjacent tiles for roads\n    for (let dy=-1; dy<=1; dy++) {\n      for (let dx=-1; dx<=1; dx++) {\n        if (dx===0 && dy===0) continue;\n        const nx = plant.x + dx, ny = plant.y + dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          if (st.grid[ny][nx].type === 'road') {\n            const key = `${nx},${ny}`;\n            if (!visited.has(key)) {\n              visited.add(key);\n              queue.push({x: nx, y: ny});\n              st.powerGrid[ny][nx] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // BFS along road network\n  while (queue.length > 0) {\n    const current = queue.shift();\n    \n    // Check all 4 directions (up, down, left, right)\n    const directions = [[0,-1], [0,1], [-1,0], [1,0]];\n    for (const [dx, dy] of directions) {\n      const nx = current.x + dx, ny = current.y + dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        const key = `${nx},${ny}`;\n        if (!visited.has(key) && st.grid[ny][nx].type === 'road') {\n          visited.add(key);\n          queue.push({x: nx, y: ny});\n          st.powerGrid[ny][nx] = true;\n        }\n      }\n    }\n  }\n  \n  // Mark all tiles adjacent to powered roads as powered\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      if (st.powerGrid[y][x]) {\n        // Check adjacent tiles (including diagonals)\n        for (let dy=-1; dy<=1; dy++) {\n          for (let dx=-1; dx<=1; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n              if (!st.powerGrid[ny][nx]) {\n                st.powerGrid[ny][nx] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  allocatePowerToBuildings();\n}\n\nfunction hasPowerAccess(x,y) {\n  // Check if building at (x,y) has power access\n  // Power flows via roads, so check if any adjacent tile is powered\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const startX = bounds.startX ?? x;\n  const startY = bounds.startY ?? y;\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n\n  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) return false;\n  \n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx=startX+dx, cy=startY+dy;\n      // Check adjacent tiles (including diagonals)\n      for (let ndy=-1; ndy<=1; ndy++) {\n        for (let ndx=-1; ndx<=1; ndx++) {\n          if (ndx===0 && ndy===0) continue;\n          const nx=cx+ndx, ny=cy+ndy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.powerGrid[ny][nx]) return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction buildingHasPower(x,y) {\n  if (!hasPowerAccess(x,y)) return false;\n  const key = getBuildingPowerKey(x,y);\n  if (!key) return false;\n  if (!st.powerShortageBuildings || typeof st.powerShortageBuildings !== 'object') return true;\n  return !st.powerShortageBuildings[key];\n}\n\n// ===== Water System =====\nfunction getWaterConsumption(buildingType, level) {\n  if (buildingType === 'residential') {\n    if (level === 1) return 3;\n    if (level === 2) return 6;\n    if (level === 3) return 10;\n    return 0; // L0 residential doesn't need water\n  } else if (buildingType === 'commercial') {\n    if (level === 1) return 8;\n    if (level === 2) return 15;\n    if (level === 3) return 25;\n    return 0;\n  } else if (buildingType === 'industrial') {\n    if (level === 1) return 12;\n    if (level === 2) return 25;\n    if (level === 3) return 40;\n    return 0;\n  }\n  return 0;\n}\n\nfunction getBuildingWaterKey(x, y) {\n  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;\n  const cell = st.grid[y][x];\n  if (!cell || !cell.type || cell.type === 'empty') return null;\n  if (cell.buildingId != null) return `b:${cell.buildingId}`;\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n  return `b:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;\n}\n\nfunction getWaterPlantKey(x, y) {\n  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;\n  const cell = st.grid[y][x];\n  if (!cell || !cell.type) return null;\n  if (cell.buildingId != null) return `p:${cell.buildingId}`;\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n  return `p:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;\n}\n\nfunction getWaterSystemSnapshot() {\n  const processedWaterPlants = new Set();\n  const processedBuildings = new Set();\n  const consumers = [];\n  let totalWaterGeneration = 0;\n  let totalWaterConsumption = 0;\n  let waterplantGen = 0, watertowerGen = 0;\n  let waterplantCount = 0, watertowerCount = 0;\n  let residentialConsumption = 0, commercialConsumption = 0, industrialConsumption = 0;\n  \n  for (let y = 0; y < GR_SZ; y++) {\n    for (let x = 0; x < GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (!cell) continue;\n      \n      if (cell.type === 'waterplant' || cell.type === 'watertower') {\n        const plantKey = getWaterPlantKey(x,y);\n        if (plantKey && !processedWaterPlants.has(plantKey)) {\n          processedWaterPlants.add(plantKey);\n          const gen = WATER_GENERATION[cell.type] || 0;\n          totalWaterGeneration += gen;\n          if (cell.type === 'waterplant') { waterplantGen += gen; waterplantCount++; }\n          else if (cell.type === 'watertower') { watertowerGen += gen; watertowerCount++; }\n        }\n      }\n      \n      if (cell.type === 'residential' || cell.type === 'commercial' || cell.type === 'industrial') {\n        if (cell.abandoned) continue;\n        const buildingKey = getBuildingWaterKey(x,y);\n        if (!buildingKey || processedBuildings.has(buildingKey)) continue;\n        processedBuildings.add(buildingKey);\n        \n        const level = cell.level || 0;\n        const perTileConsumption = getWaterConsumption(cell.type, level);\n        if (perTileConsumption <= 0) continue;\n        const bounds = getBuildingBoundsFromCell(x,y);\n        const area = Math.max(1,(bounds.w||1)*(bounds.h||1));\n        const consumption = perTileConsumption * area;\n        totalWaterConsumption += consumption;\n        if (cell.type === 'residential') residentialConsumption += consumption;\n        else if (cell.type === 'commercial') commercialConsumption += consumption;\n        else industrialConsumption += consumption;\n        \n        const hasConnection = hasWaterAccess(x,y);\n        consumers.push({\n          key: buildingKey,\n          type: cell.type,\n          level,\n          consumption,\n          hasConnection,\n          x: bounds.startX,\n          y: bounds.startY\n        });\n      }\n    }\n  }\n  \n  return {\n    totalWaterGeneration,\n    totalWaterConsumption,\n    waterplantGen,\n    watertowerGen,\n    waterplantCount,\n    watertowerCount,\n    residentialConsumption,\n    commercialConsumption,\n    industrialConsumption,\n    consumers\n  };\n}\n\nfunction allocateWaterToBuildings() {\n  if (!st.waterShortageBuildings || typeof st.waterShortageBuildings !== 'object') {\n    st.waterShortageBuildings = {};\n  }\n  const snapshot = getWaterSystemSnapshot();\n  const shortageMap = {};\n  const connectedBuildings = [];\n  \n  for (const consumer of snapshot.consumers) {\n    if (!consumer.hasConnection) {\n      shortageMap[consumer.key] = true;\n    } else if (consumer.consumption > 0) {\n      connectedBuildings.push(consumer);\n    }\n  }\n  \n  const typePriority = {residential:0, commercial:1, industrial:2};\n  connectedBuildings.sort((a,b) => {\n    const typeDiff = (typePriority[a.type] ?? 99) - (typePriority[b.type] ?? 99);\n    if (typeDiff !== 0) return typeDiff;\n    if (b.level !== a.level) return b.level - a.level;\n    if (a.consumption !== b.consumption) return a.consumption - b.consumption;\n    return a.key.localeCompare(b.key);\n  });\n  \n  let remainingWater = snapshot.totalWaterGeneration;\n  for (const building of connectedBuildings) {\n    if (remainingWater >= building.consumption) {\n      remainingWater -= building.consumption;\n    } else {\n      shortageMap[building.key] = true;\n    }\n  }\n  \n  st.waterShortageBuildings = shortageMap;\n}\n\n// Calculate water generation and consumption statistics\nfunction calculateWaterStats(includeDetails = false) {\n  const snapshot = getWaterSystemSnapshot();\n  const result = {\n    totalWaterGeneration: snapshot.totalWaterGeneration,\n    totalWaterConsumption: snapshot.totalWaterConsumption,\n    waterSurplus: snapshot.totalWaterGeneration - snapshot.totalWaterConsumption\n  };\n  \n  if (includeDetails) {\n    result.waterplantGen = snapshot.waterplantGen;\n    result.watertowerGen = snapshot.watertowerGen;\n    result.waterplantCount = snapshot.waterplantCount;\n    result.watertowerCount = snapshot.watertowerCount;\n    result.residentialConsumption = snapshot.residentialConsumption;\n    result.commercialConsumption = snapshot.commercialConsumption;\n    result.industrialConsumption = snapshot.industrialConsumption;\n  }\n  \n  return result;\n}\n\nfunction initWaterGrid() {\n  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) {\n    st.waterGrid = [];\n    for (let y=0; y<GR_SZ; y++) {\n      st.waterGrid.push([]);\n      for (let x=0; x<GR_SZ; x++) st.waterGrid[y][x] = false;\n    }\n  }\n}\n\nfunction calculateWaterGrid() {\n  // Always reset the entire grid to false before recalculating\n  st.waterGrid = [];\n  for (let y=0; y<GR_SZ; y++) {\n    st.waterGrid.push([]);\n    for (let x=0; x<GR_SZ; x++) st.waterGrid[y][x] = false;\n  }\n  \n  // Find all water plants and all pipes\n  const waterPlants = [];\n  const allPipes = [];\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (cell.type === 'waterplant' || cell.type === 'watertower') {\n        waterPlants.push({x, y});\n      }\n      if (cell.pipe === true) {\n        allPipes.push({x, y});\n      }\n    }\n  }\n  \n  // If no water plants, no coverage at all\n  if (waterPlants.length === 0) {\n    allocateWaterToBuildings();\n    return;\n  }\n  \n  // BFS from each water plant along pipes to mark all connected pipes\n  const pipeNetwork = new Set(); // Track only pipes that are connected to water plants\n  const visited = new Set();\n  const queue = [];\n  \n  // Start BFS from each water plant's adjacent pipe tiles (4 cardinal directions only)\n  for (const plant of waterPlants) {\n    // Check adjacent tiles for pipes (only 4 cardinal directions for connection)\n    const directions = [[0,-1], [0,1], [-1,0], [1,0]];\n    for (const [dx, dy] of directions) {\n      const nx = plant.x + dx, ny = plant.y + dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        if (st.grid[ny][nx].pipe === true) {\n          const key = `${nx},${ny}`;\n          if (!visited.has(key)) {\n            visited.add(key);\n            queue.push({x: nx, y: ny});\n            pipeNetwork.add(key);\n          }\n        }\n      }\n    }\n  }\n  \n  // BFS along pipe network - only mark the pipes themselves\n  while (queue.length > 0) {\n    const current = queue.shift();\n    \n    // Check all 4 cardinal directions (up, down, left, right)\n    const directions = [[0,-1], [0,1], [-1,0], [1,0]];\n    for (const [dx, dy] of directions) {\n      const nx = current.x + dx, ny = current.y + dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        const key = `${nx},${ny}`;\n        if (!visited.has(key) && st.grid[ny][nx].pipe === true) {\n          visited.add(key);\n          queue.push({x: nx, y: ny});\n          pipeNetwork.add(key);\n        }\n      }\n    }\n  }\n  \n  // IMPORTANT: Only mark coverage for pipes that are connected to water plants\n  // Water plants themselves do NOT provide coverage - they need pipes!\n  for (const pipeKey of pipeNetwork) {\n    const [pipeX, pipeY] = pipeKey.split(',').map(Number);\n    st.waterGrid[pipeY][pipeX] = true; // The pipe itself has water\n    \n    // Mark adjacent tiles (including diagonals) around connected pipes - 2x range\n    for (let dy=-2; dy<=2; dy++) {\n      for (let dx=-2; dx<=2; dx++) {\n        const nx = pipeX + dx, ny = pipeY + dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          st.waterGrid[ny][nx] = true;\n        }\n      }\n    }\n  }\n  \n  allocateWaterToBuildings();\n}\n\nfunction isNearWaterTile(x, y, maxDistance = 2) {\n  // Check if location (x,y) is within maxDistance tiles of a water terrain tile\n  for (let dy = -maxDistance; dy <= maxDistance; dy++) {\n    for (let dx = -maxDistance; dx <= maxDistance; dx++) {\n      const nx = x + dx, ny = y + dy;\n      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {\n        const distance = Math.abs(dx) + Math.abs(dy); // Manhattan distance\n        if (distance <= maxDistance && st.terrain[ny][nx] === 'water') {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction hasWaterAccess(x,y) {\n  // Check if building at (x,y) has water access\n  // Water flows via pipes, so check if building's own tiles or adjacent tiles have water\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const startX = bounds.startX ?? x;\n  const startY = bounds.startY ?? y;\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n\n  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) return false;\n  \n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx=startX+dx, cy=startY+dy;\n      \n      // First check if the building's own tile has water coverage (pipe on building)\n      if (st.waterGrid[cy][cx]) return true;\n      \n      // Then check adjacent tiles (including diagonals)\n      for (let ndy=-1; ndy<=1; ndy++) {\n        for (let ndx=-1; ndx<=1; ndx++) {\n          if (ndx===0 && ndy===0) continue;\n          const nx=cx+ndx, ny=cy+ndy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.waterGrid[ny][nx]) return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction buildingHasWater(x,y) {\n  if (!hasWaterAccess(x,y)) return false;\n  const key = getBuildingWaterKey(x,y);\n  if (!key) return false;\n  if (!st.waterShortageBuildings || typeof st.waterShortageBuildings !== 'object') return true;\n  return !st.waterShortageBuildings[key];\n}\n\nfunction hasSchoolCoverage(x,y) {\n  // Check if building at (x,y) is within a school's bounds (8-tile radius)\n  const bounds = getBuildingBoundsFromCell(x,y);\n  const startX = bounds.startX ?? x;\n  const startY = bounds.startY ?? y;\n  const w = bounds.w || 1;\n  const h = bounds.h || 1;\n\n  // Check each cell of the building\n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx=startX+dx, cy=startY+dy;\n      // Check for schools within 8-tile radius\n      for (let sdy=-8; sdy<=8; sdy++) {\n        for (let sdx=-8; sdx<=8; sdx++) {\n          const nx=cx+sdx, ny=cy+sdy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            const d=Math.abs(sdx)+Math.abs(sdy);\n            if (d<=8 && st.grid[ny][nx].type==='school') {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// ===== Game Logic =====\nfunction calcLV(x,y) {\n  let v=50; const tr=st.terrain[y][x];\n  if (tr==='water') for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) { const d=Math.abs(dx)+Math.abs(dy); if (d<=2) v+=(3-d)*5; }\n  }\n  let pk=0, pl=0, sv=0;\n  for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), c=st.grid[ny][nx];\n      if (c.type.startsWith('park')) { const m=(c.w||1)*(c.h||1); const sizeBoost=m>1?1.5:1; pk+=(7-d)*2*m*sizeBoost; }\n      else if (c.type==='industrial') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*2*m; }\n      else if (c.type==='coal') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*3*m; } // Coal plants pollute more than industrial\n      else if (c.type==='police'||c.type==='fire'||c.type==='school'||c.type==='hospital') sv+=(7-d);\n    }\n  }\n  v+=Math.min(pk,30); v-=Math.min(pl,40); v+=Math.min(sv,20);\n  if (!hasRdAcc(x,y)) v-=30;\n  return Math.max(0,Math.min(100,v));\n}\n\nfunction calcCrime(x,y) {\n  let c=30; const tr=st.terrain[y][x];\n  if (tr==='water'||tr==='cliff') return 0;\n  \n  // Reduce crime near police stations (8-tile radius)\n  let policeCoverage=0;\n  for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), cell=st.grid[ny][nx];\n      if (cell.type==='police' && d<=8) {\n        policeCoverage+=(9-d)*3;\n      }\n    }\n  }\n  c-=Math.min(policeCoverage,50);\n  \n  // Increase crime in high-population areas without police coverage\n  const cell=st.grid[y][x];\n  if ((cell.type==='residential'||cell.type==='commercial') && !cell.abandoned) {\n    const popDensity=(cell.w||1)*(cell.h||1)*(cell.level||0);\n    if (policeCoverage<10) c+=popDensity*5;\n  }\n  \n  // Factor in happiness (low happiness = more crime)\n  if (st.happiness<50) c+=20;\n  else if (st.happiness<70) c+=10;\n  \n  // Increase crime if no road access\n  if (!hasRdAcc(x,y)) c+=15;\n  \n  // Check for active crime events nearby\n  for (const evt of st.crimeEvents) {\n    const dx=Math.abs(x-evt.x), dy=Math.abs(y-evt.y), d=dx+dy;\n    if (d<=3) c+=Math.max(0,(4-d)*10);\n  }\n  \n  return Math.max(0,Math.min(100,c));\n}\n\nfunction updLV() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.landValue[y][x]=calcLV(x,y); }\nfunction updCrime() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.crime[y][x]=calcCrime(x,y); }\n\nfunction calcDmd(rC,cC,iC,p) {\n  let rD=50, cD=50, iD=50; const tZ=rC+cC+iC;\n  if (tZ===0) { rD=80; cD=40; iD=40; }\n  else {\n    const iR={r:0.5,c:0.25,i:0.25}, aR={r:rC/tZ,c:cC/tZ,i:iC/tZ};\n    rD=Math.max(0,Math.min(100,50+(iR.r-aR.r)*200)); cD=Math.max(0,Math.min(100,50+(iR.c-aR.c)*200)); iD=Math.max(0,Math.min(100,50+(iR.i-aR.i)*200));\n    if (p>0) { const jA=cC*5+iC*8, jN=p*0.6; if (jA<jN) { cD=Math.min(100,cD+20); iD=Math.min(100,iD+20); } }\n    if (st.happiness<50) rD=Math.max(0,rD-20); else if (st.happiness>80) rD=Math.min(100,rD+10);\n  }\n  return {rDemand:rD,cDemand:cD,iDemand:iD};\n}\n\nfunction cleanupNewsEvents() {\n  // Remove all event messages (fire, robbery, earthquake, etc.) - they have emojis\n  st.newsEvents = st.newsEvents.filter(ev => !ev.includes('üî•') && !ev.includes('üö®') && !ev.includes('üåé'));\n  \n  // Keep only the 5 most recent news items\n  if (st.newsEvents.length > 5) {\n    st.newsEvents = st.newsEvents.slice(-5);\n  }\n}\n\n  function parseNewsEffectValue(chunk) {\n    if (!chunk) return 0;\n    const normalized = chunk.replace(/,/g, '').trim();\n    const match = normalized.match(/([+-])?\\s*\\$?\\s*(\\d+(?:\\.\\d+)?)/);\n    if (!match) return 0;\n    const sign = match[1] === '-' ? -1 : 1;\n    let value = parseFloat(match[2]);\n    if (!Number.isFinite(value)) return 0;\n    if (/[kK]/.test(normalized)) value *= 1000;\n    else if (/[mM]/.test(normalized)) value *= 1000000;\n    return Math.round(value * sign);\n  }\n\n  function applyNewsEffectFromChunk(chunk) {\n    if (!chunk) return;\n    const delta = parseNewsEffectValue(chunk);\n    if (delta === 0) return;\n    const lower = chunk.toLowerCase();\n    if (lower.includes('pop')) {\n      if (!Number.isFinite(st.populationNewsBonus)) st.populationNewsBonus = 0;\n      st.populationNewsBonus += delta;\n      st.population = Math.max(0, st.population + delta);\n    } else if (lower.includes('joy') || lower.includes('happiness')) {\n      st.happiness = Math.max(0, Math.min(100, st.happiness + delta));\n    } else {\n      const moneyKeywords = ['money','funds','budget','cash','treasury'];\n      const hasMoneyKeyword = chunk.includes('$') || moneyKeywords.some(k => lower.includes(k));\n      if (hasMoneyKeyword) {\n        st.money = Math.max(0, st.money + delta);\n      }\n    }\n  }\n\nasync function genNws() {\n  // If we have pending news, consume it instead of asking AI\n  if (st.pendingNews && st.pendingNews.length > 0) {\n    const ev = st.pendingNews.shift();\n    const m=ev.match(/\\(([^)]+)\\)/);\n    if (m) applyNewsEffectFromChunk(m[1]);\n    st.newsEvents.push(ev);\n    nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();\n    return;\n  }\n\n  if (aiReq) return; aiReq=true;\n    cleanupNewsEvents(); // Clean old events before generating new one\n    const cnts=getBuildingCounts();\n  const ctx=`${st.cityName}, ${st.year}, pop ${st.population}, $${(st.money/1000).toFixed(0)}k, happiness ${st.happiness}, ${cnts.residential||0}R ${cnts.commercial||0}C ${cnts.industrial||0}I`;\n  const prm=`Generate 3 quirky news headlines (8 words max each) for SimCity game. Context: ${ctx}. Topics: era-specific events (${st.year}s culture/tech), citizen stories, weird happenings, local color, achievements, community events. NO fires, earthquakes, crimes, or disasters. Include brief stat at end like (+200 pop) or (-$2k) or (+5 joy). Be creative and fun. Return ONLY the headlines separated by \"|||\".`;\n    try {\n      const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n      if (!r.ok) throw new Error('AI request failed');\n      const d=await r.json(); \n      let reply=d.reply||'City continues to grow';\n      reply=reply.replace(/^[\"']|[\"']$/g,'').trim();\n      \n      const headlines = reply.split('|||').map(h => h.trim()).filter(h => h.length > 0);\n      \n      if (headlines.length > 0) {\n        if (!st.pendingNews) st.pendingNews = [];\n        st.pendingNews.push(...headlines);\n        \n        // Display the first one immediately\n        const ev = st.pendingNews.shift();\n        const m=ev.match(/\\(([^)]+)\\)/);\n        if (m) applyNewsEffectFromChunk(m[1]);\n        st.newsEvents.push(ev);\n        nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();\n      }\n    } catch(e) { console.error('News generation error:',e); } finally { aiReq=false; }\n}\n\nfunction tryMrgPark(x,y) {\n  const c=st.grid[y][x]; if (!c||!c.type.startsWith('park')) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  \n  // Try to merge 2x1 tiles into 2x2\n  if (c.w===2&&c.h===1) {\n    // Check if there's a 2x1 tile directly above or below\n    const checkAbove=y>0 && x+1<GR_SZ;\n    const checkBelow=y+1<GR_SZ && x+1<GR_SZ;\n    \n    if (checkAbove) {\n      const above=st.grid[y-1][x];\n      if (above.type===c.type&&above.w===2&&above.h===1 && y-1>=0 && x+1<GR_SZ && st.grid[y-1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y-1>=0 && y<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y-1+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkBelow) {\n      const below=st.grid[y+1][x];\n      if (below.type===c.type&&below.w===2&&below.h===1 && y+1<GR_SZ && x+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Try to merge 1x2 tiles into 2x2\n  if (c.w===1&&c.h===2) {\n    // Check if there's a 1x2 tile directly left or right\n    const checkLeft=x>0 && y+1<GR_SZ;\n    const checkRight=x+1<GR_SZ && y+1<GR_SZ;\n    \n    if (checkLeft) {\n      const left=st.grid[y][x-1];\n      if (left.type===c.type&&left.w===1&&left.h===2 && x-1>=0 && y+1<GR_SZ && st.grid[y+1][x-1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x-1>=0 && x<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x-1+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkRight) {\n      const right=st.grid[y][x+1];\n      if (right.type===c.type&&right.w===1&&right.h===2 && x+1<GR_SZ && y+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Original logic: merge 1x1 tiles\n  if (c.w!==1||c.h!==1) return false;\n  \n  // Try to merge with adjacent parks of the same type\n  const dirs=[{dx:0,dy:0,w:2,h:2},{dx:-1,dy:0,w:2,h:1},{dx:0,dy:-1,w:1,h:2},{dx:-1,dy:-1,w:2,h:2},{dx:0,dy:0,w:2,h:1},{dx:0,dy:0,w:1,h:2}];\n  for (const d of dirs) {\n    const sx=x+d.dx, sy=y+d.dy;\n    if (sx<0||sy<0||sx+d.w>GR_SZ||sy+d.h>GR_SZ) continue;\n    \n    // Check if all cells in the area are the same park type and 1x1\n    let canMerge=true;\n    for (let dy=0; dy<d.h; dy++) for (let dx=0; dx<d.w; dx++) {\n      const nx=sx+dx, ny=sy+dy, nb=st.grid[ny][nx];\n      if (nb.type!==c.type||nb.w!==1||nb.h!==1) { canMerge=false; break; }\n    }\n    \n    if (canMerge) {\n      // Merge the parks - ensure all cells are within bounds\n      const buildingId = nextBuildingId++;\n      for (let dy=0; dy<d.h; dy++) {\n        for (let dx=0; dx<d.w; dx++) {\n          const nx=sx+dx, ny=sy+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            const hadPipe = st.grid[ny][nx].pipe;\n            st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:d.w,h:d.h,buildingId:buildingId};\n            if (hadPipe) st.grid[ny][nx].pipe = true;\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n// First step: merge 1x1 buildings to 2x1 or 1x2\nfunction tryMrgTo2x1(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge mature 1x1 buildings\n  const w=c.w||1, h=c.h||1;\n  if (w!==1 || h!==1) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const targets=[\n    {dx:1, dy:0, w:2, h:1}, // Merge to the right (2x1)\n    {dx:0, dy:1, w:1, h:2}  // Merge downward (1x2)\n  ];\n  \n  for (const target of targets) {\n    const adjX=x+target.dx, adjY=y+target.dy;\n    if (adjX<0||adjX>=GR_SZ||adjY<0||adjY>=GR_SZ) continue;\n    const adj=st.grid[adjY][adjX];\n    if (!adj) continue;\n    if (adj.type!==c.type) continue;\n    if ((adj.w||1)!==1 || (adj.h||1)!==1) continue;\n    \n    const adjLevel=adj.level||0;\n    if (adjLevel<=0 && !adj.abandoned) continue; // keep level-0 zones 1x1\n    \n    const topLeftX=Math.min(x,adjX);\n    const topLeftY=Math.min(y,adjY);\n    const bestAge=Math.max(c.age||0,adj.age||0);\n    const bestLevel=Math.max(1,Math.min(c.level||1,adj.level||c.level||1));\n    const isAbandoned=c.abandoned && adj.abandoned;\n    \n    const buildingId = nextBuildingId++;\n    for (let dy=0; dy<target.h; dy++) {\n      for (let dx=0; dx<target.w; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          const hadPipe = st.grid[ny][nx].pipe;\n          st.grid[ny][nx]={type:c.type,age:bestAge,level:bestLevel,w:target.w,h:target.h,abandoned:isAbandoned,buildingId:buildingId};\n          if (hadPipe) st.grid[ny][nx].pipe = true;\n        }\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction tryMrg(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge buildings that are 1x2 or 2x1 (not 1x1 - those merge first)\n  const w=c.w||1, h=c.h||1;\n  if (!((w===1&&h===2) || (w===2&&h===1))) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const baseLevel=Math.max(1,c.level||1);\n  const baseAge=c.age||0;\n  const expansions=[];\n  \n  if (w===2 && h===1) {\n    if (y>0) expansions.push({topLeftX:x, topLeftY:y-1, fillCells:[{x:x,y:y-1},{x:x+1,y:y-1}]});\n    if (y+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x,y:y+1},{x:x+1,y:y+1}]});\n  } else if (w===1 && h===2) {\n    if (x>0) expansions.push({topLeftX:x-1, topLeftY:y, fillCells:[{x:x-1,y:y},{x:x-1,y:y+1}]});\n    if (x+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x+1,y:y},{x:x+1,y:y+1}]});\n  }\n  \n  for (const option of expansions) {\n    const {topLeftX, topLeftY, fillCells}=option;\n    if (topLeftX<0 || topLeftY<0 || topLeftX+1>=GR_SZ || topLeftY+1>=GR_SZ) continue;\n    \n    let canExpand=true;\n    let mergedAge=baseAge;\n    for (const pos of fillCells) {\n      if (pos.x<0 || pos.x>=GR_SZ || pos.y<0 || pos.y>=GR_SZ) { canExpand=false; break; }\n      const target=st.grid[pos.y][pos.x];\n      if (!target) { canExpand=false; break; }\n      if (target.type!==c.type) { canExpand=false; break; }\n      if ((target.w||1)!==1 || (target.h||1)!==1) { canExpand=false; break; }\n      const targetLevel=target.level||0;\n      if (targetLevel>0 && !target.abandoned) { canExpand=false; break; }\n      mergedAge=Math.max(mergedAge,target.age||0);\n    }\n    \n    if (!canExpand) continue;\n    \n    const buildingId = nextBuildingId++;\n    for (let dy=0; dy<2; dy++) {\n      for (let dx=0; dx<2; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        const hadPipe = st.grid[ny][nx].pipe;\n        st.grid[ny][nx]={type:c.type,age:mergedAge,level:baseLevel,w:2,h:2,abandoned:false,buildingId:buildingId};\n        if (hadPipe) st.grid[ny][nx].pipe = true;\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction updFires() {\n  st.fires=st.fires.filter(f => {\n    f.age++;\n    \n    // Count fire trucks at scene (from vehicles that have arrived and are within coverage range)\n    const trucksAtScene = st.cars.filter(c => \n      c.mission && \n      c.mission.type === 'fire' && \n      c.mission.arrived && \n      isWithinCoverageRange(c.mission.targetX, c.mission.targetY, f.x, f.y)\n    ).length;\n    \n    // Fires REQUIRE fire trucks to be extinguished - they won't go out on their own\n    // With trucks: extinguish faster (10 ticks per truck, min 5 ticks)\n    // Without trucks: fire continues indefinitely (but building will eventually be destroyed)\n    if (trucksAtScene === 0) {\n      // No fire trucks - fire continues burning\n      // After 60 ticks without trucks, building is destroyed anyway\n      if (f.age > 60) {\n        sendEmergencyVehiclesHome('fire', f.x, f.y);\n        \n        const cell=st.grid[f.y][f.x];\n        if (cell && cell.type!=='empty') {\n          const bounds=getBuildingBoundsFromCell(f.x,f.y);\n          const w=bounds.w||1, h=bounds.h||1;\n          for (let dy=0; dy<h; dy++) {\n            for (let dx=0; dx<w; dx++) {\n              const nx=bounds.startX+dx, ny=bounds.startY+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n                normalizeEmptyCell(nx,ny);\n              }\n            }\n          }\n        }\n        return false; // Remove fire after building destroyed\n      }\n      return true; // Keep fire burning\n    }\n    \n    // Fire trucks are at scene - extinguish fire\n    // More trucks = faster extinguishing (15 ticks with 1 truck, down to 5 ticks with 3+ trucks)\n    const maxAge = trucksAtScene >= 1 ? Math.max(5, 15 - (trucksAtScene - 1) * 5) : 60;\n    \n    if (f.age>maxAge) { \n      sendEmergencyVehiclesHome('fire', f.x, f.y);\n      \n      // If fire trucks arrived (trucksAtScene > 0), save the building\n      if (trucksAtScene > 0) {\n        // Fire extinguished successfully - building saved!\n        return false; // Remove fire\n      } else {\n        // No fire trucks - building destroyed\n        const cell=st.grid[f.y][f.x];\n        if (cell && cell.type!=='empty') {\n          const bounds=getBuildingBoundsFromCell(f.x,f.y);\n          const w=bounds.w||1, h=bounds.h||1;\n          for (let dy=0; dy<h; dy++) {\n            for (let dx=0; dx<w; dx++) {\n              const nx=bounds.startX+dx, ny=bounds.startY+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                const hadPipe = st.grid[ny][nx].pipe;\n                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                if (hadPipe) st.grid[ny][nx].pipe = true;\n                normalizeEmptyCell(nx,ny);\n              }\n            }\n          }\n        }\n        return false; \n      }\n    }\n    const c=st.grid[f.y][f.x]; if (c.type==='empty') return false;\n    let hasFr=false; for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n      const nx=f.x+dx, ny=f.y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='fire') hasFr=true;\n    }\n    // With fire trucks, fires can be extinguished earlier\n    const minAgeForSpread = trucksAtScene > 0 ? 5 : 10;\n    if (hasFr && f.age>minAgeForSpread) return false; return true;\n  });\n}\n\nfunction startFire() {\n  const blds=[]; for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x]; if ((c.type==='residential'||c.type==='commercial'||c.type==='industrial') && !c.abandoned) blds.push({x,y});\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)]; \n    st.fires.push({x:b.x,y:b.y,age:0,fireTrucksAtScene:0});\n    plySnd('fire');\n    \n    // Dispatch fire truck from nearest fire station\n    const dispatched = dispatchEmergencyVehicle('fire', b.x, b.y, 'fire');\n    const cost = 5000;\n    st.newsEvents.push(`üî• Fire! (-$${fmtCompact(cost)})`);\n    st.money-=cost;\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\n\nfunction startQuake() {\n  plySnd('earthquake');\n  const gr=document.getElementById('grid'); gr.classList.add('earthquake');\n  setTimeout(() => gr.classList.remove('earthquake'),1500);\n  const blds=[]; \n  const processedBuildings=new Set(); // Track buildings we've already added\n  \n  // Collect buildings, but only add the top-left cell of each building\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x]; \n      if (c.type==='empty' || c.type==='road') continue;\n      \n      // Skip level 0 RCI zones (empty zones), but allow abandoned buildings\n      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n      if (isZone && (c.level||0)===0 && !c.abandoned) continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only add the top-left cell of each building to avoid duplicates\n      // Check if this is the top-left cell\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (isTopLeft) {\n        // Ensure this building's footprint does not include any roads (which can happen\n        // with older saves or after complex merges next to roads)\n        let hasRoadInFootprint=false;\n        for (let dy=0; dy<h && !hasRoadInFootprint; dy++) {\n          for (let dx=0; dx<w; dx++) {\n            const nx=x+dx, ny=y+dy;\n            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n              if (st.grid[ny][nx].type==='road') {\n                hasRoadInFootprint=true;\n                break;\n              }\n            }\n          }\n        }\n        if (hasRoadInFootprint) continue;\n\n        const buildingKey=`${x},${y},${c.type},${w},${h}`;\n        if (!processedBuildings.has(buildingKey)) {\n          processedBuildings.add(buildingKey);\n          blds.push({x,y,w,h});\n        }\n      }\n    }\n  }\n  \n  const dmg=Math.min(5,Math.floor(blds.length*0.1));\n  for (let i=0; i<dmg; i++) {\n    if (blds.length>0) {\n      const b=blds.splice(Math.floor(Math.random()*blds.length),1)[0];\n      // Destroy all cells that are part of this building using robust bounds\n      const bounds=getBuildingBoundsFromCell(b.x,b.y);\n      const w=bounds.w||1, h=bounds.h||1;\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=bounds.startX+dx, ny=bounds.startY+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            // Only destroy if it's not a road\n            if (st.grid[ny][nx].type!=='road') {\n              const hadPipe = st.grid[ny][nx].pipe;\n              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n              if (hadPipe) st.grid[ny][nx].pipe = true;\n              normalizeEmptyCell(nx,ny); // Ensure it's 1x1\n            }\n          }\n        }\n      }\n    }\n  }\n  const cost = 10000;\n  st.newsEvents.push(`üåé Earthquake! ${dmg} buildings damaged (-$${fmtCompact(cost)})`);\n  st.money-=cost;\n  nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n}\n\nfunction updCrimeEvents() {\n  st.crimeEvents=st.crimeEvents.filter(evt => {\n    evt.age++;\n    \n    // Count police cars at scene (from vehicles that have arrived and are within coverage range)\n    const policeAtScene = st.cars.filter(c => \n      c.mission && \n      c.mission.type === 'crime' && \n      c.mission.arrived && \n      isWithinCoverageRange(c.mission.targetX, c.mission.targetY, evt.x, evt.y)\n    ).length;\n    \n    // Crimes REQUIRE police cars to resolve - they won't resolve on their own\n    // Without police cars: crime continues indefinitely (causing ongoing costs)\n    if (policeAtScene === 0) {\n      // No police cars - crime continues\n      // After 100 ticks without police, crime eventually stops (but damage is done)\n      if (evt.age > 100) {\n        // Crime resolved after long time without police (but should have been handled)\n        return false;\n      }\n      // Continue costing money while crime is active\n      if (evt.age % 10 === 0) {\n        st.money -= 500; // Ongoing cost every 10 ticks\n      }\n      return true; // Keep crime active\n    }\n    \n    // Police cars are at scene - resolve crime quickly\n    // Resolve faster with more cars: 5 ticks per car (min 2 ticks)\n    const maxAge = Math.max(2, 20 - policeAtScene * 5);\n    \n    if (evt.age>maxAge) {\n      sendEmergencyVehiclesHome('crime', evt.x, evt.y);\n      return false;\n    }\n    return true;\n  });\n}\n\nfunction startCrimeEvent() {\n  const blds=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    // Higher crime areas are more likely to have crime events\n    const crimeLevel=st.crime[y][x]||30;\n    if ((c.type==='residential'||c.type==='commercial') && !c.abandoned && crimeLevel>40) {\n      // Weight by crime level - higher crime = more likely\n      for (let i=0; i<Math.floor(crimeLevel/20); i++) blds.push({x,y,crimeLevel});\n    }\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)];\n    const crimeTypes=['robbery','break-in','vandalism'];\n    const crimeType=crimeTypes[Math.floor(Math.random()*crimeTypes.length)];\n    st.crimeEvents.push({x:b.x,y:b.y,type:crimeType,age:0,policeCarsAtScene:0});\n    plySnd('crime');\n    \n    // Dispatch police car from nearest police station\n    const dispatched = dispatchEmergencyVehicle('police', b.x, b.y, 'crime');\n    const cost=Math.floor(Math.random()*3000)+2000;\n    st.money-=cost;\n    const msg=crimeType==='robbery'?`üö® Robbery! (-$${fmtCompact(cost)})`:\n           crimeType==='break-in'?`üö® Break-in! (-$${fmtCompact(cost)})`:\n           `üö® Vandalism! (-$${fmtCompact(cost)})`;\n    st.newsEvents.push(msg);\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\n\nfunction simTk() {\n  st.tickCount++; st.ticksSinceNews++;\n  if (st.tickCount%12===0) {\n    st.year++;\n    // Clean up old event messages and AI news every year\n    cleanupNewsEvents();\n  }\n  // Recalculate power grid each tick\n  calculatePowerGrid();\n  calculateWaterGrid();\n  let rC=0, cC=0, iC=0, pC=0, poC=0, fC=0, sC=0, hC=0, rdC=0; const cntd={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (cntd[k]) continue;\n    const c=st.grid[y][x]; \n    // Normalize empty cells to ensure they're always 1x1\n    if (c.type==='empty') normalizeEmptyCell(x,y);\n    if (c.type!=='empty') {\n      const w=c.w||1, h=c.h||1;\n      // Only increment age once per building (only for the top-left cell being processed)\n      c.age++;\n      // For multi-tile buildings, sync age to all cells\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=x+dx, ny=y+dy;\n          if (nx<GR_SZ && ny<GR_SZ) {\n            st.grid[ny][nx].age = c.age; // Sync age across all cells\n          }\n          cntd[`${nx},${ny}`]=true;\n        }\n      }\n    }\n    if (c.type==='residential') rC++; else if (c.type==='commercial') cC++; else if (c.type==='industrial') iC++;\n    else if (c.type.startsWith('park')) pC++;     else if (c.type==='police') poC++; else if (c.type==='fire') fC++;\n    else if (c.type==='school') sC++; else if (c.type==='hospital') hC++; else if (c.type==='road') rdC++;\n    else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {\n      // Count power plants (for stats)\n    }\n  }\n  updLV();\n  updCrime();\n  // Track processed buildings to avoid duplicate updates for merged buildings\n  const processedBuildings = new Set();\n  const processedCells = new Set(); // Track individual cells that have been processed\n  \n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential'||c.type==='commercial'||c.type==='industrial') {\n      // Skip if this cell has already been processed (e.g., as part of a merged building)\n      const cellKey = `${x},${y}`;\n      if (processedCells.has(cellKey)) continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only process the top-left cell of each building\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (!isTopLeft) continue;\n      \n      // Skip if this building has already been processed\n      const buildingKey = `${x},${y},${c.type},${w},${h}`;\n      if (processedBuildings.has(buildingKey)) continue;\n      processedBuildings.add(buildingKey);\n      \n      // Mark all cells of this building as processed\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=x+dx, ny=y+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            processedCells.add(`${nx},${ny}`);\n          }\n        }\n      }\n        \n        const lv=st.landValue[y][x], hr=hasRdAcc(x,y), mv=c.type==='industrial'?10:20;\n        const level = c.level || 0;\n        \n        // Check power requirements\n        let needsPower = false;\n        if (c.type === 'residential' && (level === 2 || level === 3)) needsPower = true;\n        else if (c.type === 'commercial' || c.type === 'industrial') needsPower = true;\n        \n        const hasPower = buildingHasPower(x, y);\n        \n        // Track ticks without road access\n      if (!hr) {\n        c.ticksNoRoad = (c.ticksNoRoad || 0) + 1;\n      } else {\n        c.ticksNoRoad = 0;\n      }\n      \n      // Track ticks without power (if building needs it)\n      if (needsPower && !hasPower) {\n        c.ticksNoPower = (c.ticksNoPower || 0) + 1;\n      } else {\n        c.ticksNoPower = 0;\n      }\n      \n      // Immediate abandonment if land value too low OR no power for extended period (15 ticks)\n      if (lv<mv || (needsPower && !hasPower && c.ticksNoPower > 15)) { \n        c.abandoned=true;\n        // Keep level but mark as abandoned - don't set to 0\n        // Update all cells of merged building\n        const w=c.w||1, h=c.h||1;\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=true;\n          }\n        }\n      }\n      // Gradual decline without road access\n      else if (!hr) {\n        // Downgrade every 3 ticks without road\n        if (c.ticksNoRoad > 3 && c.level > 1) {\n          c.level--;\n          c.ticksNoRoad = 0; // Reset counter after downgrade\n          // Update all cells of merged building\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n          }\n        }\n        // Become abandoned after being at level 1 for 5 ticks without road\n        else if (c.ticksNoRoad > 5 && c.level >= 1) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n        // Immediately abandon if no road for 10+ ticks\n        else if (c.ticksNoRoad > 10) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          const w=c.w||1, h=c.h||1;\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n      }\n      else {\n        c.abandoned=false;\n        // Update all cells of merged building to un-abandon\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=false;\n          }\n        }\n        \n        // Check for downgrades first (more important)\n        let downgraded = false;\n        \n        // Downgrade if no power and building needs it (after 5 ticks)\n        if (needsPower && !hasPower && c.ticksNoPower > 5 && c.level > 0) {\n          // For residential: downgrade L3->L2, L2->L1 (but L1 doesn't need power so stop there)\n          // For commercial/industrial: downgrade by 1 level\n          if (c.type === 'residential' && c.level >= 2) {\n            const newLevel = c.level - 1;\n            c.level = newLevel;\n            downgraded = true;\n            c.ticksNoPower = 0;\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          } else if ((c.type === 'commercial' || c.type === 'industrial') && c.level > 1) {\n            const newLevel = c.level - 1;\n            c.level = newLevel;\n            downgraded = true;\n            c.ticksNoPower = 0;\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          }\n        }\n        \n        if (!downgraded) {\n          if (lv<30 && c.level>1) { \n            const newLevel = Math.max(1,c.level-1);\n            c.level = newLevel;\n            downgraded = true;\n            // Update all cells of merged building\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          }\n          // Level 3 downgrades: need land value >= 40 AND school coverage (same criteria as upgrade)\n          else if (c.level===3 && (lv<40 || !hasSchoolCoverage(x,y))) { \n            c.level=2; \n            downgraded = true;\n            // Update all cells of merged building\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=2;\n            }\n          }\n        }\n        \n          // Upgrade logic - only if not downgraded, gradual one level at a time\n          // Slowed down upgrades: require more age and better conditions\n          // Also require power if building needs it\n          if (!downgraded) {\n            let upgraded = false;\n            // Level 0 -> 1: needs age > 10 ticks (was 5)\n            if (c.level===0 && c.age>10) {\n              // Check if level 1 would need power\n              const wouldNeedPower = (c.type === 'commercial' || c.type === 'industrial');\n              if (!wouldNeedPower || hasPower) {\n                c.level=1;\n                upgraded = true;\n              }\n            }\n            // Level 1 -> 2: needs age > 30 AND land value > 55 (was 15 and 50)\n            // For residential: also needs power (L2 requires power)\n            // For commercial/industrial: also needs power\n            else if (c.level===1 && c.age>30 && lv>55) {\n              if (hasPower) {\n                c.level=2;\n                upgraded = true;\n              }\n            }\n            // Level 2 -> 3: needs age > 50 AND land value >= 40 AND school coverage\n            // Also needs power (L3 requires power for residential, commercial, industrial)\n            else if (c.level===2 && c.age>50 && lv>=40 && hasSchoolCoverage(x,y)) {\n              if (hasPower) {\n                c.level=3;\n                upgraded = true;\n              }\n            }\n          \n          // Update all cells of merged building if upgraded\n          if (upgraded) {\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n            }\n          }\n        }\n        \n        // Two-step merging process:\n        // Step 1: Try to merge 1x1 buildings to 2x1 or 1x2 first\n        if (c.age>8 && w===1 && h===1 && c.level>0) {\n          const merged=tryMrgTo2x1(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged building as processed\n            // The merged building is now 2x1 or 1x2, so we need to update processedCells\n            // But we don't know which direction it merged, so we'll let the next iteration handle it\n            // For now, just mark the current cell as processed\n            processedCells.add(`${x},${y}`);\n            if (x+1<GR_SZ) processedCells.add(`${x+1},${y}`); // If merged right (2x1)\n            if (y+1<GR_SZ) processedCells.add(`${x},${y+1}`); // If merged down (1x2)\n          }\n        }\n        // Step 2: Try to merge 2x1 or 1x2 buildings to 2x2 (only if at least one is 2x1/1x2)\n        if (c.age>12 && ((w===1&&h===2) || (w===2&&h===1)) && c.level>0) {\n          // Only try merge if this is the top-left cell of the building\n          // For 1x2: always top-left (spans down)\n          // For 2x1: always top-left (spans right)\n          const merged=tryMrg(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged 2x2 building as processed\n            // After merge, the grid has been updated with a 2x2 building\n            // Check the current cell and nearby cells to find the 2x2 building's top-left\n            let found2x2=false;\n            for (let checkY=Math.max(0,y-1); checkY<=Math.min(GR_SZ-2,y+1) && !found2x2; checkY++) {\n              for (let checkX=Math.max(0,x-1); checkX<=Math.min(GR_SZ-2,x+1) && !found2x2; checkX++) {\n                const checkCell=st.grid[checkY][checkX];\n                if (checkCell.type===c.type && (checkCell.w||1)===2 && (checkCell.h||1)===2) {\n                  // This is the top-left of the merged 2x2 building\n                  // Mark all 4 cells as processed\n                  for (let dy=0; dy<2; dy++) {\n                    for (let dx=0; dx<2; dx++) {\n                      const nx=checkX+dx, ny=checkY+dy;\n                      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                        processedCells.add(`${nx},${ny}`);\n                      }\n                    }\n                  }\n                  found2x2=true;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else if (c.type.startsWith('park')) {\n      // Try to merge parks of the same type\n      tryMrgPark(x,y);\n    }\n  }\n  const bPR=10; let nP=0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n      const sM=(c.w||1)*(c.h||1), lM=c.level===3?1.5:(c.level===2?1.2:1);\n      nP+=Math.floor(bPR*sM*lM);\n    }\n  }\n  if (!Number.isFinite(st.populationNewsBonus)) st.populationNewsBonus=0;\n  const effectivePopulation=Math.max(0,nP+(st.populationNewsBonus||0));\n  st.population=effectivePopulation;\n  const jA=cC*5+iC*8, jN=effectivePopulation*0.6;\n  if (jA<=0 || jN<=0) st.employment=0;\n  else st.employment=Math.min(100,Math.floor((Math.min(jA,jN)/jN)*100));\n  \n  // IMPROVED ECONOMY CALCULATIONS\n  // 1. Residential tax income (scaled by level and land value)\n  let residentialIncome = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseTax=2.5; // Base tax per person (increased to balance expenses)\n      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n      const landValueMultiplier=1+(lv-50)/100; // +1% per point above 50\n      const popPerCell=Math.floor(10*size*levelMultiplier);\n      residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);\n    }\n  }\n  \n  // 2. Commercial revenue (based on population served, level, land value, employment)\n  let commercialRevenue = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseRevenue=18; // Base revenue per cell (increased to balance expenses)\n      const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));\n      const landValueMultiplier=1+(lv-50)/80;\n      const employmentMultiplier=0.5+(st.employment/200); // 0.5x to 1.0x based on employment\n      const populationMultiplier=Math.min(2.0,1+(st.population/5000)); // More population = more customers\n      commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);\n    }\n  }\n  \n  // 3. Industrial revenue (based on employment, level, land value)\n  let industrialRevenue = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseRevenue=24; // Base revenue per cell (increased to balance expenses)\n      const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));\n      const landValueMultiplier=1+(lv-50)/100;\n      const employmentMultiplier=0.4+(st.employment/167); // 0.4x to 1.0x based on employment\n      industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);\n    }\n  }\n  \n  // 4. Tourism income from parks (scaled by park size and city population)\n  let tourismIncome = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type && c.type.startsWith('park')) {\n      const size=(c.w||1)*(c.h||1);\n        const baseTourism=6; // Base tourism per cell (increased to balance expenses)\n        const populationMultiplier=Math.min(3.0,1+(st.population/3000)); // More people = more visitors\n        const happinessMultiplier=0.7+(st.happiness/143); // Higher happiness = more tourism\n        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);\n    }\n  }\n  \n  // 5. Apply tax rate multiplier (taxRate is 0-20, convert to 0.5-1.5 multiplier)\n  const taxMultiplier=0.5+(st.taxRate/20); // 10% tax = 1.0x, 20% = 1.5x, 0% = 0.5x\n  const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);\n  \n  // 6. Improved maintenance (scaled by building level) - INCREASED COSTS\n  let totalMaintenance = 0;\n  \n  // Base building maintenance (increased)\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='road') totalMaintenance+=2; // Increased from 1\n    else if (c.type==='residential' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n      totalMaintenance+=Math.floor(5*levelMultiplier); // Increased from 2\n    }\n    else if (c.type==='commercial' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));\n      totalMaintenance+=Math.floor(8*levelMultiplier); // Increased from 3\n    }\n    else if (c.type==='industrial' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));\n      totalMaintenance+=Math.floor(12*levelMultiplier); // Increased from 5\n    }\n    else if (c.type && c.type.startsWith('park')) totalMaintenance+=4; // Increased from 2\n    else if (c.type==='police') totalMaintenance+=25; // Increased from 10\n    else if (c.type==='fire') totalMaintenance+=25; // Increased from 10\n    else if (c.type==='school') totalMaintenance+=40; // Increased from 15\n    else if (c.type==='hospital') totalMaintenance+=60; // Increased from 20\n    else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {\n      const maint = POWER_PLANT_MAINTENANCE[c.type] || 0;\n      totalMaintenance += maint;\n    }\n  }\n  \n  // Population-based infrastructure costs (utilities, waste management, etc.)\n  const infrastructureCost = Math.floor(st.population * 0.5); // $0.50 per person\n  \n  // Service operation costs (based on population served)\n  let serviceCosts = 0;\n  if (st.population > 0) {\n    // Police operation cost (scales with population and crime)\n    let avgCrime = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime += st.crime[y][x] || 30;\n    }\n    avgCrime = avgCrime / (GR_SZ * GR_SZ);\n    const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100)); // Higher crime = more police costs\n    serviceCosts += policeOpCost;\n    \n    // Fire department operation cost\n    const fireOpCost = Math.floor(st.population * 0.2);\n    serviceCosts += fireOpCost;\n    \n    // Education costs (scales with population)\n    const educationCost = Math.floor(st.population * 0.4);\n    serviceCosts += educationCost;\n    \n    // Healthcare costs (scales with population and affected by happiness)\n    const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));\n    serviceCosts += healthCost;\n  }\n  \n  // Crime-related expenses (damage, insurance, etc.)\n  let crimeExpenses = 0;\n  if (st.population > 0) {\n    let avgCrime = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime += st.crime[y][x] || 30;\n    }\n    avgCrime = avgCrime / (GR_SZ * GR_SZ);\n    if (avgCrime > 40) {\n      crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20); // $1 per person per 20 crime points above 40\n    }\n  }\n  \n  // Road maintenance (increases with city size and traffic)\n  const roadMaintenanceBonus = Math.floor(rdC * 0.1); // Additional cost for extensive road networks\n  \n  totalMaintenance += infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;\n  \n  const inc=totalIncome, mnt=totalMaintenance;\n  st.money+=inc-mnt;\n  let hp=70;\n  if (st.population>0) {\n    const pR=pC/(rC+1); hp+=Math.min(pR*50,15);\n    const sR=(poC+fC+sC+hC)/(st.population/100+1); hp+=Math.min(sR*20,10);\n    const jR=(cC+iC)/(rC+1); if (jR<0.5) hp-=10; else if (jR>2) hp-=5;\n    if (st.money<0) hp-=15;\n    // Tax rate affects happiness: 10% is neutral, lower = happier, higher = unhappier\n    const taxImpact=(st.taxRate-10)*0.8; // -8 to +8 happiness based on tax rate (0-20%)\n    hp-=taxImpact;\n    // Factor in crime - calculate average city crime\n    let avgCrime=0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime+=st.crime[y][x]||30;\n    }\n    avgCrime=avgCrime/(GR_SZ*GR_SZ);\n    // High crime reduces happiness (up to -15 points)\n    if (avgCrime>60) hp-=Math.min(15,Math.floor((avgCrime-60)/2));\n    else if (avgCrime>40) hp-=Math.min(8,Math.floor((avgCrime-40)/3));\n    // Police coverage improves happiness\n    if (poC>0 && st.population>0) {\n      const policeRatio=poC/(st.population/500+1);\n      hp+=Math.min(5,policeRatio*2);\n    }\n  }\n  st.happiness=Math.max(0,Math.min(100,Math.floor(hp)));\n  const dmd=calcDmd(rC,cC,iC,st.population); st.rDemand=Math.floor(dmd.rDemand); st.cDemand=Math.floor(dmd.cDemand); st.iDemand=Math.floor(dmd.iDemand);\n  const tB=rC+cC+iC+pC+poC+fC+sC+hC;\n  if (st.ticksSinceNews>=20 && tB>5 && !aiReq) { st.ticksSinceNews=0; genNws(); }\n    if (Math.random()<0.02 && tB>10) startFire();\n  \n  // Update resident routines (daily schedules, car spawning)\n  updateResidentRoutines();\n    if (Math.random()<0.01 && tB>20) startQuake();\n    if (Math.random()<0.02 && st.population>50) startCrimeEvent();\n    ensureEmergencyCoverage();\n    updFires(); updCrimeEvents(); drGr(); updUI(); updateStatsPanel(); sv();\n}\n\n// ===== Audio =====\nconst aC=new (window.AudioContext||window.webkitAudioContext)();\nfunction plySnd(t) {\n  const n=aC.currentTime;\n  if (t==='place') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); }\n  else if (t==='bulldoze') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sawtooth'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(200,n); g.gain.setValueAtTime(0.15,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); }\n  else if (t==='click') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(600,n); g.gain.setValueAtTime(0.08,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.05); o.start(n); o.stop(n+0.05); }\n  else if (t==='error') { const o=aC.createOscillator(), g=aC.createGain(); o.type='square'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(300,n); o.frequency.setValueAtTime(200,n+0.1); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); }\n  else if (t==='fire') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(700,n); o.frequency.setValueAtTime(500,n+0.15); o.frequency.setValueAtTime(700,n+0.3); o.frequency.setValueAtTime(500,n+0.45); g.gain.setValueAtTime(0.06,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.6); o.start(n); o.stop(n+0.6); }\n  else if (t==='crime') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); o.frequency.setValueAtTime(600,n+0.12); o.frequency.setValueAtTime(800,n+0.24); o.frequency.setValueAtTime(600,n+0.36); o.frequency.setValueAtTime(800,n+0.48); g.gain.setValueAtTime(0.06,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.6); o.start(n); o.stop(n+0.6); }\n  else if (t==='earthquake') {\n    // Low rumble\n    const o1=aC.createOscillator(), g1=aC.createGain();\n    o1.type='sine'; o1.connect(g1); g1.connect(aC.destination);\n    o1.frequency.setValueAtTime(80,n);\n    o1.frequency.exponentialRampToValueAtTime(30,n+1.5);\n    g1.gain.setValueAtTime(0.25,n);\n    g1.gain.exponentialRampToValueAtTime(0.001,n+1.5);\n    o1.start(n); o1.stop(n+1.5);\n    \n    // Mid rumble for more impact\n    const o2=aC.createOscillator(), g2=aC.createGain();\n    o2.type='sine'; o2.connect(g2); g2.connect(aC.destination);\n    o2.frequency.setValueAtTime(150,n);\n    o2.frequency.exponentialRampToValueAtTime(60,n+1.5);\n    g2.gain.setValueAtTime(0.15,n);\n    g2.gain.exponentialRampToValueAtTime(0.001,n+1.5);\n    o2.start(n); o2.stop(n+1.5);\n  }\n}\n\nif (!ld()) { initGr('balanced'); st.newsEvents=['Welcome to '+st.cityName+'!']; }\nif (!st.zoom) st.zoom=1;\nif (st.disastersEnabled === undefined) st.disastersEnabled = true;\nconst disastersToggleEl = document.getElementById('disastersToggle');\nif (disastersToggleEl) {\n  disastersToggleEl.checked = st.disastersEnabled;\n  disastersToggleEl.addEventListener('change', (e) => {\n    st.disastersEnabled = e.target.checked;\n    updateDisasterButtonsVisibility();\n    sv();\n  });\n}\nupdateDisasterButtonsVisibility();\napplyZoom();\ndrGr(); updUI(); updNwsTk(); selTl('road');\nif (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); }\n\n// Center canvas after page is fully loaded\nwindow.addEventListener('load', () => {\n  setTimeout(centerCanvas, 100);\n});\n\n// Re-center canvas when window is resized\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimeout);\n  resizeTimeout = setTimeout(centerCanvas, 100);\n});\n\nsetInterval(() => { if (st.speed>0) { updCars(); drGr(); } },50);\n\n// Building info panel for stat view\nfunction showBuildingInfo(x, y) {\n  // On mobile, don't show building info immediately after placing a tile\n  if (isMobile && justPlacedTileOnMobile) return;\n  \n  const c = st.grid[y][x];\n  if (!c || c.type === 'empty' || c.type === 'road') return;\n  \n  const panel = document.getElementById('buildingInfoPanel');\n  const title = document.getElementById('buildingInfoTitle');\n  const content = document.getElementById('buildingInfoContent');\n  \n  // Get building icon\n  const icon = {\n    'residential': 'üè†',\n    'commercial': 'üè¢',\n    'industrial': 'üè≠',\n    'road': 'üõ£Ô∏è',\n    'park': 'üå≥',\n    'park2': 'üå∏',\n    'park3': 'üå≤',\n    'park4': 'üåª',\n    'police': 'üëÆ',\n    'fire': 'üöí',\n    'school': 'üè´',\n    'hospital': 'üè•',\n    'coal': '‚ö°',\n    'nuclear': '‚ò¢Ô∏è',\n    'wind': 'üí®',\n    'waterplant': 'üè≠',\n    'watertower': 'üóº'\n  }[c.type] || 'üèóÔ∏è';\n  \n  // Format building name\n  let name = c.type.charAt(0).toUpperCase() + c.type.slice(1).replace(/\\d+$/, '');\n  \n  // Add level to name for zones\n  if ((c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') && !c.abandoned) {\n    const level = c.level || 0;\n    name = `${name} L${level}`;\n  }\n  \n  title.textContent = `${icon} ${name}`;\n  \n  // Build content - always show in order: size, age, land value, other values\n  let statItems = [];\n  \n  // 1. Size - always show\n  const w = c.w || 1;\n  const h = c.h || 1;\n  statItems.push(statItem('size', `${w}‚®Ø${h}`));\n  \n  // 2. Age - show if defined\n  if (c.age !== undefined) {\n    const years = Math.floor(c.age / 12);\n    statItems.push(statItem('age', `${years} year${years !== 1 ? 's' : ''}`));\n  }\n  \n  // 3. Land value - always show\n  const landValue = st.landValue[y] && st.landValue[y][x] !== undefined ? st.landValue[y][x] : 50;\n  const lvColor = landValue >= 80 ? 'text-green-400' : landValue >= 50 ? 'text-yellow-400' : 'text-orange-400';\n  statItems.push(statItem('land value', landValue.toFixed(0), lvColor));\n  \n  // 4. Other values - status, maintenance, income, etc.\n  // Status for abandoned zones\n  if ((c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') && c.abandoned) {\n    statItems.push(statItem('status', 'Abandoned', 'text-red-400'));\n  }\n  \n  // Cost and maintenance for parks and service buildings\n  if (c.type && c.type.startsWith('park')) {\n    const size = w * h;\n    const maintenance = 4 * size; // $4 per tile per month\n    statItems.push(statItem('maintenance', `-$${maintenance}/mo`, 'text-red-400'));\n    \n    // Calculate tourism income\n    const baseTourism = 6;\n    const populationMultiplier = Math.min(3.0, 1 + (st.population / 3000));\n    const happinessMultiplier = 0.7 + (st.happiness / 143);\n    const tourismIncome = Math.floor(baseTourism * size * populationMultiplier * happinessMultiplier);\n    statItems.push(statItem('tourism income', `+$${tourismIncome}/mo`, 'text-green-400'));\n  } else if (c.type === 'police') {\n    statItems.push(statItem('maintenance', '-$25/mo', 'text-red-400'));\n    statItems.push(statItem('coverage', '8-tile radius', 'text-blue-400'));\n  } else if (c.type === 'fire') {\n    statItems.push(statItem('maintenance', '-$25/mo', 'text-red-400'));\n  } else if (c.type === 'school') {\n    statItems.push(statItem('maintenance', '-$40/mo', 'text-red-400'));\n    statItems.push(statItem('coverage', '8-tile radius', 'text-blue-400'));\n  } else if (c.type === 'hospital') {\n    statItems.push(statItem('maintenance', '-$60/mo', 'text-red-400'));\n  } else if (c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind') {\n    const size = w * h;\n    const maintenance = (POWER_PLANT_MAINTENANCE[c.type] || 0) * size;\n    const generation = POWER_GENERATION[c.type] || 0;\n    statItems.push(statItem('maintenance', `-$${maintenance}/mo`, 'text-red-400'));\n    statItems.push(statItem('generation', `+${generation}`, 'text-green-400'));\n  } else if (c.type === 'waterplant' || c.type === 'watertower') {\n    const size = w * h;\n    const maintenance = (WATER_PLANT_MAINTENANCE[c.type] || 0) * size;\n    const generation = WATER_GENERATION[c.type] || 0;\n    statItems.push(statItem('maintenance', `-$${maintenance}/mo`, 'text-red-400'));\n    statItems.push(statItem('generation', `+${generation}`, 'text-green-400'));\n  }\n  \n  // Crime overlay (if active)\n  const crime = st.crime[y] && st.crime[y][x] !== undefined ? st.crime[y][x] : 30;\n  \n  if (showCrimeOverlay) {\n    const crimeColor = crime >= 70 ? 'text-red-400' : crime >= 30 ? 'text-yellow-400' : 'text-green-400';\n    const crimeLevel = crime >= 70 ? 'High' : crime >= 30 ? 'Medium' : 'Low';\n    statItems.push(statItem('crime', `${crimeLevel} (${crime.toFixed(0)})`, crimeColor));\n  }\n  \n  // Build the stats HTML\n  let statsHTML = '';\n  if (statItems.length > 0) {\n    statsHTML = `<div class=\"flex flex-wrap gap-6 py-2\">${statItems.join('')}</div>`;\n  }\n  \n  // For residential buildings, always show residents below stats\n  let residentsHTML = '';\n  if (c.type === 'residential' && !c.abandoned && hasRdAcc(x, y)) {\n    const residents = generateResidentsForBuilding(x, y);\n    if (residents.length > 0) {\n      // Store building coordinates for back button\n      lastBuildingView = { x, y };\n      \n      const residentList = residents.slice(0, 20).map((r, idx) => {\n        const workplaceEmoji = r.workplace ? getWorkplaceEmoji(r.workplace.type) : '‚ùå';\n        return `\n          <div class=\"inline-flex items-center gap-1.5 bg-neutral-700/50 hover:bg-neutral-700 rounded-full px-2.5 py-1 cursor-pointer transition-colors text-xs\" onclick=\"showResidentInfo(${r.id}, ${x}, ${y})\">\n            <span class=\"font-medium text-white\">${r.name}</span>\n            <span>${workplaceEmoji}</span>\n          </div>\n        `;\n      }).join('');\n      \n      const moreText = residents.length > 20 ? `<div class=\"inline-flex items-center bg-neutral-700/50 rounded-full px-2.5 py-1 text-xs text-neutral-500\">+${residents.length - 20} more</div>` : '';\n      \n      residentsHTML = `\n        <div class=\"border-t border-neutral-700 mt-3 pt-3\">\n          <div class=\"text-xs text-neutral-400 mb-2\">${residents.length} resident${residents.length !== 1 ? 's' : ''}</div>\n          <div class=\"flex flex-wrap gap-1.5 max-h-64 overflow-y-auto\">\n            ${residentList}\n            ${moreText}\n          </div>\n          <div class=\"text-xs text-neutral-500 mt-2\">Click on a resident to view details</div>\n        </div>\n      `;\n    }\n  }\n  \n  // Combine stats and residents\n  content.innerHTML = statsHTML + residentsHTML;\n  panel.classList.remove('hidden');\n  \n  // Set highlighted building (get full building bounds from top-left corner)\n  const bounds = getBuildingBoundsFromCell(x, y);\n  highlightedBuilding = {\n    x: bounds.startX,\n    y: bounds.startY,\n    w: bounds.w,\n    h: bounds.h\n  };\n  highlightedWorkplace = null; // Clear workplace highlight\n  drGr(); // Redraw to show highlight\n}\n\nfunction hideBuildingInfo() {\n  const panel = document.getElementById('buildingInfoPanel');\n  panel.classList.add('hidden');\n  highlightedBuilding = null;\n  highlightedWorkplace = null;\n  lastBuildingView = null;\n  drGr(); // Redraw to remove highlight\n}\n\nfunction findResidentById(residentId) {\n  for (const buildingKey in st.residents) {\n    const residents = st.residents[buildingKey];\n    const resident = residents.find(r => r.id === residentId);\n    if (resident) return resident;\n  }\n  return null;\n}\n\nfunction showResidentInfo(residentId, buildingX, buildingY) {\n  // Use provided building coordinates or fall back to lastBuildingView\n  const bX = buildingX !== undefined ? buildingX : (lastBuildingView ? lastBuildingView.x : null);\n  const bY = buildingY !== undefined ? buildingY : (lastBuildingView ? lastBuildingView.y : null);\n  \n  let resident = null;\n  \n  // Try to find resident directly from the building if coordinates are provided\n  if (bX !== null && bY !== null) {\n    // Regenerate residents for the building to ensure we have the latest data\n    const residents = generateResidentsForBuilding(bX, bY);\n    resident = residents.find(r => r.id === residentId);\n    // Also ensure lastBuildingView is set for back button\n    if (!lastBuildingView) {\n      lastBuildingView = { x: bX, y: bY };\n    }\n  }\n  \n  // Fall back to searching all buildings if not found\n  if (!resident) {\n    resident = findResidentById(residentId);\n  }\n  \n  if (!resident) return;\n  \n  const panel = document.getElementById('buildingInfoPanel');\n  const title = document.getElementById('buildingInfoTitle');\n  const content = document.getElementById('buildingInfoContent');\n  \n  // Set title with back button on the left (X button stays on the right via HTML structure)\n  const backButton = lastBuildingView \n    ? `<button onclick=\"showBuildingInfo(${lastBuildingView.x}, ${lastBuildingView.y})\" class=\"text-xs text-neutral-400 hover:text-neutral-200 transition-colors flex items-center gap-1\">\n        ‚Üê Back\n      </button>`\n    : '';\n  \n  title.innerHTML = backButton;\n  \n  const workplaceText = resident.workplace \n    ? `${getWorkplaceEmoji(resident.workplace.type)} ${getWorkplaceTypeName(resident.workplace.type)} (${resident.workplace.x}, ${resident.workplace.y})`\n    : '‚ùå Unemployed';\n  \n  const workHoursText = resident.workplace \n    ? `${resident.workHours.start}:00 - ${resident.workHours.end}:00`\n    : 'N/A';\n  \n  // Highlight workplace building if it exists\n  if (resident.workplace) {\n    const bounds = getBuildingBoundsFromCell(resident.workplace.x, resident.workplace.y);\n    highlightedWorkplace = {\n      x: bounds.startX,\n      y: bounds.startY,\n      w: bounds.w,\n      h: bounds.h\n    };\n  } else {\n    highlightedWorkplace = null;\n  }\n  \n  // Keep home building highlighted\n  if (lastBuildingView) {\n    const bounds = getBuildingBoundsFromCell(lastBuildingView.x, lastBuildingView.y);\n    highlightedBuilding = {\n      x: bounds.startX,\n      y: bounds.startY,\n      w: bounds.w,\n      h: bounds.h\n    };\n  }\n  \n  const isFollowing = followedResident === resident.id;\n  const followButtonText = isFollowing ? 'Unfollow' : 'Follow';\n  const followButtonClass = isFollowing \n    ? 'bg-red-600 hover:bg-red-700 text-white text-xs py-1.5 px-3 rounded transition-colors flex-shrink-0'\n    : 'bg-blue-600 hover:bg-blue-700 text-white text-xs py-1.5 px-3 rounded transition-colors flex-shrink-0';\n  const followButtonAction = isFollowing \n    ? `stopFollowingResident()`\n    : `followResident(${resident.id})`;\n  \n  content.innerHTML = `\n    <div class=\"mb-3 flex items-center justify-between gap-2\">\n      <div class=\"text-sm font-bold text-white\">${resident.name}</div>\n      <button onclick=\"${followButtonAction}\" class=\"${followButtonClass}\">\n        ${followButtonText}\n      </button>\n    </div>\n    <div class=\"space-y-3\">\n      <div class=\"text-xs text-neutral-400 leading-relaxed\">\n        ${resident.story}\n      </div>\n      \n      <div class=\"border-t border-neutral-700 pt-2\">\n        <div class=\"text-xs font-semibold text-neutral-300 mb-2\">Work Details</div>\n        <div class=\"text-xs text-neutral-400 space-y-1\">\n          <div>${workplaceText}</div>\n          <div>Occupation: ${resident.occupation}</div>\n          <div>Work Hours: ${workHoursText}</div>\n        </div>\n      </div>\n      \n      <div class=\"border-t border-neutral-700 pt-2\">\n        <div class=\"text-xs font-semibold text-neutral-300 mb-2\">Financial Info</div>\n        <div class=\"flex flex-wrap gap-4 text-xs\">\n          ${statItem('income', `$${resident.income.toLocaleString()}/mo`, 'text-green-400')}\n          ${statItem('spend', `$${resident.spend.toLocaleString()}/mo`, 'text-yellow-400')}\n          ${statItem('tax', `$${resident.tax.toLocaleString()}/mo`, 'text-red-400')}\n        </div>\n      </div>\n    </div>\n  `;\n  \n  panel.classList.remove('hidden');\n  drGr(); // Redraw to show highlights\n}\n\nfunction followResident(residentId) {\n  const resident = findResidentById(residentId);\n  if (!resident) return;\n  \n  followedResident = residentId;\n  \n  // Update button to show unfollow\n  const panel = document.getElementById('buildingInfoPanel');\n  const content = document.getElementById('buildingInfoContent');\n  const buttons = content.querySelectorAll('button');\n  // Find the follow button\n  const followButton = Array.from(buttons).find(btn => btn.textContent.includes('Follow') || btn.textContent.includes('Unfollow'));\n  if (followButton) {\n    followButton.textContent = 'Unfollow';\n    followButton.className = 'bg-red-600 hover:bg-red-700 text-white text-xs py-1.5 px-3 rounded transition-colors flex-shrink-0';\n    followButton.onclick = () => stopFollowingResident();\n  }\n  \n  // Create or update car for resident\n  getResidentCar(resident);\n  \n  drGr(); // Redraw to show highlight\n}\n\nfunction stopFollowingResident() {\n  const currentResidentId = followedResident;\n  followedResident = null;\n  \n  // Update button back if panel is still showing the resident\n  const panel = document.getElementById('buildingInfoPanel');\n  const content = document.getElementById('buildingInfoContent');\n  const buttons = content.querySelectorAll('button');\n  // Find the follow/unfollow button\n  const followButton = Array.from(buttons).find(btn => btn.textContent.includes('Follow') || btn.textContent.includes('Unfollow'));\n  if (followButton && currentResidentId) {\n    const resident = findResidentById(currentResidentId);\n    if (resident) {\n      followButton.textContent = 'Follow';\n      followButton.className = 'bg-blue-600 hover:bg-blue-700 text-white text-xs py-1.5 px-3 rounded transition-colors flex-shrink-0';\n      followButton.setAttribute('onclick', `followResident(${currentResidentId})`);\n    }\n  }\n  \n  // Update car color\n  const car = st.cars.find(c => c.residentId === currentResidentId);\n  if (car && car.isResidentCar) {\n    car.color = '#808080';\n  }\n  \n  drGr(); // Redraw to remove highlight\n}\n\nfunction getResidentCar(resident) {\n  // Check if resident already has a car\n  const existingCar = st.cars.find(c => c.residentId === resident.id);\n  if (existingCar) {\n    // Update car color if followed\n    if (followedResident === resident.id) {\n      existingCar.color = '#ffeb3b';\n    }\n    return existingCar;\n  }\n  \n  // Only create car if resident has a workplace\n  if (!resident.workplace) return null;\n  \n  const homeX = resident.homeBuilding.x;\n  const homeY = resident.homeBuilding.y;\n  const workX = resident.workplace.x;\n  const workY = resident.workplace.y;\n  \n  // Find roads near home and workplace\n  const rdNear = [];\n  for (let dy = -1; dy <= 1; dy++) {\n    for (let dx = -1; dx <= 1; dx++) {\n      const nx = homeX + dx, ny = homeY + dy;\n      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ && st.grid[ny][nx].type === 'road') {\n        rdNear.push({x: nx, y: ny});\n      }\n    }\n  }\n  \n  const rdEnd = [];\n  for (let dy = -1; dy <= 1; dy++) {\n    for (let dx = -1; dx <= 1; dx++) {\n      const nx = workX + dx, ny = workY + dy;\n      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ && st.grid[ny][nx].type === 'road') {\n        rdEnd.push({x: nx, y: ny});\n      }\n    }\n  }\n  \n  if (rdNear.length === 0 || rdEnd.length === 0) return null;\n  \n  const start = rdNear[Math.floor(Math.random() * rdNear.length)];\n  const end = rdEnd[Math.floor(Math.random() * rdEnd.length)];\n  \n  const path = findPath(start.x, start.y, end.x, end.y);\n  if (!path || path.length < 2) return null;\n  \n  // Determine lane offset\n  let laneOffset = 0;\n  const startCenterX = path[0].x * CL_SZ + 7;\n  const startCenterY = path[0].y * CL_SZ + 7;\n  let startX = startCenterX;\n  let startY = startCenterY;\n  \n  if (path.length >= 2) {\n    const dx = path[1].x - path[0].x;\n    const dy = path[1].y - path[0].y;\n    \n    if (Math.abs(dx) > Math.abs(dy)) {\n      laneOffset = dx > 0 ? 5 : -5;\n      startY += laneOffset;\n    } else {\n      laneOffset = dy > 0 ? -5 : 5;\n      startX += laneOffset;\n    }\n  }\n  \n  const src = {x: homeX, y: homeY};\n  const dst = {x: workX, y: workY};\n  const entryDir = getEdgeDirection(src, start);\n  let entryTarget = null;\n  let entering = false;\n  let spawnX = startX;\n  let spawnY = startY;\n  \n  if (entryDir.x !== 0 || entryDir.y !== 0) {\n    entering = true;\n    entryTarget = {x: startX, y: startY};\n    if (Math.abs(entryDir.x) >= Math.abs(entryDir.y) && entryDir.x !== 0) {\n      spawnX = startCenterX + entryDir.x * CAR_EDGE_OFFSET;\n      spawnY = startY;\n    } else if (entryDir.y !== 0) {\n      spawnY = startCenterY + entryDir.y * CAR_EDGE_OFFSET;\n      spawnX = startX;\n    }\n  }\n  \n  const endIdx = path.length - 1;\n  const endNode = path[endIdx];\n  const endCenterX = endNode.x * CL_SZ + 7;\n  const endCenterY = endNode.y * CL_SZ + 7;\n  let exitLaneX = endCenterX;\n  let exitLaneY = endCenterY;\n  \n  if (path.length >= 2) {\n    const dxLast = path[endIdx].x - path[endIdx - 1].x;\n    const dyLast = path[endIdx].y - path[endIdx - 1].y;\n    if (Math.abs(dxLast) > Math.abs(dyLast)) {\n      exitLaneY += dxLast > 0 ? 5 : -5;\n    } else {\n      exitLaneX += dyLast > 0 ? -5 : 5;\n    }\n  }\n  \n  const exitDir = getEdgeDirection(dst, end);\n  let exitLaneTarget = {x: exitLaneX, y: exitLaneY};\n  let exitTarget = null;\n  \n  if (exitDir.x !== 0 || exitDir.y !== 0) {\n    exitTarget = {x: exitLaneX, y: exitLaneY};\n    if (Math.abs(exitDir.x) >= Math.abs(exitDir.y) && exitDir.x !== 0) {\n      exitTarget.x = endCenterX + exitDir.x * CAR_EDGE_OFFSET;\n    } else if (exitDir.y !== 0) {\n      exitTarget.y = endCenterY + exitDir.y * CAR_EDGE_OFFSET;\n    }\n  }\n  \n  // Car color - use a distinct color for followed residents\n  const carColor = followedResident === resident.id ? '#ffeb3b' : '#808080';\n  \n  const car = {\n    x: spawnX,\n    y: spawnY,\n    path: path,\n    pathIdx: 0,\n    color: carColor,\n    type: 'normal',\n    laneOffset: laneOffset,\n    reverse: false,\n    entering: entering,\n    entryTarget: entryTarget,\n    exiting: false,\n    exitLaneTarget: exitLaneTarget,\n    exitTarget: exitTarget,\n    residentId: resident.id,\n    isResidentCar: true\n  };\n  \n  st.cars.push(car);\n  resident.car = car;\n  \n  return car;\n}\n\nfunction updateResidentRoutines() {\n  // Calculate time of day (0-23 hours) based on tick count\n  // Assuming 12 ticks per year, and each tick represents about 1 month\n  // For daily routines, we'll use a faster cycle: every 24 ticks = 1 day\n  const ticksPerDay = 24;\n  const hourOfDay = Math.floor((st.tickCount % ticksPerDay) * 24 / ticksPerDay);\n  \n  // Update each resident's routine\n  for (const buildingKey in st.residents) {\n    const residents = st.residents[buildingKey];\n    for (const resident of residents) {\n      if (!resident.workplace) continue; // Skip unemployed residents\n      \n      const workStart = resident.workHours.start;\n      const workEnd = resident.workHours.end;\n      \n      // Determine if resident should be traveling or at work/home\n      let shouldBeAtWork = false;\n      let shouldBeTraveling = false;\n      let travelDirection = null; // 'toWork' or 'toHome'\n      \n      if (hourOfDay >= workStart && hourOfDay < workEnd) {\n        // Work hours - should be at work\n        shouldBeAtWork = true;\n      } else if (hourOfDay >= workStart - 1 && hourOfDay < workStart) {\n        // Traveling to work (1 hour before work starts)\n        shouldBeTraveling = true;\n        travelDirection = 'toWork';\n      } else if (hourOfDay >= workEnd && hourOfDay < workEnd + 1) {\n        // Traveling home (1 hour after work ends)\n        shouldBeTraveling = true;\n        travelDirection = 'toHome';\n      }\n      \n      // Check if resident has a car\n      const existingCar = st.cars.find(c => c.residentId === resident.id);\n      \n      if (shouldBeTraveling && !existingCar && followedResident === resident.id) {\n        // Create car for followed resident if they should be traveling\n        getResidentCar(resident);\n      } else if (shouldBeAtWork && existingCar) {\n        // Remove car if resident should be at work (car is parked)\n        // Actually, keep the car but mark it as parked\n        if (existingCar.pathIdx >= existingCar.path.length - 1) {\n          // Car has reached destination, can remove it\n          const carIndex = st.cars.indexOf(existingCar);\n          if (carIndex > -1) {\n            st.cars.splice(carIndex, 1);\n            resident.car = null;\n          }\n        }\n      }\n      \n      // Update car color if followed\n      if (existingCar && followedResident === resident.id) {\n        existingCar.color = '#ffeb3b';\n      } else if (existingCar && existingCar.isResidentCar) {\n        existingCar.color = '#808080';\n      }\n    }\n  }\n}\n</script>\n</body>\n</html>\n\n",
  "title": "AI SimCity",
  "icon": "üèôÔ∏è",
  "name": "AI SimCity.app",
  "windowWidth": 420,
  "windowHeight": 625,
  "createdAt": 1763812022556,
  "createdBy": "ryo",
  "updatedAt": 1763812022556,
  "featured": true
}