{
  "content": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n    <link rel=\"stylesheet\" href=\"https://os.ryo.lu/fonts/fonts.css\">\n    <!-- ts=1763051833299 --> \n    \n    <script src=\"https://cdn.tailwindcss.com/3.4.16\"></script>\n    <script>\n      tailwind.config = {\n        theme: {\n          extend: {\n            fontFamily: {\n              sans: [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"sans-serif\"],\n              mono: [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"ui-monospace\", \"SFMono-Regular\", \"Menlo\", \"Monaco\", \"Consolas\", \"Liberation Mono\", \"Courier New\", \"monospace\"],\n              serif: [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"SerenityOS-Emoji\", \"serif\"],\n              emoji: [\"SerenityOS-Emoji\", \"AppleColorEmoji\", \"AppleColorEmojiFallback\"],\n              'geneva': [\"Geneva-12\", \"ArkPixel\", \"SerenityOS-Emoji\", \"system-ui\", \"-apple-system\", \"sans-serif\"],\n              'mondwest': [\"Mondwest\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"serif\"],\n              'neuebit': [\"NeueBit\", \"ArkPixel\", \"SerenityOS-Emoji\", \"Helvetica\", \"Arial\", \"Hiragino Sans\", \"sans-serif\"],\n              'monaco': [\"Monaco\", \"ArkPixel\", \"SerenityOS-Emoji\", \"monospace\"],\n              'jacquard': [\"Jacquard\", \"Yu Mincho\", \"Hiragino Mincho Pro\", \"Georgia\", \"Palatino\", \"serif\"]\n            }\n          }\n        }\n      }\n    </script>\n  <style>\n    * {\n      box-sizing: border-box;\n      \n    }\n    html, body {\n      margin: 0;\n      overflow-x: auto; /* Allow horizontal scroll if content overflows */\n      width: 100%;\n      height: 100%;\n      max-width: 100%; /* Prevent body from exceeding viewport width */\n      \n    }\n    \n    /* Ensure pre doesn't break layout */\n    pre {\n      white-space: pre-wrap; /* Allow wrapping */\n      word-break: break-all; /* Break long words */\n    }\n  </style>\n  \n  <!-- Move click interceptor script to head for earlier execution -->\n  <script>\n    document.addEventListener('DOMContentLoaded', function() {\n      document.addEventListener('click', function(event) {\n        var targetElement = event.target.closest('a');\n        // Only intercept if it's a valid link and NOT inside the draggable toolbar\n        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            // Resolve relative URLs against the document's base URI (if set) or window location\n            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;\n            // Use a specific message type for AI HTML navigation\n            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');\n            console.log('Intercepted link click:', absoluteUrl);\n          } catch (e) { console.error(\"Error resolving/posting URL:\", e); }\n        }\n      }, true); // Use capture phase to intercept early\n    });\n    \n    // Also add immediate execution version for documents that load quickly\n    // This helps ensure we don't miss any clicks during initial page load\n    (function() {\n      document.addEventListener('click', function(event) {\n        var targetElement = event.target.closest('a');\n        // Only intercept if it's a valid link and NOT inside the draggable toolbar\n        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {\n          event.preventDefault();\n          event.stopPropagation();\n          try {\n            // Resolve relative URLs against the document's base URI (if set) or window location\n            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;\n            // Use a specific message type for AI HTML navigation\n            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');\n            console.log('Intercepted link click (immediate handler):', absoluteUrl);\n          } catch (e) { console.error(\"Error resolving/posting URL:\", e); }\n        }\n      }, true); // Use capture phase to intercept early\n    })();\n  </script>\n \n</head>\n<body>\n  <div class=\"w-full h-screen bg-neutral-900 text-neutral-100 font-geneva flex flex-col overflow-hidden\">\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-2 flex items-center justify-between flex-shrink-0\">\n    <div class=\"flex items-center gap-3\">\n      <button id=\"menuBtn\" class=\"text-sm text-neutral-300 hover:text-neutral-100 transition-colors\">‚ò∞</button>\n      <div class=\"flex items-center gap-1\">\n        <div class=\"text-sm text-neutral-400\">\n          <input id=\"cityName\" type=\"text\" value=\"new city\" class=\"bg-transparent border-none outline-none text-white cursor-pointer hover:bg-neutral-700 px-1 rounded transition-colors\">\n        </div>\n        <button id=\"speedToggle\" class=\"text-xs text-neutral-300 hover:text-neutral-100 transition-colors\">‚è∏</button>\n      </div>\n    </div>\n    \n    <div class=\"flex items-center gap-3\">\n      <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"rciBtn\">\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"rDemand\" class=\"w-full bg-green-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"cDemand\" class=\"w-full bg-blue-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n        <div class=\"w-1 h-4 bg-neutral-700 rounded-full overflow-hidden\">\n          <div id=\"iDemand\" class=\"w-full bg-yellow-500 transition-all duration-300\" style=\"height: 50%; margin-top: auto;\"></div>\n        </div>\n      </div>\n      \n      <div class=\"flex items-center gap-3 text-xs\">\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"popBtn\">\n          <span class=\"text-neutral-500\">‚òª</span>\n          <span id=\"population\" class=\"text-white tabular-nums\">0</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"moneyBtn\">\n          <span class=\"text-neutral-500\">$</span>\n          <span id=\"money\" class=\"text-white tabular-nums\">50k</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"happyBtn\">\n          <span class=\"text-neutral-500\">‚ô•</span>\n          <span id=\"happiness\" class=\"text-white tabular-nums\">70</span>\n        </div>\n        <div class=\"flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity\" id=\"powerBtn\">\n          <span class=\"text-neutral-500\">‚ö°</span>\n          <span id=\"power\" class=\"text-white tabular-nums\">0/0</span>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"border-b border-neutral-700 bg-neutral-800 px-3 py-1.5 flex items-center gap-3 text-xs flex-shrink-0\">\n    <div id=\"yearDisplay\" class=\"text-neutral-400 font-mono tabular-nums\">1990</div>\n    <div class=\"flex-1 overflow-hidden relative\" style=\"height: 1.25rem; line-height: 1.25rem;\">\n      <div id=\"newsTicker\" class=\"text-neutral-300 whitespace-nowrap absolute left-0 transition-all duration-500\" style=\"line-height: 1.25rem;\"></div>\n    </div>\n  </div>\n\n  <div id=\"menu\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-3 flex-shrink-0\">\n    <div class=\"space-y-3\">\n      <div class=\"flex items-start gap-3\">\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">zoom</div>\n          <div class=\"flex items-center gap-1 w-full justify-between\">\n            <button id=\"zoomOutBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">‚àí</button>\n            <div id=\"zoomLevel\" class=\"text-xs text-neutral-300 tabular-nums px-2\">100%</div>\n            <button id=\"zoomInBtn\" class=\"w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center\">+</button>\n          </div>\n        </div>\n        <div class=\"space-y-2 flex-1\">\n          <div class=\"text-xs text-neutral-500 tracking-wider px-1\">settings</div>\n          <label class=\"flex items-center gap-2 px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors cursor-pointer\">\n            <input id=\"disastersToggle\" type=\"checkbox\" checked class=\"w-4 h-4 accent-green-600\">\n            <span>disasters</span>\n          </label>\n        </div>\n      </div>\n      <div class=\"flex items-center gap-2\">\n        <button id=\"aiSuggestBtn\" class=\"flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors flex items-center justify-center gap-2\">\n          <span>ask AI mayor</span>\n        </button>\n        <button id=\"newCityBtn\" class=\"flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors\">\n          new city\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"newGamePanel\" class=\"hidden border-b border-neutral-700 bg-neutral-800 p-4 flex-shrink-0\">\n    <div class=\"max-w-md mx-auto space-y-3\">\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">city name</label>\n        <input id=\"newCityName\" type=\"text\" value=\"\" placeholder=\"new city\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none focus:border-neutral-500\">\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">terrain type</label>\n        <select id=\"terrainType\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"balanced\">balanced</option>\n          <option value=\"island\">island</option>\n          <option value=\"valley\">valley</option>\n          <option value=\"plains\">plains</option>\n        </select>\n      </div>\n      <div>\n        <label class=\"text-xs text-neutral-400 block mb-1\">difficulty</label>\n        <select id=\"difficulty\" class=\"w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none\">\n          <option value=\"easy\">easy ($100k)</option>\n          <option value=\"normal\" selected>normal ($50k)</option>\n          <option value=\"hard\">hard ($20k)</option>\n        </select>\n      </div>\n      <button id=\"startGameBtn\" class=\"w-full bg-green-700 hover:bg-green-600 text-white px-4 py-2 rounded text-sm transition-colors\">\n        start game\n      </button>\n    </div>\n  </div>\n\n  <div class=\"flex-1 overflow-hidden flex\">\n    <div id=\"grid\" class=\"flex-1 overflow-auto p-4 relative\">\n      <canvas id=\"canvas\" class=\"rounded\" style=\"image-rendering: pixelated;\"></canvas>\n    </div>\n\n    <div class=\"flex flex-shrink-0 relative\" style=\"overflow: visible;\">\n      <div id=\"subToolbar\" class=\"hidden absolute right-[calc(100%+1px)] w-14 border-r border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto rounded-lg z-10\" style=\"overflow-x: visible;\"></div>\n      <div class=\"w-14 border-l border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto flex-shrink-0\" id=\"mainToolbar\" style=\"overflow-x: visible;\">\n        <button data-tool=\"road\" data-tooltip=\"road\" data-shortcut=\"R\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üõ£Ô∏è</button>\n        <button data-tool=\"residential\" data-tooltip=\"residential\" data-shortcut=\"H\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè†</button>\n        <button data-tool=\"commercial\" data-tooltip=\"commercial\" data-shortcut=\"C\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè¢</button>\n        <button data-tool=\"industrial\" data-tooltip=\"industrial\" data-shortcut=\"I\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üè≠</button>\n        <div class=\"w-full flex flex-col\">\n          <div class=\"h-1\"></div>\n          <div class=\"h-px w-full bg-neutral-700\"></div>\n          <div class=\"h-1\"></div>\n        </div>\n        <button data-submenu=\"power\" data-tooltip=\"energy\" data-shortcut=\"E\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">‚ö°</button>\n        <button data-submenu=\"services\" data-tooltip=\"services\" data-shortcut=\"S\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üèõÔ∏è</button>\n        <button data-submenu=\"park\" data-tooltip=\"park\" data-shortcut=\"P\" class=\"tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\">üå≥</button>\n        <div class=\"w-full flex flex-col\">\n          <div class=\"h-1\"></div>\n          <div class=\"h-px w-full bg-neutral-700\"></div>\n          <div class=\"h-1\"></div>\n        </div>\n        <button data-submenu=\"disaster\" data-tooltip=\"disasters\" data-shortcut=\"W\" class=\"disaster-btn tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center\" style=\"display: none;\">‚ö†Ô∏è</button>\n        <button data-tool=\"bulldoze\" data-tooltip=\"demolish\" data-shortcut=\"D\" class=\"tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center\">üí•</button>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"aiPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0\">\n    <div class=\"flex items-start gap-2 mb-2\">\n      <div class=\"flex-1\">\n        <div class=\"text-xs text-yellow-500 mb-1\">AI Mayor</div>\n        <div id=\"aiMessage\" class=\"text-sm text-neutral-300 leading-relaxed\"></div>\n      </div>\n      <button id=\"closeAiBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n    </div>\n  </div>\n  <!-- Building info panel for stat view -->\n  <div id=\"buildingInfoPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 flex-shrink-0\">\n    <div class=\"flex items-start gap-2\">\n      <div class=\"flex-1\">\n        <div id=\"buildingInfoTitle\" class=\"text-sm font-bold text-white mb-2\"></div>\n        <div id=\"buildingInfoContent\" class=\"text-xs text-neutral-300 space-y-1\"></div>\n      </div>\n    </div>\n  </div>\n\n  <div id=\"infoPanel\" class=\"hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0\">\n    <div class=\"flex items-start gap-2 mb-2\">\n      <div class=\"flex-1\">\n        <div class=\"text-xs text-blue-400 mb-1\" id=\"infoTitle\">Info</div>\n        <div id=\"infoContent\" class=\"text-sm text-neutral-300 leading-relaxed space-y-1\"></div>\n      </div>\n      <button id=\"closeInfoBtn\" class=\"text-xs text-neutral-500 hover:text-neutral-300\">‚úï</button>\n    </div>\n  </div>\n\n\n\n  <div class=\"border-t border-neutral-700 bg-neutral-800 px-3 py-2 text-xs text-neutral-400 flex items-center justify-between flex-shrink-0\">\n    <div id=\"statusText\">select a tool to start building</div>\n    <div id=\"costText\" class=\"text-neutral-500\"></div>\n  </div>\n</div>\n\n<style>\n@keyframes tickerRollUp {\n  0% { transform: translateY(0); opacity: 1; }\n  100% { transform: translateY(-100%); opacity: 0; }\n}\n@keyframes shake {\n  0%, 100% { transform: translate(0, 0); }\n  10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 1px); }\n  20%, 40%, 60%, 80% { transform: translate(2px, -1px); }\n}\n.ticker-roll { animation: tickerRollUp 0.5s ease-out forwards; }\n.earthquake { animation: shake 0.5s ease-in-out; }\n.tool-btn {\n  transition: opacity 0.2s ease, background-color 0.2s ease;\n  position: relative;\n}\n.tooltip {\n  position: fixed;\n  background-color: rgb(30, 30, 30);\n  color: rgb(229, 229, 229);\n  padding: 4px 8px;\n  border-radius: 4px;\n  font-size: 12px;\n  white-space: nowrap;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s ease;\n  z-index: 10000;\n  border: 1px solid rgb(64, 64, 64);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n}\n.tooltip.show {\n  opacity: 1;\n}\n.tooltip-shortcut {\n  color: rgb(163, 163, 163);\n  margin-left: 6px;\n}\n@media (hover: hover) and (pointer: fine) {\n  .tool-btn:hover { background-color: rgb(64, 64, 64); opacity: 1 !important; }\n  .tool-btn[data-tool=\"bulldoze\"]:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }\n  .tool-btn.submenu-active:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }\n}\n</style>\n\n<script>\nconst GR_SZ = 32, CL_SZ = 16;\nlet TK_INT = 2000, tkTmr = null, aiReq = false, edtNm = false, nwsIdx = 0, tkrTmr = null, trans = false, nwsQ = [];\nconst COSTS = {road:100,residential:500,commercial:800,industrial:1000,park:300,park2:300,park3:300,park4:300,police:2000,fire:2000,school:3000,hospital:4000,coal:5000,nuclear:10000,wind:3000};\n\n// Power generation amounts per plant (further boosted output for each type)\nconst POWER_GENERATION = {coal:120,nuclear:320,wind:80};\n\n// Power consumption per building type and level\nfunction getPowerConsumption(buildingType, level) {\n  if (buildingType === 'residential') {\n    if (level === 2) return 5;\n    if (level === 3) return 10;\n    return 0; // L1 residential doesn't need power\n  } else if (buildingType === 'commercial') {\n    if (level === 1) return 10;\n    if (level === 2) return 20;\n    if (level === 3) return 30;\n    return 0;\n  } else if (buildingType === 'industrial') {\n    if (level === 1) return 15;\n    if (level === 2) return 30;\n    if (level === 3) return 45;\n    return 0;\n  }\n  return 0;\n}\nfunction getPowerSummary() {\n  let totalPowerGeneration=0;\n  let totalPowerDemand=0;\n  let totalPowerAllocated=0;\n  const processedPlants=new Set();\n  const processedBuildings=new Set();\n  const assignments=st.buildingPowerAssignments||{};\n\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell=st.grid[y][x];\n      if (!cell) continue;\n\n      if (cell.type==='coal'||cell.type==='nuclear'||cell.type==='wind') {\n        const key=getBuildingPowerKey(x,y);\n        if (!key || processedPlants.has(key)) continue;\n        processedPlants.add(key);\n        totalPowerGeneration+=POWER_GENERATION[cell.type]||0;\n        continue;\n      }\n\n      if (!(cell.type==='residential'||cell.type==='commercial'||cell.type==='industrial')) continue;\n      const buildingKey=getBuildingPowerKey(x,y);\n      if (!buildingKey || processedBuildings.has(buildingKey)) continue;\n      processedBuildings.add(buildingKey);\n\n      const consumption=getPowerConsumption(cell.type,cell.level||0);\n      if (consumption<=0) continue;\n      totalPowerDemand+=consumption;\n      if (assignments[buildingKey]) {\n        totalPowerAllocated+=consumption;\n      }\n    }\n  }\n\n  return {\n    generation: totalPowerGeneration,\n    demand: totalPowerDemand,\n    allocated: totalPowerAllocated,\n    surplus: totalPowerGeneration - totalPowerDemand\n  };\n}\nconst LAND_VALUE_LOW_COLOR = {r:250,g:204,b:21};\nconst LAND_VALUE_HIGH_COLOR = {r:34,g:197,b:94};\nconst STATION_MAX_ACTIVE = 2;\n\nlet st = {cityName:'new city',money:50000,population:0,happiness:70,grid:[],terrain:[],landValue:[],crime:[],crimeEvents:[],selectedTool:null,tickCount:0,speed:3000,rDemand:50,cDemand:50,iDemand:50,year:1990,newsEvents:[],ticksSinceNews:0,fires:[],employment:0,cars:[],zoom:1.5,disastersEnabled:true,stationDispatches:{},taxRate:10,powerGrid:[],buildingPowerAssignments:{}};\nlet nextBuildingId = 1;\nlet showLandValueOverlay = false;\nlet showCrimeOverlay = false;\nlet highlightedBuilding = null; // {x, y, w, h} of highlighted building\n\nconst cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d');\ncvs.width = GR_SZ * CL_SZ; cvs.height = GR_SZ * CL_SZ;\n\nfunction genTerr(t) {\n  const tr = [];\n  for (let y=0; y<GR_SZ; y++) { const r=[]; for (let x=0; x<GR_SZ; x++) r.push('grass'); tr.push(r); }\n  if (t==='island') {\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const dx=x-GR_SZ/2, dy=y-GR_SZ/2, d=Math.sqrt(dx*dx+dy*dy), n=(Math.sin(x*0.3)+Math.cos(y*0.3))*2;\n      if (d+n>GR_SZ/2.3) tr[y][x]='water';\n    }\n    for (let i=0; i<3; i++) {\n      const cx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), cy=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-cx, dy=y-cy, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<3 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  } else if (t==='valley') {\n    for (let y=0; y<GR_SZ; y++) {\n      const cd=Math.abs(y-GR_SZ/2), th=GR_SZ/4+Math.sin(y*0.2)*2;\n      if (cd>th) for (let x=0; x<GR_SZ; x++) tr[y][x]='cliff';\n    }\n    const ry=Math.floor(GR_SZ/2);\n    for (let x=0; x<GR_SZ; x++) {\n      const of=Math.floor(Math.sin(x*0.3)*3), r=ry+of;\n      if (r>=0 && r<GR_SZ) { tr[r][x]='water'; if (r-1>=0 && Math.random()<0.5) tr[r-1][x]='water'; if (r+1<GR_SZ && Math.random()<0.5) tr[r+1][x]='water'; }\n    }\n  } else if (t==='plains') {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<4) tr[y][x]='water';\n      }\n    }\n  } else {\n    for (let i=0; i<2; i++) {\n      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;\n        if (d+n<3.5) tr[y][x]='water';\n      }\n    }\n    for (let i=0; i<2; i++) {\n      const mx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), my=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        const dx=x-mx, dy=y-my, d=Math.sqrt(dx*dx+dy*dy);\n        if (d<2.5 && tr[y][x]==='grass') tr[y][x]='cliff';\n      }\n    }\n  }\n  return tr;\n}\n\n// Helper function to ensure empty cells are always 1x1\nfunction normalizeEmptyCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return;\n  const c=st.grid[y][x];\n  if (c.type==='empty' && ((c.w||1)!==1 || (c.h||1)!==1)) {\n    st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n  }\n}\n  \n  function snapCenterToPixelGrid(value, halfSize) {\n    const fractional = halfSize - Math.floor(halfSize);\n    if (Math.abs(fractional) < 1e-6) return Math.round(value);\n    return Math.round(value - fractional) + fractional;\n  }\n\nfunction initGr(tt='balanced') {\n  st.grid=[]; st.terrain=genTerr(tt); st.landValue=[]; st.crime=[]; st.fires=[]; st.cars=[]; st.crimeEvents=[]; st.stationDispatches={};\n  st.powerGrid=[];\n  st.buildingPowerAssignments={};\n  for (let y=0; y<GR_SZ; y++) {\n    const r=[], vr=[], cr=[], pg=[];\n    for (let x=0; x<GR_SZ; x++) { r.push({type:'empty',age:0,level:0,w:1,h:1,buildingId:null}); vr.push(50); cr.push(30); pg.push(false); }\n    st.grid.push(r); st.landValue.push(vr); st.crime.push(cr); st.powerGrid.push(pg);\n  }\n}\n\nfunction sv() { try { localStorage.setItem('simcity_state',JSON.stringify(st)); } catch(e) {} }\nfunction ld() {\n  try {\n    const s=localStorage.getItem('simcity_state');\n    if (s) {\n      const p=JSON.parse(s);\n        if (p.grid && p.grid.length===GR_SZ) {\n        st=p;\n        if (!st.rDemand) st.rDemand=50; if (!st.cDemand) st.cDemand=50; if (!st.iDemand) st.iDemand=50;\n        if (!st.year) st.year=1990; if (!st.newsEvents) st.newsEvents=[]; if (!st.ticksSinceNews) st.ticksSinceNews=0;\n        if (st.taxRate===undefined) st.taxRate=10; // Default 10% tax rate\n        if (!st.terrain) st.terrain=genTerr('balanced'); if (!st.landValue) { st.landValue=[]; for (let y=0; y<GR_SZ; y++) { const vr=[]; for (let x=0; x<GR_SZ; x++) vr.push(50); st.landValue.push(vr); } }\n        if (!st.crime) { st.crime=[]; for (let y=0; y<GR_SZ; y++) { const cr=[]; for (let x=0; x<GR_SZ; x++) cr.push(30); st.crime.push(cr); } }\n          if (!st.fires) st.fires=[]; if (!st.employment) st.employment=0; if (!st.cars) st.cars=[]; if (!st.crimeEvents) st.crimeEvents=[];\n          st.stationDispatches={};\n          if (st.cars && st.cars.length>0) {\n            st.cars.forEach(car => {\n              if (car.stationKey) incrementStationDispatchCount(car.stationKey);\n            });\n          }\n        if (!st.zoom) st.zoom=1;\n        if (st.disastersEnabled === undefined) st.disastersEnabled = true;\n        if (!st.powerGrid) {\n          st.powerGrid = [];\n          for (let y=0; y<GR_SZ; y++) {\n            const pg = [];\n            for (let x=0; x<GR_SZ; x++) pg.push(false);\n            st.powerGrid.push(pg);\n          }\n        }\n          if (!st.buildingPowerAssignments) st.buildingPowerAssignments = {};\n        for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) { \n          if (!st.grid[y][x].level) st.grid[y][x].level=0; \n          if (!st.grid[y][x].w) st.grid[y][x].w=1; \n          if (!st.grid[y][x].h) st.grid[y][x].h=1; \n          // Normalize empty cells to ensure they're always 1x1\n          if (st.grid[y][x].type==='empty') normalizeEmptyCell(x,y);\n        }\n\n        // Rebuild buildingId metadata after loading to ensure consistent grouping\n        rebuildBuildingIdsFromGrid();\n        // Recalculate power grid after loading\n        calculatePowerGrid();\n        return true;\n      }\n    }\n  } catch(e) {}\n  return false;\n}\n\nfunction isRd(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].type==='road'; }\nfunction getRdNb(x,y) { return {top:isRd(x,y-1),right:isRd(x+1,y),bottom:isRd(x,y+1),left:isRd(x-1,y)}; }\n\nfunction drRd(px,py,nb) {\n  ctx.fillStyle='#3a3a3a'; ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);\n  ctx.fillStyle='#4a4a4a';\n  if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }\n  else if (rc===3) {\n    if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }\n    else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }\n    else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n  } else if (rc===2) {\n    if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n    else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }\n    else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }\n    else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }\n  } else if (rc===1) {\n    if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n    else { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }\n  } else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }\n}\nfunction drTl(x,y,tp,lv,ab,w,h) {\n  const px=x*CL_SZ, py=y*CL_SZ, wd=w*CL_SZ, ht=h*CL_SZ, tr=st.terrain[y][x];\n  const c = st.grid[y][x];\n  \n  // Check if building needs power but doesn't have it\n  let needsPowerButNoPower = false;\n  if (!ab && (tp === 'residential' || tp === 'commercial' || tp === 'industrial')) {\n      const level = lv || 0;\n      const needsPower = getPowerConsumption(tp, level) > 0;\n      if (needsPower) {\n        const hasPower = hasPowerAccess(x, y);\n        if (!hasPower) {\n          needsPowerButNoPower = true;\n        }\n      }\n    }\n  if (tp==='empty') {\n    if (tr==='water') ctx.fillStyle='#1e40af'; \n    else if (tr==='cliff') ctx.fillStyle='#3e2723'; \n    else ctx.fillStyle='#2d5016';\n    ctx.fillRect(px,py,CL_SZ,CL_SZ);\n  } else if (tp==='road') { \n    const nb=getRdNb(x,y); drRd(px,py,nb); \n  }\n  else if (tp==='residential') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,124,89,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-6, bh=ht-6; \n      ctx.fillRect(px+3,py+5,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+3,py+5,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+Math.floor(5+bh*0.35),2,2); \n      ctx.fillRect(px+9,py+Math.floor(5+bh*0.35),2,2); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(5+bh*0.35),2,2); \n    }\n    else {\n      // For 2x2 buildings, make them grow taller with level\n      const sz=w===2&&h===2?(lv===3?wd-3:(lv===2?wd-3.5:wd-4)):w===2?wd-4:(lv===1?8:(lv===3?10:10));\n      const of=w===2&&h===2?(lv===3?1.5:(lv===2?1.75:2)):w===2?2:(lv===1?4:(lv===3?3:3));\n      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-7)):w===2?ht-7:(lv===1?8:(lv===3?12:(lv===2?14:11)));\n      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:6)):w===1&&h===1?(lv===3?2:(lv===2?1:7)):6;\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#22c55e':(lv===2?'#16a34a':'#15803d')):w===2?'#16a34a':(lv===3?'#1a9e4a':(lv===2?'#16a34a':'#15803d')); \n      ctx.fillRect(px+of,py+yo,sz,bh);\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#16a34a':(lv===2?'#15803d':'#166534')):w===2?'#15803d':(lv===3?'#15803d':'#15803d'); \n      const roofHeight=w===2&&h===2&&lv===1?0.18:0.25;\n      ctx.fillRect(px+of,py+yo,sz,Math.floor(bh*roofHeight));\n      if (lv>=2 || w===2) {\n        ctx.fillStyle='#4ade80';\n        const wh=2, ww=2, gap=1;\n        const floors=w===2&&h===2?(lv===3?4:(lv===2?3:2)):w===2&&h===1?1:(lv===3?2:(lv===2?2:1));\n        const winStart=w===2&&h===2?0.35:0.4;\n        for (let f=0; f<floors; f++) {\n          const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));\n          ctx.fillRect(px+5,wy,ww,wh); \n          ctx.fillRect(px+9,wy,ww,wh);\n          if (w===2) { \n            ctx.fillRect(px+20,wy,ww,wh); \n            ctx.fillRect(px+24,wy,ww,wh); \n          }\n        }\n      } else if (lv===1) {\n        ctx.fillStyle='#4ade80';\n        const winStart=w===2&&h===2?0.35:0.4;\n        const wy = py+Math.floor(yo+bh*winStart);\n        ctx.fillRect(px+5,wy,2,2); \n        ctx.fillRect(px+9,wy,2,2);\n      }\n      ctx.fillStyle='#166534'; \n      if (w===1&&h===1&&lv===1) {\n        ctx.fillRect(px+7,py+ht-3,2,3);\n      } else if (w===1&&h===2) {\n        // For 1x2 buildings, position door at bottom of building, centered\n        ctx.fillRect(px+7,py+yo+bh-3,2,3);\n      } else {\n        ctx.fillRect(px+6,py+ht-3,3,3); \n      }\n      if (w===2) ctx.fillRect(px+21,py+ht-3,3,3);\n      // Add yard decorations for 1x2 tiles\n      if (w===1&&h===2&&!ab) {\n        ctx.fillStyle='#15803d';\n        ctx.fillRect(px+3,py+ht-6,2,2); // Small bush left\n        ctx.fillRect(px+11,py+ht-6,2,2); // Small bush right\n        // Add more for higher levels\n        if (lv>=2) {\n          ctx.fillStyle='#16a34a';\n          ctx.fillRect(px+1,py+ht-8,2,2); // Extra bush left\n          ctx.fillRect(px+13,py+ht-8,2,2); // Extra bush right\n        }\n        if (lv>=3) {\n          ctx.fillStyle='#4ade80';\n          ctx.fillRect(px+7,py+ht-7,2,1); // Accent center\n        }\n      }\n    }\n  } else if (tp==='commercial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(74,107,138,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-4; \n      ctx.fillRect(px+2,py+4,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+4,bw,Math.floor(bh*0.25)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+4,py+Math.floor(4+bh*0.4),3,3); \n      ctx.fillRect(px+9,py+Math.floor(4+bh*0.4),3,3); \n      if (w===2) ctx.fillRect(px+20,py+Math.floor(4+bh*0.4),3,3); \n    }\n    else {\n      // For 2x2 buildings, make them grow taller with level\n      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-9)):w===2||h===2?ht-3:(lv===1?9:(lv===2?11:13));\n      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:8)):w===2||h===2?2:(lv===1?6:(lv===2?4:1));\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')):w===2||h===2?'#2563eb':(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')); \n      ctx.fillRect(px+2,py+yo,wd-4,bh);\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#2563eb':(lv===2?'#1e40af':'#1d4ed8')):w===2||h===2?'#1e40af':(lv===3?'#2563eb':'#1e40af'); \n      ctx.fillRect(px+2,py+yo,wd-4,Math.floor(bh*0.25));\n      ctx.fillStyle='#87ceeb';\n      const wh=3, ww=3, gap=1;\n      const floors=w===2&&h===2?(lv===3?3:(lv===2?3:1)):w===2&&h===1?1:(w===2||h===2?2:1);\n      const winStart=w===2&&h===2?0.35:0.4;\n      for (let f=0; f<floors; f++) {\n        const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));\n        ctx.fillRect(px+4,wy,ww,wh); \n        ctx.fillRect(px+9,wy,ww,wh);\n        if (w===2) { \n          ctx.fillRect(px+20,wy,ww,wh); \n          ctx.fillRect(px+25,wy,ww,wh); \n        }\n      }\n      ctx.fillStyle='#1e3a8a'; \n      ctx.fillRect(px+6,py+ht-4,4,4); \n      if (w===2) ctx.fillRect(px+22,py+ht-4,4,4);\n    }\n  } else if (tp==='industrial') {\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    if (lv===0) { \n      ctx.fillStyle='rgba(138,124,74,0.5)';\n      const squareSize = Math.min(wd, ht) - 4;\n      const squareX = px + (wd - squareSize) / 2;\n      const squareY = py + (ht - squareSize) / 2;\n      ctx.fillRect(squareX, squareY, squareSize, squareSize); \n    }\n    else if (ab) { \n      ctx.fillStyle='#4a4a4a'; \n      const bw=wd-4, bh=ht-6; \n      ctx.fillRect(px+2,py+6,bw,bh); \n      ctx.fillStyle='#3a3a3a'; \n      ctx.fillRect(px+2,py+6,bw,Math.floor(bh*0.4)); \n      ctx.fillStyle='#2a2a2a'; \n      ctx.fillRect(px+5,py+11,2,2); \n      ctx.fillRect(px+9,py+11,2,2); \n      if (w===2) ctx.fillRect(px+21,py+11,2,2); \n    }\n    else {\n      // For 2x2 buildings, grow taller with level\n      const bh=w===2&&h===2?(lv===3?ht-2:(lv===2?ht-3:ht-4)):w===2?ht-4:(lv===1?8:(lv===2?10:11));\n      const yo=w===2&&h===2?(lv===3?2:(lv===2?2.5:3)):w===2?3:(lv===1?5:(lv===2?4:3));\n      // Main building body\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')):w===2?'#ca8a04':(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')); \n      ctx.fillRect(px+2,py+yo+1,wd-4,bh);\n      // Slanted roof (darker top section)\n      ctx.fillStyle=w===2&&h===2?(lv===3?'#ca8a04':(lv===2?'#a16207':'#854d0e')):w===2?'#a16207':(lv===3?'#ca8a04':'#854d0e'); \n      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));\n      // Chimney structure\n      ctx.fillStyle='#6b4423'; \n      const ch=w===2&&h===2?(lv===3?8:(lv===2?7:6)):lv===3?6:5; \n      ctx.fillRect(px+4,py+yo-ch+1,2,ch); \n      if (w===2) ctx.fillRect(px+26,py+yo-ch+1,2,ch);\n      // Chimney top cap\n      ctx.fillStyle='#854d0e'; \n      ctx.fillRect(px+3,py+yo-ch+1,4,1); \n      if (w===2) ctx.fillRect(px+25,py+yo-ch+1,4,1);\n      // Smoke from chimney\n      ctx.fillStyle='#9ca3af'; \n      ctx.fillRect(px+4,py+yo-ch,1,1); \n      ctx.fillRect(px+5,py+yo-ch-1,1,1); \n      if (w===2) { \n        ctx.fillRect(px+26,py+yo-ch,1,1); \n        ctx.fillRect(px+27,py+yo-ch-1,1,1); \n      }\n      // Windows\n      ctx.fillStyle='#fde047'; \n      if (w===2 && h===2) {\n        // More windows for higher level 2x2 buildings\n        const rows=lv===3?3:(lv===2?2:2);\n        for (let r=0; r<rows; r++) {\n          const wy = py+yo+Math.floor(bh*0.35)+(r*5);\n          ctx.fillRect(px+5,wy,2,2); \n          ctx.fillRect(px+9,wy,2,2); \n          ctx.fillRect(px+21,wy,2,2); \n          ctx.fillRect(px+25,wy,2,2);\n        }\n      } else {\n        // Single row of windows for smaller buildings\n        ctx.fillRect(px+5,py+yo+Math.floor(bh*0.55),2,2); \n        ctx.fillRect(px+9,py+yo+Math.floor(bh*0.55),2,2); \n        if (w===2) { \n          ctx.fillRect(px+21,py+yo+Math.floor(bh*0.55),2,2); \n          ctx.fillRect(px+25,py+yo+Math.floor(bh*0.55),2,2); \n        }\n      }\n      // Entrance/door\n      ctx.fillStyle='#713f12'; \n      ctx.fillRect(px+6,py+ht-3,4,3); \n      if (w===2) ctx.fillRect(px+22,py+ht-3,4,3);\n    }\n  } else if (tp.startsWith('park')) {\n    const bc=tp==='park'?'#1d6b2e':(tp==='park2'?'#2a5a3a':(tp==='park3'?'#1a5a2a':'#2d6b1e'));\n    ctx.fillStyle=bc; ctx.fillRect(px,py,wd,ht);\n    if (tp==='park') { \n      ctx.fillStyle='#2a8f3f'; \n      ctx.fillRect(px+4,py+3,3,3); \n      ctx.fillRect(px+9,py+8,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+5,3,3); \n        ctx.fillRect(px+15,py+20,3,3); \n      } \n      ctx.fillStyle='#165a24'; \n      ctx.fillRect(px+2,py+9,2,2); \n      ctx.fillRect(px+11,py+4,2,2); \n      ctx.fillStyle='#6b4423'; \n      ctx.fillRect(px+7,py+6,2,4); \n      if (w===2||h===2) ctx.fillRect(px+23,py+10,2,4); \n    }\n    else if (tp==='park2') { \n      ctx.fillStyle='#ff69b4'; \n      ctx.fillRect(px+4,py+4,2,2); \n      ctx.fillRect(px+9,py+7,2,2); \n      ctx.fillRect(px+6,py+10,2,2); \n      if (w===2||h===2) { \n        ctx.fillRect(px+20,py+6,2,2); \n        ctx.fillRect(px+25,py+9,2,2); \n        ctx.fillRect(px+17,py+20,2,2); \n      } \n      ctx.fillStyle='#ffc0cb'; \n      ctx.fillRect(px+11,py+5,1,1); \n      ctx.fillRect(px+3,py+8,1,1); \n    }\n    else if (tp==='park3') { \n      ctx.fillStyle='#2d5016'; \n      ctx.fillRect(px+5,py+2,3,4); \n      ctx.fillRect(px+10,py+8,3,4); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+4,3,4); \n        ctx.fillRect(px+16,py+20,3,4); \n      } \n      ctx.fillStyle='#1a4010'; \n      ctx.fillRect(px+3,py+10,2,3); \n      ctx.fillRect(px+12,py+5,2,3); \n    }\n    else { \n      ctx.fillStyle='#ffd700'; \n      ctx.fillRect(px+5,py+5,3,3); \n      ctx.fillRect(px+10,py+9,3,3); \n      if (w===2||h===2) { \n        ctx.fillRect(px+21,py+7,3,3); \n        ctx.fillRect(px+16,py+20,3,3); \n      } \n      ctx.fillStyle='#8b4513'; \n      ctx.fillRect(px+6,py+8,1,3); \n      ctx.fillRect(px+11,py+12,1,3); \n    }\n  } else if (tp==='police') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#000080'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#0000a0'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#ff0000'; ctx.fillRect(px+6,py+5,4,1); \n    ctx.fillStyle='#0000ff'; ctx.fillRect(px+6,py+6,4,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='fire') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#8b0000'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#a00000'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#444444'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); \n    ctx.fillStyle='#ff4500'; ctx.fillRect(px+6,py+5,4,2); \n    ctx.fillStyle='#ffd700'; ctx.fillRect(px+7,py+6,2,1); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='school') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#daa520'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#b8860b'; ctx.fillRect(px+2,py+4,12,4); \n    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+9,py+10,3,3); \n    ctx.fillStyle='#8b4513'; ctx.fillRect(px+4,py+11,3,3); \n  }\n  else if (tp==='hospital') { \n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); \n    ctx.fillStyle='#d1d5db'; ctx.fillRect(px+2,py+4,12,10); \n    ctx.fillStyle='#ff0000'; ctx.fillRect(px+7,py+5,2,5); ctx.fillRect(px+5,py+6,6,2); \n    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); \n  }\n  else if (tp==='coal') {\n    // Background - industrial ground\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-4,wd-2,3);\n    \n    // Main building - dark brown brick structure (2x2)\n    ctx.fillStyle='#5a3a2a'; ctx.fillRect(px+3,py+12,wd-6,ht-13);\n    \n    // Darker roof\n    ctx.fillStyle='#3a2a1a'; ctx.fillRect(px+3,py+12,wd-6,4);\n    \n    // Two smaller brick smoke stacks\n    ctx.fillStyle='#5a3a2a'; \n    ctx.fillRect(px+8,py+6,2,7);\n    ctx.fillRect(px+22,py+6,2,7);\n    \n    // Stack tops/caps\n    ctx.fillStyle='#6a6a6a';\n    ctx.fillRect(px+7,py+6,4,1);\n    ctx.fillRect(px+21,py+6,4,1);\n    \n    // Animated smoke from stacks\n    const smokeAnim = (Date.now() / 300) % 4; // Animate every 300ms\n    const smokeOffset1 = Math.floor(smokeAnim);\n    const smokeOffset2 = Math.floor((smokeAnim + 2) % 4);\n    \n    // Smoke from left stack\n    ctx.fillStyle='rgba(80,80,80,0.6)'; \n    ctx.fillRect(px+8,py+4-smokeOffset1,2,2);\n    ctx.fillStyle='rgba(100,100,100,0.4)';\n    ctx.fillRect(px+7,py+2-smokeOffset1,3,2);\n    ctx.fillStyle='rgba(120,120,120,0.2)';\n    ctx.fillRect(px+6,py+1-smokeOffset1,4,1);\n    \n    // Smoke from right stack\n    ctx.fillStyle='rgba(80,80,80,0.6)'; \n    ctx.fillRect(px+22,py+4-smokeOffset2,2,2);\n    ctx.fillStyle='rgba(100,100,100,0.4)';\n    ctx.fillRect(px+21,py+2-smokeOffset2,3,2);\n    ctx.fillStyle='rgba(120,120,120,0.2)';\n    ctx.fillRect(px+20,py+1-smokeOffset2,4,1);\n    \n    // Windows (dark) - moved down\n    ctx.fillStyle='#2a2a2a'; \n    ctx.fillRect(px+6,py+18,2,2);\n    ctx.fillRect(px+12,py+18,2,2);\n    ctx.fillRect(px+18,py+18,2,2);\n    ctx.fillRect(px+24,py+18,2,2);\n    ctx.fillRect(px+6,py+24,2,2);\n    ctx.fillRect(px+12,py+24,2,2);\n    ctx.fillRect(px+18,py+24,2,2);\n    ctx.fillRect(px+24,py+24,2,2);\n    \n    // Door at bottom center\n    ctx.fillStyle='#1a1a1a';\n    ctx.fillRect(px+14,py+ht-4,4,3);\n  }\n  else if (tp==='nuclear') {\n    // Background - concrete pad\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#6a6a6a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);\n    \n    // Animated steam from cooling tower (draw FIRST, behind dome)\n    const steamAnim = (Date.now() / 400) % 5;\n    const steamOffset = Math.floor(steamAnim);\n    \n    ctx.fillStyle='rgba(255,255,255,0.7)';\n    ctx.fillRect(px+14,py+6-steamOffset,6,3);\n    ctx.fillStyle='rgba(255,255,255,0.5)';\n    ctx.fillRect(px+13,py+3-steamOffset,8,3);\n    ctx.fillStyle='rgba(255,255,255,0.3)';\n    ctx.fillRect(px+12,py+1-steamOffset,10,2);\n    \n    // Large cooling tower dome (2x2) - gray (draw AFTER steam)\n    ctx.fillStyle='#8a8a8a'; \n    ctx.beginPath(); \n    ctx.arc(px+wd/2,py+14,9,0,Math.PI*2); \n    ctx.fill();\n    // Shading on dome\n    ctx.fillStyle='#6a6a6a';\n    ctx.beginPath();\n    ctx.arc(px+wd/2,py+14,9,Math.PI*0.3,Math.PI*0.7);\n    ctx.fill();\n    \n    // Cooling tower base\n    ctx.fillStyle='#7a7a7a'; \n    ctx.fillRect(px+7,py+21,wd-14,7);\n    \n    // Reactor containment building (left) - gray\n    ctx.fillStyle='#7a7a7a'; \n    ctx.fillRect(px+2,py+18,12,10);\n    ctx.fillStyle='#6a6a6a';\n    ctx.fillRect(px+2,py+18,12,4);\n    \n    // Control building (right) - gray\n    ctx.fillStyle='#8a8a8a';\n    ctx.fillRect(px+wd-13,py+20,11,8);\n    ctx.fillStyle='#7a7a7a';\n    ctx.fillRect(px+wd-13,py+20,11,3);\n    \n    // White line accents on buildings\n    ctx.strokeStyle='#ffffff';\n    ctx.lineWidth=1;\n    // Vertical lines on reactor\n    ctx.beginPath();\n    ctx.moveTo(px+6,py+18);\n    ctx.lineTo(px+6,py+28);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(px+10,py+18);\n    ctx.lineTo(px+10,py+28);\n    ctx.stroke();\n    // Horizontal line on control building\n    ctx.beginPath();\n    ctx.moveTo(px+wd-13,py+23);\n    ctx.lineTo(px+wd-2,py+23);\n    ctx.stroke();\n    \n    // Dark windows\n    ctx.fillStyle='#2a2a2a';\n    ctx.fillRect(px+4,py+22,2,2);\n    ctx.fillRect(px+8,py+22,2,2);\n    ctx.fillRect(px+wd-10,py+23,2,2);\n    ctx.fillRect(px+wd-6,py+23,2,2);\n  }\n  else if (tp==='wind') {\n    // Background - grass with service road\n    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);\n    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);\n    \n    // Thin tall tower (1x2 building, so ht = 32)\n    ctx.fillStyle='#d0d0d0'; \n    // Thin tower that gets slightly wider at bottom\n    ctx.fillRect(px+7,py+6,2,ht-9);\n    ctx.fillRect(px+6,py+ht-8,4,5);\n    \n    // Tower shading\n    ctx.fillStyle='#b0b0b0';\n    ctx.fillRect(px+7,py+6,1,ht-9);\n    \n    // Concrete base\n    ctx.fillStyle='#8a8a8a';\n    ctx.fillRect(px+5,py+ht-3,6,2);\n    \n    // Hub at top\n    const hubX = px+8;\n    const hubY = py+6;\n    ctx.fillStyle='#c0c0c0';\n    ctx.beginPath();\n    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);\n    ctx.fill();\n    \n    // Rotating turbine blades\n    // Use Date.now() for smooth continuous animation\n    const rotationSpeed = 0.002; // Adjust for faster/slower rotation\n    const rotation = (Date.now() * rotationSpeed) % (Math.PI * 2);\n    \n    ctx.save();\n    ctx.translate(hubX, hubY);\n    ctx.rotate(rotation);\n    \n    // Three large turbine blades (white) - drawn at 120 degree intervals\n    ctx.fillStyle='#ffffff';\n    ctx.strokeStyle='#b0b0b0';\n    ctx.lineWidth=0.8;\n    \n    for (let i=0; i<3; i++) {\n      ctx.save();\n      ctx.rotate((i * Math.PI * 2 / 3));\n      // Blade pointing upward\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(-1, -6);\n      ctx.lineTo(1, -6);\n      ctx.lineTo(0, 0);\n      ctx.fill();\n      ctx.stroke();\n      ctx.restore();\n    }\n    \n    ctx.restore();\n    \n    // Redraw hub on top of blades\n    ctx.fillStyle='#c0c0c0';\n    ctx.beginPath();\n    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);\n    ctx.fill();\n  }\n  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,wd,ht);\n  \n  // Draw power warning indicator if building needs power but doesn't have it\n  if (needsPowerButNoPower && !ab) {\n    // Flash effect - show bolt every other half-second\n    const flashOn = Math.floor(Date.now() / 500) % 2 === 0;\n    if (flashOn) {\n      ctx.save();\n      // Draw a yellow lightning bolt in the top-right corner\n      const indicatorSize = 10;\n      const indicatorX = px + wd - indicatorSize - 1;\n      const indicatorY = py + 1;\n      \n      // Draw yellow lightning bolt\n      ctx.fillStyle = '#ffff00';\n      ctx.beginPath();\n      // Lightning bolt shape\n      ctx.moveTo(indicatorX + indicatorSize/2 + 2, indicatorY);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 2, indicatorY + indicatorSize/2);\n      ctx.lineTo(indicatorX + indicatorSize/2 + 1, indicatorY + indicatorSize/2);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 3, indicatorY + indicatorSize);\n      ctx.lineTo(indicatorX + indicatorSize/2 + 2, indicatorY + indicatorSize/2 + 2);\n      ctx.lineTo(indicatorX + indicatorSize/2 - 1, indicatorY + indicatorSize/2 + 2);\n      ctx.closePath();\n      ctx.fill();\n      \n      ctx.restore();\n    }\n  }\n}\nfunction drGr() {\n  ctx.clearRect(0,0,cvs.width,cvs.height); const drn={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (drn[k]) continue;\n    const c=st.grid[y][x]; drTl(x,y,c.type,c.level||0,c.abandoned||false,c.w||1,c.h||1);\n    for (let dy=0; dy<(c.h||1); dy++) for (let dx=0; dx<(c.w||1); dx++) drn[`${x+dx},${y+dy}`]=true;\n  }\n  if (showLandValueOverlay) drawLandValueOverlay();\n  if (showCrimeOverlay) drawCrimeOverlay();\n  \n  // Draw placement preview when hovering\n  if (hoverPos && st.selectedTool && st.selectedTool !== 'bulldoze' && !showLandValueOverlay && !showCrimeOverlay) {\n    const x = hoverPos.x, y = hoverPos.y;\n    if (x >= 0 && x < GR_SZ && y >= 0 && y < GR_SZ) {\n      // Determine building size\n      let bw = 1, bh = 1;\n      if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {\n        bw = 2; bh = 2;\n      } else if (st.selectedTool === 'wind') {\n        bw = 1; bh = 2;\n      }\n      \n      // Check if placement is valid\n      let valid = true;\n      const c = st.grid[y][x];\n      const tr = st.terrain[y][x];\n      if (tr === 'water' || tr === 'cliff') valid = false;\n      \n      if (bw > 1 || bh > 1) {\n        for (let dy=0; dy<bh; dy++) {\n          for (let dx=0; dx<bw; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (nx >= GR_SZ || ny >= GR_SZ) { valid = false; break; }\n            const nc = st.grid[ny][nx];\n            const ntr = st.terrain[ny][nx];\n            if (ntr === 'water' || ntr === 'cliff') { valid = false; break; }\n            const isPk = st.selectedTool.startsWith('park');\n            const isZone = nc.type === 'residential' || nc.type === 'commercial' || nc.type === 'industrial';\n            const isEmptyZone = isZone && (nc.level === 0 || nc.abandoned);\n            if (isPk) {\n              if (nc.type !== 'empty' && !isEmptyZone) { valid = false; break; }\n            } else {\n              if (nc.type !== 'empty' && !nc.abandoned) { valid = false; break; }\n            }\n          }\n          if (!valid) break;\n        }\n      } else {\n        const isPk = st.selectedTool.startsWith('park');\n        const isZone = c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial';\n        const isEmptyZone = isZone && (c.level === 0 || c.abandoned);\n        if (isPk) {\n          if (c.type !== 'empty' && !isEmptyZone) valid = false;\n        } else {\n          if (c.type !== 'empty' && !c.abandoned) valid = false;\n        }\n      }\n      \n      // Draw semi-transparent preview\n      if (valid) {\n        ctx.save();\n        const px = x * CL_SZ, py = y * CL_SZ, wd = bw * CL_SZ, ht = bh * CL_SZ;\n        \n        // Draw the actual tile design semi-transparently\n        ctx.globalAlpha = 0.8;\n        drTl(x, y, st.selectedTool, 0, false, bw, bh);\n        ctx.globalAlpha = 1.0;\n        \n        // Draw semi-transparent white border\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(px, py, wd, ht);\n        ctx.restore();\n      }\n    }\n  }\n  \n  // Draw highlighted building border\n  if (highlightedBuilding) {\n    ctx.save();\n    ctx.strokeStyle = '#ffffff';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(\n      highlightedBuilding.x * CL_SZ + 1,\n      highlightedBuilding.y * CL_SZ + 1,\n      highlightedBuilding.w * CL_SZ - 2,\n      highlightedBuilding.h * CL_SZ - 2\n    );\n    ctx.restore();\n  }\n  \n  st.fires.forEach(f => {\n    if (f.age<20) {\n      const fx = f.x * CL_SZ;\n      const fy = f.y * CL_SZ;\n      const anim = f.age % 6;\n      \n      ctx.save();\n      // Draw multiple flame shapes for a more fire-like appearance\n      // Base flame (orange/red)\n      ctx.fillStyle = anim < 3 ? '#ff4500' : '#ff6600';\n      ctx.beginPath();\n      ctx.moveTo(fx + 4, fy + 14);\n      ctx.lineTo(fx + 6, fy + 10);\n      ctx.lineTo(fx + 5, fy + 8);\n      ctx.lineTo(fx + 7, fy + 6);\n      ctx.lineTo(fx + 6, fy + 4);\n      ctx.lineTo(fx + 8, fy + 2);\n      ctx.lineTo(fx + 10, fy + 4);\n      ctx.lineTo(fx + 9, fy + 6);\n      ctx.lineTo(fx + 11, fy + 8);\n      ctx.lineTo(fx + 10, fy + 10);\n      ctx.lineTo(fx + 12, fy + 14);\n      ctx.closePath();\n      ctx.fill();\n      \n      // Middle flame (yellow/orange)\n      ctx.fillStyle = anim < 3 ? '#ff8800' : '#ffaa00';\n      ctx.beginPath();\n      ctx.moveTo(fx + 5, fy + 12);\n      ctx.lineTo(fx + 6.5, fy + 9);\n      ctx.lineTo(fx + 6, fy + 7);\n      ctx.lineTo(fx + 7.5, fy + 5);\n      ctx.lineTo(fx + 7, fy + 3);\n      ctx.lineTo(fx + 9, fy + 3);\n      ctx.lineTo(fx + 8.5, fy + 5);\n      ctx.lineTo(fx + 10, fy + 7);\n      ctx.lineTo(fx + 9.5, fy + 9);\n      ctx.lineTo(fx + 11, fy + 12);\n      ctx.closePath();\n      ctx.fill();\n      \n      // Top flame (yellow/white)\n      ctx.fillStyle = anim < 2 ? '#ffd700' : (anim < 4 ? '#ffff00' : '#ffaa00');\n      ctx.beginPath();\n      ctx.moveTo(fx + 7, fy + 10);\n      ctx.lineTo(fx + 7.5, fy + 7);\n      ctx.lineTo(fx + 7.2, fy + 5);\n      ctx.lineTo(fx + 8, fy + 3);\n      ctx.lineTo(fx + 8.8, fy + 5);\n      ctx.lineTo(fx + 8.5, fy + 7);\n      ctx.lineTo(fx + 9, fy + 10);\n      ctx.closePath();\n      ctx.fill();\n      \n      // Small sparks/flickers\n      ctx.fillStyle = '#ffff00';\n      ctx.fillRect(fx + 6 + (anim % 3), fy + 4, 1, 1);\n      ctx.fillRect(fx + 9 - (anim % 2), fy + 5, 1, 1);\n      \n      ctx.restore();\n    }\n  });\n  st.crimeEvents.forEach(evt => {\n    if (evt.age<20) {\n      const cx = evt.x * CL_SZ;\n      const cy = evt.y * CL_SZ;\n      const anim = evt.age % 4;\n      \n      ctx.save();\n      \n      // Draw pulsing circle (siren effect)\n      const pulseSize = anim < 2 ? 1 : 0.7;\n      ctx.fillStyle = anim < 2 ? 'rgba(220, 20, 60, 0.6)' : 'rgba(255, 0, 0, 0.4)';\n      ctx.beginPath();\n      ctx.arc(cx + 8, cy + 8, 6 * pulseSize, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw siren light (alternating red/blue)\n      ctx.fillStyle = anim < 2 ? '#dc143c' : '#0066ff';\n      ctx.beginPath();\n      ctx.arc(cx + 8, cy + 8, 3, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw exclamation mark\n      ctx.fillStyle = '#ffffff';\n      ctx.fillRect(cx + 7.5, cy + 6, 1, 3);\n      ctx.fillRect(cx + 7.5, cy + 10, 1, 1);\n      \n      // Draw light rays\n      if (anim < 2) {\n        ctx.strokeStyle = 'rgba(220, 20, 60, 0.5)';\n        ctx.lineWidth = 1;\n        for (let i = 0; i < 8; i++) {\n          const angle = (i * Math.PI / 4) + (evt.age * 0.3);\n          ctx.beginPath();\n          ctx.moveTo(cx + 8, cy + 8);\n          ctx.lineTo(cx + 8 + Math.cos(angle) * 8, cy + 8 + Math.sin(angle) * 8);\n          ctx.stroke();\n        }\n      }\n      \n      ctx.restore();\n    }\n  });\n  st.cars.forEach(c => {\n    ctx.save();\n    \n    // Determine car direction for rotation\n    let angle = 0; // Default: horizontal (0 degrees)\n    if (c.path && c.path.length > 1 && c.pathIdx < c.path.length - 1) {\n      const curNode = c.path[c.pathIdx];\n      const nextNode = c.path[c.pathIdx + 1];\n      const dx = nextNode.x - curNode.x;\n      const dy = nextNode.y - curNode.y;\n      \n      // If moving vertically (more vertical than horizontal), rotate 90 degrees\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2; // 90 degrees\n      }\n    } else if (c.entering && c.entryTarget) {\n      // Check direction to entry target\n      const dx = c.entryTarget.x - c.x;\n      const dy = c.entryTarget.y - c.y;\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2;\n      }\n    } else if (c.exiting && c.exitTarget) {\n      // Check direction to exit target\n      const dx = c.exitTarget.x - c.x;\n      const dy = c.exitTarget.y - c.y;\n      if (Math.abs(dy) > Math.abs(dx)) {\n        angle = Math.PI / 2;\n      }\n    } else if (c.path && c.path.length > 0 && c.pathIdx < c.path.length) {\n      // Fallback: check movement direction from current position\n      const nextTarget = getCarSegmentTarget(c);\n      if (nextTarget) {\n        const dx = nextTarget.tx - c.x;\n        const dy = nextTarget.ty - c.y;\n        if (Math.abs(dy) > Math.abs(dx)) {\n          angle = Math.PI / 2;\n        }\n      }\n    }\n    \n      // Translate to car center, rotate, then translate back\n      let carWidth = 3, carHeight = 2;\n      if (c.type === 'fire') {\n        carWidth = 7; // Fire trucks are longer\n        carHeight = 4;\n      } else if (c.type === 'police') {\n        carWidth = 5;\n        carHeight = 4;\n      }\n      const halfWidth = carWidth / 2;\n      const halfHeight = carHeight / 2;\n      let drawX = c.x;\n      let drawY = c.y;\n      let carCenterX = drawX + halfWidth;\n      let carCenterY = drawY + halfHeight;\n      const isVertical = Math.abs(Math.abs(angle) - Math.PI / 2) < 0.001;\n      if (isVertical) {\n        const snappedCenterX = snapCenterToPixelGrid(carCenterX, halfHeight);\n        const snappedCenterY = snapCenterToPixelGrid(carCenterY, halfWidth);\n        drawX += snappedCenterX - carCenterX;\n        drawY += snappedCenterY - carCenterY;\n        carCenterX = snappedCenterX;\n        carCenterY = snappedCenterY;\n      }\n      ctx.translate(carCenterX, carCenterY);\n      ctx.rotate(angle);\n      ctx.translate(-carCenterX, -carCenterY);\n    \n    // Draw emergency vehicles with special styling\n    if (c.type === 'police') {\n      // Police car: dark gray body with single red/blue siren\n      ctx.fillStyle = '#1a1a1a'; // Very dark gray, almost black\n        ctx.fillRect(drawX-1, drawY-1, 5, 4);\n      // Single red/blue alternating siren on top center\n      const time = Date.now() / 200; // Blinking effect\n      const redOn = Math.floor(time) % 2 === 0;\n      ctx.fillStyle = redOn ? '#ff0000' : '#0066ff'; // Red or blue\n        ctx.fillRect(Math.floor(drawX)+1, drawY-1, 2, 1); // Top center siren (2px wide)\n    } else if (c.type === 'fire') {\n      // Fire truck: longer body with single side-mounted flashing siren\n      ctx.fillStyle = '#8b0000';\n        ctx.fillRect(drawX-2, drawY-1, 7, 4); // Longer: 7x4 instead of 5x4\n      // Single side siren (left side) alternating bright red/yellow\n      const time = Date.now() / 200; // Blinking effect\n      const redOn = Math.floor(time) % 2 === 0;\n      ctx.fillStyle = redOn ? '#ff3333' : '#ffff00';\n        ctx.fillRect(drawX-2, drawY, 1, 2); // Vertical bar on left side\n    } else {\n      // Regular cars\n      ctx.fillStyle=c.color;\n        ctx.fillRect(drawX, drawY, 3, 2);\n    }\n    \n    ctx.restore();\n  });\n}\n\nfunction drawLandValueOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getLandValueOverlayColor(st.landValue[y][x]);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getLandValueOverlayColor(value) {\n  const ratio=Math.max(0,Math.min(1,(value||0)/100));\n  const r=Math.round(LAND_VALUE_LOW_COLOR.r+(LAND_VALUE_HIGH_COLOR.r-LAND_VALUE_LOW_COLOR.r)*ratio);\n  const g=Math.round(LAND_VALUE_LOW_COLOR.g+(LAND_VALUE_HIGH_COLOR.g-LAND_VALUE_LOW_COLOR.g)*ratio);\n  const b=Math.round(LAND_VALUE_LOW_COLOR.b+(LAND_VALUE_HIGH_COLOR.b-LAND_VALUE_LOW_COLOR.b)*ratio);\n  return `rgba(${r},${g},${b},0.4)`;\n}\n\nfunction setLandValueOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showLandValueOverlay=true;\n    updLV();\n    drGr();\n    // Update status text to indicate stats mode\n    const sTx = document.getElementById('statusText');\n    sTx.textContent = 'click buildings to view details';\n    return;\n  }\n  if (showLandValueOverlay) {\n    showLandValueOverlay=false;\n    hideBuildingInfo();\n    drGr();\n    // Restore status text\n    const sTx = document.getElementById('statusText');\n    if (st.selectedTool) {\n      const tl = st.selectedTool;\n      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';\n      else {\n        const dn = tl.startsWith('park') ? 'park' : tl;\n        sTx.textContent = `placing ${dn}`;\n      }\n    } else {\n      sTx.textContent = 'select a tool to start building';\n    }\n  }\n}\n\nfunction drawCrimeOverlay() {\n  ctx.save();\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const terrain=st.terrain[y][x];\n      if (terrain==='water'||terrain==='cliff') continue;\n      ctx.fillStyle=getCrimeOverlayColor(st.crime[y][x]||30);\n      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);\n    }\n  }\n  ctx.restore();\n}\n\nfunction getCrimeOverlayColor(value) {\n  const crimeLevel=Math.max(0,Math.min(100,value||30));\n  let r, g, b;\n  if (crimeLevel>=70) {\n    // High crime: red (255,0,0) to dark red (200,0,0)\n    const ratio=(crimeLevel-70)/30;\n    r=Math.round(200+55*ratio);\n    g=0;\n    b=0;\n  } else if (crimeLevel>=30) {\n    // Medium crime: yellow (255,255,0) to red (255,0,0)\n    const ratio=(crimeLevel-30)/40;\n    r=255;\n    g=Math.round(255*(1-ratio));\n    b=0;\n  } else {\n    // Low crime: green (0,255,0) to yellow (255,255,0)\n    const ratio=crimeLevel/30;\n    r=Math.round(255*ratio);\n    g=255;\n    b=0;\n  }\n  return `rgba(${r},${g},${b},0.5)`;\n}\n\nfunction setCrimeOverlay(active) {\n  const enable=!!active;\n  if (enable) {\n    showCrimeOverlay=true;\n    updCrime();\n    drGr();\n    // Update status text to indicate stats mode\n    const sTx = document.getElementById('statusText');\n    sTx.textContent = 'click buildings to view details';\n    return;\n  }\n  if (showCrimeOverlay) {\n    showCrimeOverlay=false;\n    hideBuildingInfo();\n    drGr();\n    // Restore status text\n    const sTx = document.getElementById('statusText');\n    if (st.selectedTool) {\n      const tl = st.selectedTool;\n      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';\n      else {\n        const dn = tl.startsWith('park') ? 'park' : tl;\n        sTx.textContent = `placing ${dn}`;\n      }\n    } else {\n      sTx.textContent = 'select a tool to start building';\n    }\n  }\n}\n\nfunction findPath(sx,sy,ex,ey, maxLength=50) {\n  const q=[{x:sx,y:sy,path:[{x:sx,y:sy}]}], vis=new Set();\n  while(q.length>0) {\n    const cur=q.shift(), k=`${cur.x},${cur.y}`;\n    if (vis.has(k)) continue;\n    vis.add(k);\n    if (cur.x===ex && cur.y===ey) return cur.path;\n    if (cur.path.length>maxLength) continue;\n    const dirs=[[0,-1],[1,0],[0,1],[-1,0]];\n    for (const [dx,dy] of dirs) {\n      const nx=cur.x+dx, ny=cur.y+dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && !vis.has(`${nx},${ny}`)) {\n        if (st.grid[ny][nx].type==='road') {\n          q.push({x:nx,y:ny,path:[...cur.path,{x:nx,y:ny}]});\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction ensureStationDispatchMap() {\n  if (!st.stationDispatches) st.stationDispatches={};\n}\n\nfunction getStationKeyFromCoords(x,y) {\n  return `${x},${y}`;\n}\n\nfunction getStationDispatchCount(key) {\n  ensureStationDispatchMap();\n  return st.stationDispatches[key]||0;\n}\n\nfunction incrementStationDispatchCount(key) {\n  ensureStationDispatchMap();\n  st.stationDispatches[key]=(st.stationDispatches[key]||0)+1;\n}\n\nfunction releaseStationSlot(car) {\n  if (!car || !car.stationKey) return;\n  ensureStationDispatchMap();\n  if (st.stationDispatches[car.stationKey]) {\n    st.stationDispatches[car.stationKey]--;\n    if (st.stationDispatches[car.stationKey]<0) st.stationDispatches[car.stationKey]=0;\n  }\n  car.stationKey=null;\n}\n\nfunction getCurrentRoadNode(car) {\n  if (car && car.path && car.path[car.pathIdx]) return car.path[car.pathIdx];\n  if (car && car.sceneRoad) return car.sceneRoad;\n  if (car && car.stationRoad) return car.stationRoad;\n  return null;\n}\n\nfunction findNearestStation(targetX, targetY, stationType) {\n  // Find nearest road to target location\n  const targetRoads = [];\n  for (let dy = -2; dy <= 2; dy++) {\n    for (let dx = -2; dx <= 2; dx++) {\n      const nx = targetX + dx, ny = targetY + dy;\n      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {\n        if (st.grid[ny][nx].type === 'road') {\n          targetRoads.push({x: nx, y: ny});\n        }\n      }\n    }\n  }\n  if (targetRoads.length === 0) return null;\n  \n  // Find all stations of the requested type\n  const stations = [];\n  for (let y = 0; y < GR_SZ; y++) {\n    for (let x = 0; x < GR_SZ; x++) {\n      const c = st.grid[y][x];\n      if (c.type === stationType && hasRdAcc(x, y)) {\n        // Find nearest road to this station\n        for (let dy = -1; dy <= 1; dy++) {\n          for (let dx = -1; dx <= 1; dx++) {\n            const nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {\n              if (st.grid[ny][nx].type === 'road') {\n                stations.push({stationX: x, stationY: y, roadX: nx, roadY: ny});\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (stations.length === 0) return null;\n  \n  // Find nearest station by pathfinding distance\n  let nearestStation = null;\n  let minDistance = Infinity;\n  \n  // Use a more efficient search - limit pathfinding to reasonable distances for emergency dispatch\n  for (const station of stations) {\n    // Quick distance check first (Manhattan distance) to skip obviously too far stations\n    const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);\n    if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) continue;\n    for (const targetRoad of targetRoads) {\n      const manhattanDist = Math.abs(station.roadX - targetRoad.x) + Math.abs(station.roadY - targetRoad.y);\n      if (manhattanDist > 100) continue; // Skip stations that are clearly too far\n      \n      const path = findPath(station.roadX, station.roadY, targetRoad.x, targetRoad.y, 100);\n      if (path && path.length < minDistance) {\n        minDistance = path.length;\n        nearestStation = {\n          stationX: station.stationX,\n          stationY: station.stationY,\n          roadX: station.roadX,\n          roadY: station.roadY,\n          targetRoadX: targetRoad.x,\n          targetRoadY: targetRoad.y,\n          path: path\n        };\n        // Early exit if we find a very close station (within 10 tiles)\n        if (path.length <= 10) break;\n      }\n    }\n    if (nearestStation && nearestStation.path && nearestStation.path.length <= 10) break;\n  }\n  \n  return nearestStation;\n}\n\nfunction dispatchEmergencyVehicle(stationType, targetX, targetY, missionType) {\n  const station = findNearestStation(targetX, targetY, stationType);\n  if (!station || !station.path || station.path.length < 2) return false;\n  const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);\n  if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) return false;\n  \n  const start = {x: station.roadX, y: station.roadY};\n  const end = {x: station.targetRoadX, y: station.targetRoadY};\n  const path = station.path;\n  \n  // Determine lane offset\n  let laneOffset = 0;\n  const startCenterX = path[0].x * CL_SZ + 7;\n  const startCenterY = path[0].y * CL_SZ + 7;\n  let startX = startCenterX;\n  let startY = startCenterY;\n  \n  if (path.length >= 2) {\n    const dx = path[1].x - path[0].x;\n    const dy = path[1].y - path[0].y;\n    if (Math.abs(dx) > Math.abs(dy)) {\n      laneOffset = dx > 0 ? 5 : -5;\n      startY += laneOffset;\n    } else {\n      laneOffset = dy > 0 ? -5 : 5;\n      startX += laneOffset;\n    }\n  }\n  \n  const stationBuilding = {x: station.stationX, y: station.stationY};\n  const entryDir = getEdgeDirection(stationBuilding, start);\n  let entryTarget = null;\n  let entering = false;\n  let spawnX = startX;\n  let spawnY = startY;\n  \n  if (entryDir.x !== 0 || entryDir.y !== 0) {\n    entering = true;\n    entryTarget = {x: startX, y: startY};\n    if (Math.abs(entryDir.x) >= Math.abs(entryDir.y) && entryDir.x !== 0) {\n      spawnX = startCenterX + entryDir.x * CAR_EDGE_OFFSET;\n      spawnY = startY;\n    } else if (entryDir.y !== 0) {\n      spawnY = startCenterY + entryDir.y * CAR_EDGE_OFFSET;\n      spawnX = startX;\n    }\n  }\n  \n  // Fire trucks: red (will be styled with lights), Police cars: very dark gray (will be styled with lights)\n  const color = stationType === 'fire' ? '#ff0000' : '#1a1a1a';\n  const vehicleType = stationType === 'fire' ? 'fire' : 'police';\n  \n  st.cars.push({\n    x: spawnX,\n    y: spawnY,\n    path: path,\n    pathIdx: 0,\n    color: color,\n    type: vehicleType,\n    laneOffset: laneOffset,\n    reverse: false,\n    entering: entering,\n    entryTarget: entryTarget,\n    exiting: false,\n    exitLaneTarget: null,\n    exitTarget: null,\n    positioningForExit: false,\n    stationRoad: { x: start.x, y: start.y },\n    sceneRoad: { x: end.x, y: end.y },\n    missionPhase: 'enroute',\n    stationKey: stationKey,\n    stationCoords: { x: station.stationX, y: station.stationY },\n    mission: {\n      type: missionType,\n      targetX: targetX,\n      targetY: targetY,\n      arrived: false,\n      returning: false\n    }\n  });\n  incrementStationDispatchCount(stationKey);\n  \n  return true;\n}\n\nfunction getRoadCenterCoords(node) {\n  if (!node) return { x: 0, y: 0 };\n  return { x: node.x * CL_SZ + 7, y: node.y * CL_SZ + 7 };\n}\nfunction prepareEmergencyVehicleReturn(car, opts={}) {\n  if (!car || !car.mission || car.mission.returning) return;\n  \n  const startRoad = getCurrentRoadNode(car);\n  const stationRoad = car.stationRoad;\n  if (!startRoad || !stationRoad) {\n    car.removeOnNextTick = true;\n    releaseStationSlot(car);\n    return;\n  }\n  \n  if (!opts.skipSceneDecrement && car.mission.arrived) {\n    if (car.mission.type === 'fire') {\n      const fire = st.fires.find(f => f.x === car.mission.targetX && f.y === car.mission.targetY);\n      if (fire && fire.fireTrucksAtScene>0) fire.fireTrucksAtScene--;\n    } else if (car.mission.type === 'crime') {\n      const crime = st.crimeEvents.find(evt => evt.x === car.mission.targetX && evt.y === car.mission.targetY);\n      if (crime && crime.policeCarsAtScene>0) crime.policeCarsAtScene--;\n    }\n  }\n  \n  const returnPath = findPath(startRoad.x, startRoad.y, stationRoad.x, stationRoad.y, 100);\n  if (!returnPath || returnPath.length<2) {\n    car.removeOnNextTick = true;\n    releaseStationSlot(car);\n    return;\n  }\n  \n  car.path = returnPath;\n  car.pathIdx = 0;\n  car.mission.returning = true;\n  car.mission.arrived = false;\n  car.missionPhase = 'returning';\n  car.entering = true;\n  car.exiting = false;\n  car.exitTarget = null;\n  car.reverse = false;\n  car.holdPosition = null;\n  \n  const startCenter = getRoadCenterCoords(returnPath[0]);\n  car.x = startCenter.x;\n  car.y = startCenter.y;\n  let entryX = startCenter.x;\n  let entryY = startCenter.y;\n  car.laneOffset = 0;\n  if (returnPath.length>=2) {\n    const dx = returnPath[1].x - returnPath[0].x;\n    const dy = returnPath[1].y - returnPath[0].y;\n    if (Math.abs(dx)>Math.abs(dy)) {\n      car.laneOffset = dx>0 ? 5 : -5;\n      entryY += car.laneOffset;\n    } else {\n      car.laneOffset = dy>0 ? -5 : 5;\n      entryX += car.laneOffset;\n    }\n  }\n  car.entryTarget = { x: entryX, y: entryY };\n\n  const stationBuilding = car.stationCoords || { x: car.stationRoad.x, y: car.stationRoad.y };\n  const endIdx = returnPath.length - 1;\n  const endNode = returnPath[endIdx];\n  const endCenterX = endNode.x * CL_SZ + 7;\n  const endCenterY = endNode.y * CL_SZ + 7;\n  let exitLaneX = endCenterX;\n  let exitLaneY = endCenterY;\n  if (returnPath.length >= 2) {\n    const dxLast = returnPath[endIdx].x - returnPath[endIdx - 1].x;\n    const dyLast = returnPath[endIdx].y - returnPath[endIdx - 1].y;\n    if (Math.abs(dxLast) > Math.abs(dyLast)) {\n      exitLaneY += dxLast > 0 ? 5 : -5;\n    } else {\n      exitLaneX += dyLast > 0 ? -5 : 5;\n    }\n  }\n  const exitDir = getEdgeDirection(stationBuilding, stationRoad);\n  let exitTarget = null;\n  if (exitDir.x !== 0 || exitDir.y !== 0) {\n    exitTarget = { x: exitLaneX, y: exitLaneY };\n    if (Math.abs(exitDir.x) >= Math.abs(exitDir.y) && exitDir.x !== 0) {\n      exitTarget.x = endCenterX + exitDir.x * CAR_EDGE_OFFSET;\n    } else if (exitDir.y !== 0) {\n      exitTarget.y = endCenterY + exitDir.y * CAR_EDGE_OFFSET;\n    }\n  } else {\n    // If no direction detected, use a default offset toward the station\n    exitTarget = { x: exitLaneX, y: exitLaneY };\n    // Try to find direction from road to station building\n    const dx = stationBuilding.x - stationRoad.x;\n    const dy = stationBuilding.y - stationRoad.y;\n    if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) {\n      exitTarget.x = endCenterX + (dx > 0 ? CAR_EDGE_OFFSET : -CAR_EDGE_OFFSET);\n    } else if (dy !== 0) {\n      exitTarget.y = endCenterY + (dy > 0 ? CAR_EDGE_OFFSET : -CAR_EDGE_OFFSET);\n    } else {\n      // Station is on the road tile, just offset slightly\n      exitTarget.x = endCenterX + CAR_EDGE_OFFSET;\n    }\n  }\n  car.exitLaneTarget = { x: exitLaneX, y: exitLaneY };\n  car.exitTarget = exitTarget;\n  car.positioningForExit = false;\n}\n\nfunction sendEmergencyVehiclesHome(missionType, targetX, targetY) {\n  st.cars.forEach(car => {\n    if (!car.mission || car.mission.returning) return;\n    if (car.mission.type===missionType && car.mission.targetX===targetX && car.mission.targetY===targetY) {\n      prepareEmergencyVehicleReturn(car);\n    }\n  });\n}\n  \nfunction attemptMissionArrival(car) {\n  if (!car || !car.mission || car.mission.returning) return false;\n  const buildingTarget = {\n    x: car.mission.targetX * CL_SZ + CL_SZ / 2,\n    y: car.mission.targetY * CL_SZ + CL_SZ / 2\n  };\n  const roadTarget = car.sceneRoad ? getRoadCenterCoords(car.sceneRoad) : null;\n  // Fire and police cars should always stop at the road tile center, no offsets\n  const targetToUse = roadTarget || buildingTarget;\n  if (!targetToUse) return false;\n  const dx = targetToUse.x - car.x;\n  const dy = targetToUse.y - car.y;\n  const dist = Math.sqrt(dx*dx + dy*dy);\n  const threshold = CL_SZ * 2.5;\n  if (dist < threshold) {\n    if (!car.mission.arrived) {\n      car.mission.arrived = true;\n      car.missionPhase = 'onscene';\n        // Police and fire vehicles stop exactly at road tile center, no lane offsets\n        const holdTarget = roadTarget || buildingTarget;\n        if (holdTarget) {\n          car.holdPosition = { x: holdTarget.x, y: holdTarget.y };\n          car.x = car.holdPosition.x;\n          car.y = car.holdPosition.y;\n          // Clear any lane offsets for emergency vehicles\n          if (car.type === 'police' || car.type === 'fire') {\n            car.laneOffset = 0;\n          }\n        } else {\n          car.holdPosition = { x: car.x, y: car.y };\n        }\n      if (!car.arrivalLogged) {\n        if (car.mission.type === 'fire') {\n          const fire = st.fires.find(f => f.x === car.mission.targetX && f.y === car.mission.targetY);\n          if (fire) fire.fireTrucksAtScene = (fire.fireTrucksAtScene || 0) + 1;\n        } else if (car.mission.type === 'crime') {\n          const crime = st.crimeEvents.find(evt => evt.x === car.mission.targetX && evt.y === car.mission.targetY);\n          if (crime) crime.policeCarsAtScene = (crime.policeCarsAtScene || 0) + 1;\n        }\n        car.arrivalLogged = true;\n      }\n    } else if (!car.holdPosition) {\n      car.holdPosition = { x: car.x, y: car.y };\n    }\n    return true;\n  }\n  return false;\n}\n \nfunction countActiveResponders(missionType, targetX, targetY) {\n  if (!st.cars) return 0;\n  return st.cars.reduce((sum, car) => {\n    if (car.mission && !car.mission.returning && car.mission.type===missionType && car.mission.targetX===targetX && car.mission.targetY===targetY) {\n      return sum+1;\n    }\n    return sum;\n  },0);\n}\n\nfunction ensureEmergencyCoverage() {\n  if (st.fires) {\n    st.fires.forEach(fire => {\n      if (countActiveResponders('fire', fire.x, fire.y)===0) {\n        dispatchEmergencyVehicle('fire', fire.x, fire.y, 'fire');\n      }\n    });\n  }\n  if (st.crimeEvents) {\n    st.crimeEvents.forEach(evt => {\n      if (countActiveResponders('crime', evt.x, evt.y)===0) {\n        dispatchEmergencyVehicle('police', evt.x, evt.y, 'crime');\n      }\n    });\n  }\n}\n \nfunction getEdgeDirection(structCell,roadCell) {\n  if (!structCell || !roadCell) return {x:0,y:0};\n  const dx=structCell.x-roadCell.x;\n  const dy=structCell.y-roadCell.y;\n  if (dx===0 && dy===0) return {x:0,y:0};\n  if (Math.abs(dx)>Math.abs(dy)) return {x:dx>0?1:-1,y:0};\n  if (Math.abs(dy)>Math.abs(dx)) return {x:0,y:dy>0?1:-1};\n  if (dx!==0) return {x:dx>0?1:-1,y:0};\n  return {x:0,y:dy>0?1:-1};\n}\n\nfunction spawnCar() {\n  const res=[], com=[], ind=[], pol=[], fir=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && !c.abandoned && hasRdAcc(x,y)) res.push({x,y});\n    else if (c.type==='commercial' && !c.abandoned && hasRdAcc(x,y)) com.push({x,y});\n    else if (c.type==='industrial' && !c.abandoned && hasRdAcc(x,y)) ind.push({x,y});\n    else if (c.type==='police' && hasRdAcc(x,y)) pol.push({x,y});\n    else if (c.type==='fire' && hasRdAcc(x,y)) fir.push({x,y});\n  }\n  if (res.length===0) return;\n  \n  let tp='normal', src, dst, clr;\n  // Emergency vehicles are now dispatched via dispatchEmergencyVehicle(), not spawned randomly\n  // So we only spawn normal civilian cars here\n  {\n    src=res[Math.floor(Math.random()*res.length)];\n    const dests=[...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);\n    if (dests.length===0) return;\n    dst=dests[Math.floor(Math.random()*dests.length)];\n    const rnd=Math.random();\n    if (rnd<0.7) clr='#808080';\n    else if (rnd<0.85) clr='#a0a0a0';\n    else if (rnd<0.95) clr='#606060';\n    else clr=['#ffeb3b','#4caf50','#9c27b0'][Math.floor(Math.random()*3)];\n  }\n  \n  const rdNear=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=src.x+dx, ny=src.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdNear.push({x:nx,y:ny});\n  }\n  if (rdNear.length===0) return;\n  const start=rdNear[Math.floor(Math.random()*rdNear.length)];\n  \n  const rdEnd=[];\n  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {\n    const nx=dst.x+dx, ny=dst.y+dy;\n    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdEnd.push({x:nx,y:ny});\n  }\n  if (rdEnd.length===0) return;\n  const end=rdEnd[Math.floor(Math.random()*rdEnd.length)];\n  \n  const path=findPath(start.x,start.y,end.x,end.y);\n  if (!path || path.length<2) return;\n  \n    // Determine direction: randomly choose forward or reverse\n    const reverse=Math.random()<0.5;\n    const carPath=reverse ? [...path].reverse() : path;\n    const spawnRoad=reverse ? end : start;\n    const exitRoad=reverse ? start : end;\n    const spawnBuilding=reverse ? dst : src;\n    const exitBuilding=reverse ? src : dst;\n    \n    // Determine lane offset based on first segment direction\n    // Cars going in opposite directions should be in opposite lanes\n    let laneOffset=0;\n    const startCenterX=carPath[0].x*CL_SZ+7;\n    const startCenterY=carPath[0].y*CL_SZ+7;\n    let startX=startCenterX;\n    let startY=startCenterY;\n    \n    if (carPath.length>=2) {\n      const dx=carPath[1].x-carPath[0].x;\n      const dy=carPath[1].y-carPath[0].y;\n      \n      if (Math.abs(dx)>Math.abs(dy)) {\n        // Horizontal movement: use y offset for lanes\n        // Left-to-right (dx > 0): bottom lane (+5)\n        // Right-to-left (dx < 0): top lane (-5)\n        laneOffset=dx>0 ? 5 : -5;\n        startY+=laneOffset;\n      } else {\n        // Vertical movement: use x offset for lanes\n        // Ensure right-hand traffic: southbound (dy > 0) stays to the viewer's left (laneOffset = -5)\n        laneOffset=dy>0 ? -5 : 5;\n        startX+=laneOffset;\n      }\n    }\n    \n    const entryDir=getEdgeDirection(spawnBuilding,spawnRoad);\n    let entryTarget=null;\n    let entering=false;\n    let spawnX=startX;\n    let spawnY=startY;\n    if (entryDir.x!==0 || entryDir.y!==0) {\n      entering=true;\n      entryTarget={x:startX,y:startY};\n      if (Math.abs(entryDir.x)>=Math.abs(entryDir.y) && entryDir.x!==0) {\n        spawnX=startCenterX+entryDir.x*CAR_EDGE_OFFSET;\n        spawnY=startY;\n      } else if (entryDir.y!==0) {\n        spawnY=startCenterY+entryDir.y*CAR_EDGE_OFFSET;\n        spawnX=startX;\n      }\n    }\n    \n    const endIdx=carPath.length-1;\n    const endNode=carPath[endIdx];\n    const endCenterX=endNode.x*CL_SZ+7;\n    const endCenterY=endNode.y*CL_SZ+7;\n    let exitLaneX=endCenterX;\n    let exitLaneY=endCenterY;\n    if (carPath.length>=2) {\n      const dxLast=carPath[endIdx].x-carPath[endIdx-1].x;\n      const dyLast=carPath[endIdx].y-carPath[endIdx-1].y;\n      if (Math.abs(dxLast)>Math.abs(dyLast)) {\n        exitLaneY+=dxLast>0 ? 5 : -5;\n      } else {\n        exitLaneX+=dyLast>0 ? -5 : 5;\n      }\n    }\n    const exitDir=getEdgeDirection(exitBuilding,exitRoad);\n    let exitLaneTarget={x:exitLaneX,y:exitLaneY};\n    let exitTarget=null;\n    if (exitDir.x!==0 || exitDir.y!==0) {\n      exitTarget={x:exitLaneX,y:exitLaneY};\n      if (Math.abs(exitDir.x)>=Math.abs(exitDir.y) && exitDir.x!==0) {\n        exitTarget.x=endCenterX+exitDir.x*CAR_EDGE_OFFSET;\n      } else if (exitDir.y!==0) {\n        exitTarget.y=endCenterY+exitDir.y*CAR_EDGE_OFFSET;\n      }\n    }\n    \n    st.cars.push({\n      x:spawnX,\n      y:spawnY,\n      path:carPath,\n      pathIdx:0,\n      color:clr,\n      type:tp,\n      laneOffset:laneOffset,\n      reverse:reverse,\n      entering:entering,\n      entryTarget:entryTarget,\n      exiting:false,\n      exitLaneTarget:exitLaneTarget,\n      exitTarget:exitTarget\n    });\n}\n  \nfunction updCars() {\n  st.cars=st.cars.filter(c => {\n      const finalizeRemoval = () => {\n        if (c.mission && c.mission.returning) releaseStationSlot(c);\n        return false;\n      };\n      if (c.removeOnNextTick) return finalizeRemoval();\n    \n    if (c.mission && !c.mission.returning) {\n      const targetGridX = c.mission.targetX;\n      const targetGridY = c.mission.targetY;\n      let targetExists = false;\n      if (c.mission.type === 'fire') {\n        targetExists = st.fires.some(f => f.x === targetGridX && f.y === targetGridY);\n      } else if (c.mission.type === 'crime') {\n        targetExists = st.crimeEvents.some(evt => evt.x === targetGridX && evt.y === targetGridY);\n      }\n      \n      if (!targetExists) {\n        prepareEmergencyVehicleReturn(c);\n        } else if (!c.mission.arrived) {\n          if (attemptMissionArrival(c)) return true;\n      } else {\n        return true;\n      }\n    }\n    \n    if (c.mission && c.mission.arrived && !c.mission.returning) {\n      if (c.holdPosition) {\n        c.x = c.holdPosition.x;\n        c.y = c.holdPosition.y;\n        // Ensure emergency vehicles stay at exact road center, no offsets\n        if ((c.type === 'police' || c.type === 'fire') && c.sceneRoad) {\n          const exactCenter = getRoadCenterCoords(c.sceneRoad);\n          c.x = exactCenter.x;\n          c.y = exactCenter.y;\n          c.holdPosition = exactCenter;\n          c.laneOffset = 0;\n        }\n      } else if (c.sceneRoad) {\n        const center = getRoadCenterCoords(c.sceneRoad);\n        c.holdPosition = center;\n        c.x = center.x;\n        c.y = center.y;\n        if (c.type === 'police' || c.type === 'fire') {\n          c.laneOffset = 0;\n        }\n      } else {\n        c.holdPosition = { x: c.x, y: c.y };\n      }\n      return true;\n    }\n    \n    let remainingDist=getCarSpeedPerFrame(c);\n    if (remainingDist<=0) return true;\n    \n    // Helper to check if car reached end of path\n    const isAtPathEnd = () => c.pathIdx >= c.path.length - 1;\n    \n    // Helper to initiate exit sequence\n    const startExitSequence = () => {\n      if (c.exitLaneTarget) {\n        c.positioningForExit = true;\n      } else if (c.exitTarget) {\n        c.exiting = true;\n      } else {\n        return false; // No exit sequence available\n      }\n      return true;\n    };\n    \n    while (remainingDist>0) {\n      // Determine target based on current car state\n      let targetStage, tx, ty;\n      \n      if (c.entering && c.entryTarget) {\n        targetStage = 'entry';\n        tx = c.entryTarget.x;\n        ty = c.entryTarget.y;\n      } else if (c.exiting && c.exitTarget) {\n        targetStage = 'exit';\n        tx = c.exitTarget.x;\n        ty = c.exitTarget.y;\n      } else if (c.positioningForExit && c.exitLaneTarget) {\n        targetStage = 'positioning';\n        tx = c.exitLaneTarget.x;\n        ty = c.exitLaneTarget.y;\n      } else {\n        // Handle path-following and end-of-path logic\n        if (isAtPathEnd()) {\n          // Mission vehicles that haven't arrived yet\n          if (c.mission && !c.mission.returning) {\n            if (attemptMissionArrival(c)) return true;\n            c.holdPosition = c.holdPosition || { x: c.x, y: c.y };\n            c.x = c.holdPosition.x;\n            c.y = c.holdPosition.y;\n            return true;\n          }\n          // Start exit sequence or despawn\n          if (!startExitSequence()) {\n            return finalizeRemoval();\n          }\n          continue;\n        }\n        \n        // Normal path following\n        targetStage = 'path';\n        const nextTarget = getCarSegmentTarget(c);\n        tx = nextTarget.tx;\n        ty = nextTarget.ty;\n      }\n      \n      // Move toward target\n      const dx = tx - c.x;\n      const dy = ty - c.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      // Snap to target when very close\n      if (dist < CAR_SNAP_THRESHOLD) {\n        c.x = tx;\n        c.y = ty;\n        \n        // Handle state transitions\n        if (targetStage === 'entry') {\n          c.entering = false;\n          c.entryTarget = null;\n        } else if (targetStage === 'positioning') {\n          c.positioningForExit = false;\n          if (c.exitTarget) {\n            c.exiting = true;\n          } else {\n            return finalizeRemoval();\n          }\n        } else if (targetStage === 'exit') {\n          return finalizeRemoval();\n        } else {\n          // Advance path\n          c.pathIdx++;\n          if (isAtPathEnd()) {\n            if (!startExitSequence()) {\n              return finalizeRemoval();\n            }\n          } else {\n            updateCarLaneOffset(c);\n          }\n        }\n        continue;\n      }\n      \n      // Move step toward target\n      const step = Math.min(dist, remainingDist);\n      c.x += dx / dist * step;\n      c.y += dy / dist * step;\n      remainingDist -= step;\n      \n      if (step < dist) break; // Not enough distance remaining\n    }\n    return true;\n  });\n  \n  const maxCars=Math.min(60,Math.floor(st.population/18)+8);\n  const populationFactor=Math.min(1,st.population/4000);\n  const totalDemand=\n    Math.max(0,(st.rDemand||0))+\n    Math.max(0,(st.cDemand||0))+\n    Math.max(0,(st.iDemand||0));\n  const demandFactor=Math.min(1,totalDemand/400);\n  const spawnChance=Math.min(0.25,0.02+0.1*populationFactor+0.08*demandFactor);\n  if (st.speed>0 && st.population>10 && st.cars.length<maxCars && Math.random()<spawnChance) {\n    spawnCar();\n    if (st.cars.length<maxCars && Math.random()<0.15) spawnCar();\n  }\n}\n\nfunction updInpWd() {\n  const inp=document.getElementById('cityName'), tmp=document.createElement('span');\n  tmp.style.font=window.getComputedStyle(inp).font; tmp.style.visibility='hidden'; tmp.style.position='absolute'; tmp.style.whiteSpace='pre';\n  tmp.textContent=inp.value||inp.placeholder||'new city'; document.body.appendChild(tmp); inp.style.width=(tmp.offsetWidth+8)+'px'; document.body.removeChild(tmp);\n}\n\nfunction shwNxtNws() {\n  if (nwsQ.length>0 && !trans) {\n    const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=nwsQ.shift();\n    if (ot===nt) return;\n    trans=true; tk.classList.add('ticker-roll');\n    setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n      setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n        setTimeout(() => { trans=false; if (nwsQ.length>0) setTimeout(shwNxtNws,100); },500);\n      },10);\n    },500);\n    return;\n  }\n  if (st.newsEvents.length===0||trans) return;\n  const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=st.newsEvents[nwsIdx];\n  if (ot===nt) { nwsIdx=(nwsIdx+1)%st.newsEvents.length; return; }\n  trans=true; tk.classList.add('ticker-roll');\n  setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';\n    setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n      setTimeout(() => { trans=false; },500);\n    },10);\n  },500);\n  nwsIdx=(nwsIdx+1)%st.newsEvents.length;\n}\n\nfunction updNwsTk() {\n  if (tkrTmr) clearInterval(tkrTmr);\n  if (st.newsEvents.length>0 && st.speed>0) {\n    nwsIdx=st.newsEvents.length-1; const tk=document.getElementById('newsTicker');\n    tk.textContent=st.newsEvents[nwsIdx]; tk.style.transform='translateY(0)'; tk.style.opacity='1';\n    nwsIdx=(nwsIdx+1)%st.newsEvents.length; tkrTmr=setInterval(shwNxtNws,5000);\n  } else {\n    const tk=document.getElementById('newsTicker');\n    if (st.speed===0) tk.textContent=st.newsEvents.length>0?st.newsEvents[st.newsEvents.length-1]:'';\n    else if (st.newsEvents.length===0) tk.textContent='';\n    tk.classList.remove('ticker-roll');\n  }\n}\n\nconst STAT_INFO_TYPES = ['rci','pop','money','happy'];\nlet currentInfoType = null;\n\nfunction shwInfo(title,content,infoType) {\n  plySnd('click');\n  const pnl=document.getElementById('infoPanel');\n  \n  // If clicking the same stat, toggle it off\n  if (currentInfoType === infoType && !pnl.classList.contains('hidden')) {\n    pnl.classList.add('hidden');\n    currentInfoType = null;\n    setLandValueOverlay(false);\n    setCrimeOverlay(false);\n    return;\n  }\n  \n  // Otherwise, show the new panel\n  document.getElementById('menu').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoTitle').textContent=title;\n  document.getElementById('infoContent').innerHTML=content;\n  pnl.classList.remove('hidden');\n  currentInfoType = infoType;\n  if (infoType === 'happy') {\n    setLandValueOverlay(false);\n    setCrimeOverlay(true);\n  } else {\n    setCrimeOverlay(false);\n    setLandValueOverlay(STAT_INFO_TYPES.includes(infoType));\n  }\n}\n\nfunction updUI() {\n  const inp=document.getElementById('cityName'); if (!edtNm) { inp.value=st.cityName; updInpWd(); }\n  document.getElementById('population').textContent=st.population.toLocaleString();\n  document.getElementById('money').textContent=`${(st.money/1000).toFixed(0)}k`;\n  document.getElementById('happiness').textContent=st.happiness;\n  \n  // Calculate and update power status\n  const {generation: totalPowerGeneration, demand: totalPowerConsumption, surplus: powerSurplus} = getPowerSummary();\n  const powerEl = document.getElementById('power');\n  powerEl.textContent = `${totalPowerGeneration}/${totalPowerConsumption}`;\n  if (powerSurplus < 0) {\n    powerEl.classList.remove('text-white', 'text-green-400', 'text-yellow-400');\n    powerEl.classList.add('text-red-400');\n  } else {\n    powerEl.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');\n    powerEl.classList.add('text-white');\n  }\n  \n  if (!edtNm) {\n    const month = (st.tickCount % 12) + 1;\n    const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];\n    document.getElementById('yearDisplay').textContent=`${monthNames[month-1]} ${st.year}`;\n  }\n  const mEl=document.getElementById('money');\n  if (st.money<0) { mEl.classList.remove('text-white'); mEl.classList.add('text-red-400'); }\n  else { mEl.classList.remove('text-red-400'); mEl.classList.add('text-white'); }\n  const rB=document.getElementById('rDemand'), cB=document.getElementById('cDemand'), iB=document.getElementById('iDemand');\n  rB.style.height=`${st.rDemand}%`; cB.style.height=`${st.cDemand}%`; iB.style.height=`${st.iDemand}%`;\n  rB.parentElement.style.display='flex'; rB.parentElement.style.flexDirection='column'; rB.parentElement.style.justifyContent='flex-end';\n  cB.parentElement.style.display='flex'; cB.parentElement.style.flexDirection='column'; cB.parentElement.style.justifyContent='flex-end';\n  iB.parentElement.style.display='flex'; iB.parentElement.style.flexDirection='column'; iB.parentElement.style.justifyContent='flex-end';\n  const sBtn=document.getElementById('speedToggle');\n  if (st.speed===0) sBtn.textContent='‚è∏'; else if (st.speed===3000) sBtn.textContent='1x'; else if (st.speed===1500) sBtn.textContent='2x'; else if (st.speed===500) sBtn.textContent='3x';\n}\n\nfunction selTl(tl) {\n  st.selectedTool=tl;\n  updateToolSelection();\n  const c=COSTS[tl]||0, cTx=document.getElementById('costText'), sTx=document.getElementById('statusText');\n  if (tl==='bulldoze') { sTx.textContent='click to demolish buildings'; cTx.textContent=''; }\n  else if (tl) { const dn=tl.startsWith('park')?'park':tl; sTx.textContent=`placing ${dn}`; cTx.textContent=c>0?`$${c.toLocaleString()}`:''; }\n  else { sTx.textContent='select a tool to start building'; cTx.textContent=''; }\n}\nfunction canPlLg(x,y,w,h,zt) {\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=GR_SZ||ny>=GR_SZ) return false;\n    const c=st.grid[ny][nx]; \n    // Normalize empty cells to ensure they're 1x1\n    if (c.type==='empty') normalizeEmptyCell(nx,ny);\n    // Prevent merging through roads and other incompatible tiles\n    if (c.type==='road') return false;\n    if (c.type!=='empty' && c.type!==zt && !c.abandoned) return false;\n    const tr=st.terrain[ny][nx]; if (tr==='water'||tr==='cliff') return false;\n  }\n  return true;\n}\n\n// Helper: given any cell in a building, find the building's top-left and size\nfunction getBuildingBoundsFromCell(x,y) {\n  const c=st.grid[y][x];\n  if (!c) return {startX:x,startY:y,w:1,h:1};\n  // If this cell has a buildingId, use it as the primary way to find bounds\n  if (c.buildingId != null && c.type!=='empty') {\n    const targetId = c.buildingId;\n    const visited = new Set();\n    const queue = [{x,y}];\n    let minX = x, maxX = x, minY = y, maxY = y;\n\n    while (queue.length>0) {\n      const cur = queue.shift();\n      const key = `${cur.x},${cur.y}`;\n      if (visited.has(key)) continue;\n      visited.add(key);\n      if (cur.x<0 || cur.x>=GR_SZ || cur.y<0 || cur.y>=GR_SZ) continue;\n      const cell = st.grid[cur.y][cur.x];\n      if (!cell || cell.buildingId!==targetId) continue;\n\n      if (cur.x<minX) minX=cur.x;\n      if (cur.x>maxX) maxX=cur.x;\n      if (cur.y<minY) minY=cur.y;\n      if (cur.y>maxY) maxY=cur.y;\n\n      queue.push({x:cur.x-1,y:cur.y});\n      queue.push({x:cur.x+1,y:cur.y});\n      queue.push({x:cur.x,y:cur.y-1});\n      queue.push({x:cur.x,y:cur.y+1});\n    }\n\n    const w = maxX-minX+1;\n    const h = maxY-minY+1;\n    return {startX:minX,startY:minY,w,h};\n  }\n\n  // Fallback: legacy logic based on w/h only\n  const baseW=c.w||1, baseH=c.h||1;\n\n  // Single-tile structures (including empty zones) should never sweep across\n  // adjacent tiles just because they share the same zone type. Treat them as\n  // isolated cells so bulldozing/park placement only affects the clicked tile.\n  if (baseW===1 && baseH===1) return {startX:x,startY:y,w:1,h:1};\n\n  let startX = x;\n  let startY = y;\n\n  let stepsLeft = 0;\n  while (startX > 0 && stepsLeft < baseW-1) {\n    const left = st.grid[y][startX-1];\n    if (left && left.type === c.type && (left.w||1) === baseW && (left.h||1) === baseH) {\n      startX--;\n      stepsLeft++;\n    } else {\n      break;\n    }\n  }\n\n  let stepsUp = 0;\n  while (startY > 0 && stepsUp < baseH-1) {\n    const above = st.grid[startY-1][startX];\n    if (above && above.type === c.type && (above.w||1) === baseW && (above.h||1) === baseH) {\n      startY--;\n      stepsUp++;\n    } else {\n      break;\n    }\n  }\n\n  let consistent = true;\n  for (let dy=0; dy<baseH && consistent; dy++) {\n    for (let dx=0; dx<baseW; dx++) {\n      const nx=startX+dx, ny=startY+dy;\n      if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { consistent=false; break; }\n      const cell=st.grid[ny][nx];\n      if (!cell || cell.type!==c.type || (cell.w||1)!==baseW || (cell.h||1)!==baseH) {\n        consistent=false;\n        break;\n      }\n    }\n  }\n  if (!consistent) return {startX:x,startY:y,w:1,h:1};\n\n  return {startX:startX, startY:startY, w:baseW, h:baseH};\n}\n\nfunction getBuildingPowerKey(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return null;\n  const cell=st.grid[y][x];\n  if (!cell) return null;\n  if (cell.buildingId!=null) return `id:${cell.buildingId}`;\n  const {startX,startY}=getBuildingBoundsFromCell(x,y);\n  return `xy:${startX},${startY}`;\n}\n\nfunction isTopLeftCell(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false;\n  const cell=st.grid[y][x];\n  if (!cell) return false;\n  if (cell.buildingId != null) {\n    if (x>0) {\n      const left=st.grid[y][x-1];\n      if (left && left.buildingId===cell.buildingId) return false;\n    }\n    if (y>0) {\n      const above=st.grid[y-1][x];\n      if (above && above.buildingId===cell.buildingId) return false;\n    }\n    return true;\n  }\n  const w=cell.w||1, h=cell.h||1;\n  if (w===1 && h===1) return true;\n  if (x>0) {\n    const left=st.grid[y][x-1];\n    if (left && left.type===cell.type && (left.w||1)===w && (left.h||1)===h) return false;\n  }\n  if (y>0) {\n    const above=st.grid[y-1][x];\n    if (above && above.type===cell.type && (above.w||1)===w && (above.h||1)===h) return false;\n  }\n  return true;\n}\n\n// Recompute buildingId metadata for all non-empty cells based on rectangular buildings\nfunction rebuildBuildingIdsFromGrid() {\n  nextBuildingId = 1;\n\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (!cell) continue;\n      if (cell.type === 'empty') {\n        cell.buildingId = null;\n      } else {\n        cell.buildingId = undefined;\n      }\n    }\n  }\n\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (!cell || cell.type === 'empty') continue;\n      if (!isTopLeftCell(x,y)) continue;\n\n      const w = cell.w || 1;\n      const h = cell.h || 1;\n      const buildingId = nextBuildingId++;\n\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx = x+dx;\n          const ny = y+dy;\n          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) continue;\n          const target = st.grid[ny][nx];\n          if (!target || target.type==='empty') continue;\n          target.buildingId = buildingId;\n        }\n      }\n    }\n  }\n}\n\nfunction plcTl(x,y) {\n  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return; if (!st.selectedTool) return;\n  const c=st.grid[y][x], tr=st.terrain[y][x];\n  if (tr==='water'||tr==='cliff') { plySnd('error'); return; }\n  if (st.selectedTool==='bulldoze') {\n    if (c.type!=='empty') {\n      plySnd('bulldoze');\n\n      // Roads: always bulldoze a single tile only\n      if (c.type==='road') {\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n        normalizeEmptyCell(x,y);\n        calculatePowerGrid(); // Recalculate power grid when roads are removed\n        drGr(); sv();\n        return;\n      }\n      \n      // Check if removing a power plant\n      const wasPowerPlant = c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind';\n\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n      const isEmptyZone=isZone && (c.level===0 || c.abandoned);\n      const isSmallMulti=(w===2 && h===1) || (w===1 && h===2) || (w===2 && h===2);\n\n      // For empty zones: always bulldoze only the clicked cell\n      // For small multi-tile buildings (not empty zones): bulldoze the entire building\n      if (isEmptyZone) {\n        // Empty zones: bulldoze only the clicked cell\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n        normalizeEmptyCell(x,y);\n      } else if (isSmallMulti) {\n        // Small multi-tile buildings: bulldoze the entire building\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          const nx=startX+dx, ny=startY+dy; if (nx<GR_SZ && ny<GR_SZ) {\n            st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n            normalizeEmptyCell(nx,ny);\n          }\n        }\n      } else {\n        // All other buildings: only bulldoze the clicked cell\n        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n        normalizeEmptyCell(x,y);\n      }\n      \n      // Recalculate power grid if a power plant was removed\n      if (wasPowerPlant) {\n        calculatePowerGrid();\n      }\n\n      drGr(); sv();\n    }\n    return;\n  }\n  const isPk=st.selectedTool.startsWith('park');\n  \n  // For parks: allow placing on empty zones (level 0 or abandoned zones)\n  if (isPk) {\n    const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n    const isEmptyZone=isZone && (c.level===0 || c.abandoned);\n    if (c.type!=='empty' && !isEmptyZone) return;\n    \n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    \n    plySnd('place'); \n    st.money-=cs;\n    \n    // If replacing an empty zone, replace the entire building\n    if (isEmptyZone) {\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      // Replace all cells of the zone building with park\n      const parkBuildingId = nextBuildingId++;\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=startX+dx, ny=startY+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            st.grid[ny][nx]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};\n          }\n        }\n      }\n      // Try to merge parks after placement (from the top-left)\n      tryMrgPark(startX,startY);\n    } else {\n      // Normal placement on empty terrain\n      const parkBuildingId = nextBuildingId++;\n      st.grid[y][x]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};\n      // Try to merge with adjacent parks of the same type\n      tryMrgPark(x,y);\n    }\n  } else {\n    // For non-park tools: only allow empty or abandoned\n    // Determine building size\n    let bw = 1, bh = 1;\n    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {\n      bw = 2; bh = 2; // 2x2 for coal and nuclear\n    } else if (st.selectedTool === 'wind') {\n      bw = 1; bh = 2; // 1x2 for wind\n    }\n    \n    // Check if we can place a multi-tile building\n    if (bw > 1 || bh > 1) {\n      // Check all cells are empty or abandoned\n      let canPlace = true;\n      for (let dy=0; dy<bh; dy++) {\n        for (let dx=0; dx<bw; dx++) {\n          const nx = x + dx, ny = y + dy;\n          if (nx >= GR_SZ || ny >= GR_SZ) { canPlace = false; break; }\n          const nc = st.grid[ny][nx];\n          const ntr = st.terrain[ny][nx];\n          if (ntr === 'water' || ntr === 'cliff') { canPlace = false; break; }\n          if (nc.type !== 'empty' && !nc.abandoned) { canPlace = false; break; }\n        }\n        if (!canPlace) break;\n      }\n      if (!canPlace) { plySnd('error'); return; }\n    } else {\n      if (c.type!=='empty' && !c.abandoned) return;\n    }\n    \n    const cs=COSTS[st.selectedTool]||0; \n    if (st.money<cs) { plySnd('error'); return; }\n    plySnd('place'); \n    st.money-=cs;\n    const buildingId = nextBuildingId++;\n    \n    // Place the building across all its cells\n    for (let dy=0; dy<bh; dy++) {\n      for (let dx=0; dx<bw; dx++) {\n        const nx = x + dx, ny = y + dy;\n        if (nx < GR_SZ && ny < GR_SZ) {\n          st.grid[ny][nx]={type:st.selectedTool,age:0,level:0,w:bw,h:bh,buildingId:buildingId};\n        }\n      }\n    }\n    \n    // Recalculate power grid if a power plant or road was placed\n    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear' || st.selectedTool === 'wind' || st.selectedTool === 'road') {\n      calculatePowerGrid();\n    }\n  }\n  drGr(); updUI(); sv();\n}\n\nlet isDragging = false, dragStart = null, lastPlaced = null, isScrolling = false, touchStartPos = null, lastTouchPos = null;\nlet hoverPos = null; // Track hover position for placement preview\n\nfunction getCarSpeedMultiplier() {\n  if (st.speed<=0) return 0;\n  if (st.speed===500) return 3;\n  if (st.speed===1500) return 2;\n  return 1;\n}\n\nconst CAR_BASE_SPEED = 1.0;\nconst CAR_EDGE_OFFSET = CL_SZ/2 - 1;\nconst CAR_SNAP_THRESHOLD = 0.5;\nconst EMERGENCY_SPEED_MULTIPLIER = 1.2;\n\nfunction getCarSpeedPerFrame(car) {\n  const baseSpeed = CAR_BASE_SPEED * getCarSpeedMultiplier();\n  // Police and fire cars move faster than normal cars\n  if (car && (car.type === 'police' || car.type === 'fire')) {\n    return baseSpeed * EMERGENCY_SPEED_MULTIPLIER;\n  }\n  return baseSpeed;\n}\n\nfunction updateCarLaneOffset(car) {\n  if (car.pathIdx>=car.path.length-1) return;\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    if (Math.abs(dxSeg)>Math.abs(dySeg)) {\n      car.laneOffset=dxSeg>0 ? 5 : -5;\n    } else {\n      car.laneOffset=dySeg>0 ? -5 : 5;\n    }\n}\n\nfunction getCarSegmentTarget(car) {\n  const curNode=car.path[car.pathIdx];\n  const nextNode=car.path[car.pathIdx+1];\n  let tx=nextNode.x*CL_SZ+7;\n  let ty=nextNode.y*CL_SZ+7;\n  const dxSeg=nextNode.x-curNode.x;\n  const dySeg=nextNode.y-curNode.y;\n    const horizontal=Math.abs(dxSeg)>Math.abs(dySeg);\n    if (horizontal) ty+=car.laneOffset;\n    else tx+=car.laneOffset;\n    \n    const hasNextTurn=car.pathIdx+2<car.path.length;\n    if (hasNextTurn) {\n      const afterNode=car.path[car.pathIdx+2];\n      const dxNext=afterNode.x-nextNode.x;\n      const dyNext=afterNode.y-nextNode.y;\n      const nextHorizontal=Math.abs(dxNext)>Math.abs(dyNext);\n      if (horizontal && !nextHorizontal) {\n        const nextLaneOffset=dyNext>0 ? -5 : 5;\n        tx+=nextLaneOffset;\n      } else if (!horizontal && nextHorizontal) {\n        const nextLaneOffset=dxNext>0 ? 5 : -5;\n        ty+=nextLaneOffset;\n      }\n    }\n  return {tx,ty};\n}\n\nfunction getCanvasPos(e) {\n  const r = cvs.getBoundingClientRect();\n  const sx = cvs.width / r.width, sy = cvs.height / r.height;\n  let clientX, clientY;\n  \n  if (e.touches && e.touches.length > 0) {\n    clientX = e.touches[0].clientX;\n    clientY = e.touches[0].clientY;\n    lastTouchPos = { x: clientX, y: clientY };\n  } else if (e.changedTouches && e.changedTouches.length > 0) {\n    // For touchend events\n    clientX = e.changedTouches[0].clientX;\n    clientY = e.changedTouches[0].clientY;\n  } else if (lastTouchPos) {\n    // Fallback to last known touch position\n    clientX = lastTouchPos.x;\n    clientY = lastTouchPos.y;\n  } else {\n    clientX = e.clientX;\n    clientY = e.clientY;\n  }\n  \n  const x = Math.floor((clientX - r.left) * sx / CL_SZ);\n  const y = Math.floor((clientY - r.top) * sy / CL_SZ);\n  return { x, y };\n}\n\nfunction placeLine(x0, y0, x1, y1) {\n  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;\n  let err = dx - dy, x = x0, y = y0;\n  const placed = new Set();\n  \n  while (true) {\n    const key = `${x},${y}`;\n    if (!placed.has(key)) {\n      placed.add(key);\n      plcTl(x, y);\n    }\n    if (x === x1 && y === y1) break;\n    const e2 = 2 * err;\n    if (e2 > -dy) { err -= dy; x += sx; }\n    if (e2 < dx) { err += dx; y += sy; }\n  }\n}\n\nlet lastZoneBounds = null;\n\nfunction placeZone(x0, y0, x1, y1) {\n  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);\n  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);\n  const currentBounds = `${minX},${minY},${maxX},${maxY}`;\n  \n  // Only place if bounds changed to avoid redundant work\n  if (currentBounds === lastZoneBounds) return;\n  lastZoneBounds = currentBounds;\n  \n  for (let y = minY; y <= maxY; y++) {\n    for (let x = minX; x <= maxX; x++) {\n      plcTl(x, y);\n    }\n  }\n}\n\nfunction handleDragStart(e) {\n  // On mobile (touch events), allow scrolling and only handle taps\n  if (e.touches) {\n    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n    isDragging = false;\n    isScrolling = false;\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  // Don't start drag if stats view is active\n  if (!st.selectedTool || showLandValueOverlay || showCrimeOverlay) return;\n  \n  const pos = getCanvasPos(e);\n  dragStart = pos;\n  lastPlaced = { x: pos.x, y: pos.y };\n  lastZoneBounds = null; // Reset zone bounds tracking\n  isDragging = true;\n  isScrolling = false;\n}\n\nfunction handleDragMove(e) {\n  // On mobile (touch events), allow native scrolling - don't place tiles while dragging\n  if (e.touches) {\n    if (touchStartPos) {\n      const dx = Math.abs(e.touches[0].clientX - touchStartPos.x);\n      const dy = Math.abs(e.touches[0].clientY - touchStartPos.y);\n      // If moved significantly, mark as scrolling (not a tap)\n      if (dx > 5 || dy > 5) {\n        isScrolling = true;\n      }\n    }\n    // Don't prevent default - allow native scrolling\n    return;\n  }\n  \n  // Desktop mouse behavior\n  // Don't drag if stats view is active\n  if (!st.selectedTool || !isDragging || !dragStart || showLandValueOverlay || showCrimeOverlay) return;\n  \n  const pos = getCanvasPos(e);\n  \n  // For roads: place as line\n  if (st.selectedTool === 'road') {\n    placeLine(dragStart.x, dragStart.y, pos.x, pos.y);\n    dragStart = pos; // Update start for continuous line\n  }\n  // For RCI zones: place as zone\n  else if (st.selectedTool === 'residential' || st.selectedTool === 'commercial' || st.selectedTool === 'industrial') {\n    placeZone(dragStart.x, dragStart.y, pos.x, pos.y);\n  }\n  // For other tools: place individual tiles\n  else {\n    const key = `${pos.x},${pos.y}`;\n    const lastKey = `${lastPlaced.x},${lastPlaced.y}`;\n    if (key !== lastKey) {\n      plcTl(pos.x, pos.y);\n      lastPlaced = pos;\n    }\n  }\n}\n\nfunction handleDragEnd(e) {\n  // Handle mobile tap (touch without scrolling)\n  if (e.changedTouches && touchStartPos && !isScrolling) {\n    const pos = getCanvasPos(e);\n    \n    // If stat view is active, show building info instead of placing tool\n    if (showLandValueOverlay || showCrimeOverlay) {\n      showBuildingInfo(pos.x, pos.y);\n    } else if (st.selectedTool) {\n      // This was a tap, not a scroll - place a tile\n      plcTl(pos.x, pos.y);\n    }\n  }\n  // Handle desktop mouse drag end\n  else if (isDragging && !isScrolling && dragStart && !e.touches) {\n    const pos = getCanvasPos(e);\n    // If we didn't move much (or at all), treat as click\n    const moved = Math.abs(pos.x - dragStart.x) > 0 || Math.abs(pos.y - dragStart.y) > 0;\n    if (!moved) {\n      // If stat view is active, show building info instead of placing tool\n      if (showLandValueOverlay || showCrimeOverlay) {\n        showBuildingInfo(pos.x, pos.y);\n      } else if (st.selectedTool) {\n        plcTl(pos.x, pos.y);\n      }\n    }\n  }\n  \n  isDragging = false;\n  isScrolling = false;\n  dragStart = null;\n  lastPlaced = null;\n  touchStartPos = null;\n  lastTouchPos = null;\n  lastZoneBounds = null;\n}\n\n// Mouse events\ncvs.addEventListener('mousedown', handleDragStart);\ncvs.addEventListener('mousemove', handleDragMove);\ncvs.addEventListener('mouseup', handleDragEnd);\ncvs.addEventListener('mouseleave', (e) => {\n  hoverPos = null;\n  handleDragEnd(e);\n});\n\n// Track hover for placement preview\ncvs.addEventListener('mousemove', (e) => {\n  if (!isDragging && st.selectedTool && st.selectedTool !== 'bulldoze') {\n    const pos = getCanvasPos(e);\n    hoverPos = pos;\n  } else {\n    hoverPos = null;\n  }\n});\n\n// Touch events - passive for smooth scrolling on mobile\ncvs.addEventListener('touchstart', handleDragStart, { passive: true });\ncvs.addEventListener('touchmove', handleDragMove, { passive: true });\ncvs.addEventListener('touchend', handleDragEnd, { passive: true });\ncvs.addEventListener('touchcancel', handleDragEnd, { passive: true });\n\n// Click handler for mouse only (touch events are handled separately)\ncvs.addEventListener('click', e => {\n  // Only handle mouse clicks, not touch-generated clicks\n  if (e.detail === 0) return; // Touch events have detail = 0\n  if (!isDragging && !isScrolling) {\n    const r = cvs.getBoundingClientRect(), sx = cvs.width / r.width, sy = cvs.height / r.height;\n    const x = Math.floor((e.clientX - r.left) * sx / CL_SZ), y = Math.floor((e.clientY - r.top) * sy / CL_SZ);\n    \n    // If stat view is active, show building info instead of placing tool\n    if (showLandValueOverlay || showCrimeOverlay) {\n      showBuildingInfo(x, y);\n    } else if (st.selectedTool) {\n      plcTl(x, y);\n    }\n  }\n});\n\nlet activeSubmenu = null;\n\nconst submenuItems = {\n  park: [\n    { tool: 'park', icon: 'üå≥', tooltip: 'park', shortcut: '1' },\n    { tool: 'park2', icon: 'üå∏', tooltip: 'park', shortcut: '2' },\n    { tool: 'park3', icon: 'üå≤', tooltip: 'park', shortcut: '3' },\n    { tool: 'park4', icon: 'üåª', tooltip: 'park', shortcut: '4' }\n  ],\n  services: [\n    { tool: 'police', icon: 'üöì', tooltip: 'police station', shortcut: '1' },\n    { tool: 'fire', icon: 'üöí', tooltip: 'fire station', shortcut: '2' },\n    { tool: 'school', icon: 'üè´', tooltip: 'school', shortcut: '3' },\n    { tool: 'hospital', icon: 'üè•', tooltip: 'hospital', shortcut: '4' }\n  ],\n  power: [\n    { tool: 'coal', icon: '‚ö°', tooltip: 'coal plant', shortcut: '1' },\n    { tool: 'nuclear', icon: '‚ò¢Ô∏è', tooltip: 'nuclear plant', shortcut: '2' },\n    { tool: 'wind', icon: 'üí®', tooltip: 'wind plant', shortcut: '3' }\n  ],\n  disaster: [\n    { disaster: 'fire', icon: 'üî•', tooltip: 'fire', shortcut: '1' },\n    { disaster: 'crime', icon: 'üö®', tooltip: 'crime', shortcut: '2' },\n    { disaster: 'earthquake', icon: 'üåç', tooltip: 'earthquake', shortcut: '3' }\n  ]\n};\nfunction openSubmenu(button, submenuKey) {\n  // Close any existing submenu\n  closeSubmenu();\n  \n  // Store reference to the button\n  activeSubmenu = { button, submenuKey };\n  \n  // Change button to X\n  const originalContent = button.innerHTML;\n  button.dataset.originalContent = originalContent;\n  button.innerHTML = '‚úï';\n  button.classList.add('submenu-active');\n  \n  // Get sub-toolbar\n  const subToolbar = document.getElementById('subToolbar');\n  \n  // Populate sub-toolbar with items (but keep hidden for now)\n  subToolbar.innerHTML = '';\n  const items = submenuItems[submenuKey];\n  items.forEach(item => {\n    const subBtn = document.createElement('button');\n    subBtn.className = 'tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center';\n    if (item.tool) {\n      subBtn.dataset.tool = item.tool;\n    }\n    if (item.disaster) {\n      subBtn.dataset.disaster = item.disaster;\n    }\n    if (item.tooltip) {\n      subBtn.dataset.tooltip = item.tooltip;\n      if (item.shortcut) {\n        subBtn.dataset.shortcut = item.shortcut;\n      }\n      subBtn.addEventListener('mouseenter', () => {\n        showTooltip(subBtn, item.tooltip);\n      });\n      subBtn.addEventListener('mouseleave', () => {\n        hideTooltip();\n      });\n    }\n    subBtn.textContent = item.icon;\n    subBtn.addEventListener('click', (e) => {\n      e.stopPropagation();\n      plySnd('click');\n      if (item.tool) {\n        selTl(item.tool);\n        // Don't close submenu - keep it open so user can switch tools\n      } else if (item.disaster) {\n        // Trigger disaster and close submenu\n        if (item.disaster === 'fire') {\n          startFire();\n        } else if (item.disaster === 'crime') {\n          startCrimeEvent();\n        } else if (item.disaster === 'earthquake') {\n          startQuake();\n        }\n        closeSubmenu();\n      }\n    });\n    subToolbar.appendChild(subBtn);\n  });\n  \n  // Auto-select the first tool in the submenu (only for tools, not disasters)\n  if (items.length > 0 && items[0].tool) {\n    selTl(items[0].tool);\n  }\n  \n  // Make submenu invisible but rendered to measure it\n  subToolbar.style.visibility = 'hidden';\n  subToolbar.classList.remove('hidden');\n  \n  // Position submenu vertically centered on the toggle button\n  requestAnimationFrame(() => {\n    const parentContainer = button.closest('.flex.flex-shrink-0.relative');\n    const parentRect = parentContainer.getBoundingClientRect();\n    const buttonRect = button.getBoundingClientRect();\n    const subToolbarRect = subToolbar.getBoundingClientRect();\n    \n    // Calculate positions relative to parent container\n    const buttonTopRelative = buttonRect.top - parentRect.top;\n    const buttonCenterY = buttonTopRelative + buttonRect.height / 2;\n    const submenuHeight = subToolbarRect.height;\n    const submenuCenterY = submenuHeight / 2;\n    \n    // Calculate top position to center submenu on button\n    const topPosition = buttonCenterY - submenuCenterY;\n    subToolbar.style.top = `${topPosition}px`;\n    \n    // Now make it visible\n    subToolbar.style.visibility = '';\n    \n    updateToolSelection();\n  });\n}\n\nfunction closeSubmenu() {\n  if (activeSubmenu) {\n    // Restore original button content\n    if (activeSubmenu.button.dataset.originalContent) {\n      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;\n      activeSubmenu.button.classList.remove('submenu-active');\n    }\n    activeSubmenu = null;\n  }\n  \n  // Hide sub-toolbar and reset position\n  const subToolbar = document.getElementById('subToolbar');\n  subToolbar.classList.add('hidden');\n  subToolbar.style.top = '';\n  subToolbar.style.visibility = '';\n}\n\nfunction updateToolSelection() {\n  // Update all tool buttons including sub-toolbar buttons\n  document.querySelectorAll('.tool-btn').forEach(b => {\n    const bt = b.dataset.tool;\n    b.style.borderColor = '';\n    b.style.opacity = '';\n    if (bt === st.selectedTool) {\n      b.style.borderColor = '#666';\n      b.style.opacity = '1';\n    } else {\n      // All other unselected buttons get reduced opacity (including submenu toggle showing X and disaster buttons)\n      b.style.opacity = '0.5';\n    }\n  });\n}\n\n// Create tooltip element\nlet tooltipEl = null;\nfunction createTooltip() {\n  if (!tooltipEl) {\n    tooltipEl = document.createElement('div');\n    tooltipEl.className = 'tooltip';\n    document.body.appendChild(tooltipEl);\n  }\n  return tooltipEl;\n}\n\nfunction showTooltip(button, text) {\n  // Only show on devices that support hover\n  if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {\n    const tooltip = createTooltip();\n    const shortcut = button.dataset.shortcut;\n    if (shortcut) {\n      tooltip.innerHTML = `${text}<span class=\"tooltip-shortcut\">${shortcut}</span>`;\n    } else {\n      tooltip.textContent = text;\n    }\n    tooltip.classList.add('show');\n    \n    const rect = button.getBoundingClientRect();\n    tooltip.style.left = `${rect.left - tooltip.offsetWidth - 8}px`;\n    tooltip.style.top = `${rect.top + rect.height / 2}px`;\n    tooltip.style.transform = 'translateY(-50%)';\n    \n    // Recalculate position after tooltip is rendered\n    setTimeout(() => {\n      const tooltipRect = tooltip.getBoundingClientRect();\n      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;\n    }, 0);\n  }\n}\n\nfunction hideTooltip() {\n  if (tooltipEl) {\n    tooltipEl.classList.remove('show');\n  }\n}\n\n// Keyboard shortcut mapping\nconst keyToTool = {\n  'r': 'road',\n  'R': 'road',\n  'h': 'residential',\n  'H': 'residential',\n  'c': 'commercial',\n  'C': 'commercial',\n  'i': 'industrial',\n  'I': 'industrial',\n  'p': 'park',\n  'P': 'park',\n  's': 'services',\n  'S': 'services',\n  'e': 'power',\n  'E': 'power',\n  'd': 'bulldoze',\n  'D': 'bulldoze',\n  'w': 'disaster',\n  'W': 'disaster'\n};\n\nfunction triggerToolByKey(key) {\n  const tool = keyToTool[key];\n  if (!tool) return false;\n  \n  // Find the button for this tool\n  if (tool === 'disaster') {\n    const disasterBtn = document.querySelector('[data-submenu=\"disaster\"]');\n    if (disasterBtn && st.disastersEnabled) {\n      if (activeSubmenu && activeSubmenu.button === disasterBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(disasterBtn, 'disaster');\n      }\n      return true;\n    }\n  } else if (tool === 'park') {\n    const parkBtn = document.querySelector('[data-submenu=\"park\"]');\n    if (parkBtn) {\n      if (activeSubmenu && activeSubmenu.button === parkBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(parkBtn, 'park');\n      }\n      return true;\n    }\n  } else if (tool === 'services') {\n    const servicesBtn = document.querySelector('[data-submenu=\"services\"]');\n    if (servicesBtn) {\n      if (activeSubmenu && activeSubmenu.button === servicesBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(servicesBtn, 'services');\n      }\n      return true;\n    }\n  } else if (tool === 'power') {\n    const powerBtn = document.querySelector('[data-submenu=\"power\"]');\n    if (powerBtn) {\n      if (activeSubmenu && activeSubmenu.button === powerBtn) {\n        closeSubmenu();\n      } else {\n        openSubmenu(powerBtn, 'power');\n      }\n      return true;\n    }\n  } else {\n    const toolBtn = document.querySelector(`[data-tool=\"${tool}\"]`);\n    if (toolBtn) {\n      toolBtn.click();\n      return true;\n    }\n  }\n  return false;\n}\n\n// Handle submenu shortcuts when submenu is open\nfunction handleSubmenuShortcut(key) {\n  if (!activeSubmenu) return false;\n  \n  if (activeSubmenu.submenuKey === 'disaster') {\n    const shortcuts = { '1': 'fire', '2': 'crime', '3': 'earthquake' };\n    const disaster = shortcuts[key];\n    if (disaster) {\n      const subBtn = document.querySelector(`[data-disaster=\"${disaster}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'park') {\n    const shortcuts = { '1': 'park', '2': 'park2', '3': 'park3', '4': 'park4' };\n    const parkTool = shortcuts[key];\n    if (parkTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${parkTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'services') {\n    const shortcuts = { '1': 'police', '2': 'fire', '3': 'school', '4': 'hospital' };\n    const servicesTool = shortcuts[key];\n    if (servicesTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${servicesTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  } else if (activeSubmenu.submenuKey === 'power') {\n    const shortcuts = { '1': 'coal', '2': 'nuclear', '3': 'wind' };\n    const powerTool = shortcuts[key];\n    if (powerTool) {\n      const subBtn = document.querySelector(`[data-tool=\"${powerTool}\"]`);\n      if (subBtn) {\n        subBtn.click();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction setSpeedByNumber(num) {\n  plySnd('click');\n  if (num === 0) {\n    st.speed = 0;\n  } else if (num === 1) {\n    st.speed = 3000;\n  } else if (num === 2) {\n    st.speed = 1500;\n  } else if (num === 3) {\n    st.speed = 500;\n  }\n  sv();\n  if (tkTmr) clearInterval(tkTmr);\n  if (st.speed > 0) {\n    TK_INT = st.speed;\n    tkTmr = setInterval(simTk, TK_INT);\n    updNwsTk();\n  } else {\n    updNwsTk();\n  }\n  updUI();\n}\n\ndocument.addEventListener('keydown', (e) => {\n  // Don't trigger if user is typing in an input field\n  const activeElement = document.activeElement;\n  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {\n    return;\n  }\n  \n  // Handle speed controls (0-3) only if no submenu is open\n  if (!activeSubmenu && (e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3')) {\n    const num = parseInt(e.key);\n    setSpeedByNumber(num);\n    e.preventDefault();\n    return;\n  }\n  \n  // Handle submenu shortcuts when submenu is open\n  if (handleSubmenuShortcut(e.key)) {\n    e.preventDefault();\n    return;\n  }\n  \n  // Handle main tool shortcuts\n  if (triggerToolByKey(e.key)) {\n    e.preventDefault();\n  }\n});\n\ndocument.querySelectorAll('.tool-btn').forEach(b => {\n  const tooltipText = b.dataset.tooltip;\n  if (tooltipText) {\n    b.addEventListener('mouseenter', () => {\n      showTooltip(b, tooltipText);\n    });\n    b.addEventListener('mouseleave', () => {\n      hideTooltip();\n    });\n  }\n  \n  b.addEventListener('click', (e) => {\n    plySnd('click');\n    hideTooltip();\n    \n    // Check if this button has a submenu\n    if (b.dataset.submenu) {\n      // If submenu is already open, close it\n      if (activeSubmenu && activeSubmenu.button === b) {\n        closeSubmenu();\n      } else {\n        // Open submenu\n        openSubmenu(b, b.dataset.submenu);\n      }\n    } else if (b.dataset.tool) {\n      // Regular tool selection\n      selTl(b.dataset.tool);\n      closeSubmenu();\n    }\n  });\n});\n\nfunction updateDisasterButtonsVisibility() {\n  const disasterButtons = document.querySelectorAll('.disaster-btn');\n  disasterButtons.forEach(btn => {\n    btn.style.display = st.disastersEnabled ? 'flex' : 'none';\n  });\n}\n\nfunction centerCanvas() {\n  const gridContainer = document.getElementById('grid');\n  if (!gridContainer) return;\n  \n  // Wait for next frame to ensure layout is calculated\n  requestAnimationFrame(() => {\n    const zoom = st.zoom || 1;\n    const canvasWidth = cvs.width * zoom;\n    const canvasHeight = cvs.height * zoom;\n    const containerWidth = gridContainer.clientWidth;\n    const containerHeight = gridContainer.clientHeight;\n    \n    // If canvas is smaller than container, center it with CSS\n    if (canvasWidth <= containerWidth && canvasHeight <= containerHeight) {\n      // Center using flexbox or margin auto\n      gridContainer.style.display = 'flex';\n      gridContainer.style.justifyContent = 'center';\n      gridContainer.style.alignItems = 'center';\n      gridContainer.scrollLeft = 0;\n      gridContainer.scrollTop = 0;\n    } else {\n      // Canvas is larger, use scroll positioning\n      gridContainer.style.display = 'block';\n      gridContainer.style.justifyContent = '';\n      gridContainer.style.alignItems = '';\n      \n      // Calculate scroll position to center the canvas\n      const scrollLeft = Math.max(0, (canvasWidth - containerWidth) / 2);\n      const scrollTop = Math.max(0, (canvasHeight - containerHeight) / 2);\n      \n      gridContainer.scrollLeft = scrollLeft;\n      gridContainer.scrollTop = scrollTop;\n    }\n  });\n}\n\nfunction applyZoom() {\n  if (!st.zoom) st.zoom = 1;\n  cvs.style.transform = `scale(${st.zoom})`;\n  cvs.style.transformOrigin = 'top left';\n  document.getElementById('zoomLevel').textContent = Math.round(st.zoom * 100) + '%';\n  sv();\n  centerCanvas();\n}\n\nfunction zoomIn() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.min(3, st.zoom + 0.25);\n  applyZoom();\n}\n\nfunction zoomOut() {\n  if (!st.zoom) st.zoom = 1;\n  st.zoom = Math.max(0.25, st.zoom - 0.25);\n  applyZoom();\n}\n\nfunction zoomReset() {\n  st.zoom = 1;\n  applyZoom();\n}\n\ndocument.getElementById('zoomInBtn').addEventListener('click', () => { plySnd('click'); zoomIn(); });\ndocument.getElementById('zoomOutBtn').addEventListener('click', () => { plySnd('click'); zoomOut(); });\n\nconst inpNm=document.getElementById('cityName');\ninpNm.addEventListener('focus', () => edtNm=true);\ninpNm.addEventListener('blur', () => { edtNm=false; st.cityName=inpNm.value||'new city'; sv(); updUI(); });\ninpNm.addEventListener('input', () => updInpWd());\ninpNm.addEventListener('change', e => { st.cityName=e.target.value||'new city'; sv(); });\ninpNm.addEventListener('click', e => e.target.select());\n\ndocument.getElementById('menuBtn').addEventListener('click', () => {\n  plySnd('click'); const m=document.getElementById('menu'); m.classList.toggle('hidden');\n  document.getElementById('newGamePanel').classList.add('hidden'); \n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n});\n\ndocument.getElementById('speedToggle').addEventListener('click', () => {\n  plySnd('click');\n  if (st.speed===0) st.speed=3000; else if (st.speed===3000) st.speed=1500; else if (st.speed===1500) st.speed=500; else st.speed=0;\n  sv(); if (tkTmr) clearInterval(tkTmr);\n  if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); updNwsTk(); }\n  else updNwsTk();\n  updUI();\n});\n\ndocument.getElementById('newCityBtn').addEventListener('click', () => { \n  plySnd('click'); \n  document.getElementById('newCityName').value = '';\n  document.getElementById('menu').classList.add('hidden'); \n  document.getElementById('newGamePanel').classList.remove('hidden'); \n});\n\ndocument.getElementById('startGameBtn').addEventListener('click', () => {\n  plySnd('click');\n  const nm=document.getElementById('newCityName').value||'new city', tr=document.getElementById('terrainType').value, df=document.getElementById('difficulty').value;\n  let mn=50000; if (df==='easy') mn=100000; else if (df==='hard') mn=20000;\n  aiReq=false; initGr(tr); st.money=mn; st.population=0; st.happiness=70; st.tickCount=0; st.cityName=nm; st.rDemand=50; st.cDemand=50; st.iDemand=50; st.year=1990; st.newsEvents=['Welcome to '+nm+'!']; st.ticksSinceNews=0; st.employment=0; st.taxRate=10;\n  if (!st.zoom) st.zoom=1;\n  drGr(); updUI(); updNwsTk(); sv();\n  document.getElementById('newGamePanel').classList.add('hidden');\n  document.getElementById('aiPanel').classList.add('hidden');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  setTimeout(centerCanvas, 100);\n});\n\ndocument.getElementById('aiSuggestBtn').addEventListener('click', async () => {\n  plySnd('click'); document.getElementById('menu').classList.add('hidden'); document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n  const pnl=document.getElementById('aiPanel'), msg=document.getElementById('aiMessage');\n  pnl.classList.remove('hidden'); msg.innerHTML='<span class=\"text-neutral-500\">thinking...</span>';\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  const prm=`You are an AI mayor advisor for a SimCity-like game. Analyze the current city state and give 2-3 SHORT, actionable suggestions (1-2 sentences total).\\n\\nCurrent city stats:\\n- Money: $${st.money.toLocaleString()}\\n- Population: ${st.population}\\n- Happiness: ${st.happiness}/100\\n- Buildings: ${JSON.stringify(cnts)}\\n- RCI Demand: R=${st.rDemand}% C=${st.cDemand}% I=${st.iDemand}%\\n\\nAvailable building types: road, residential, commercial, industrial, park, police, fire, school, hospital\\n\\nGive practical advice based on what's missing or unbalanced. Keep it brief and conversational.`;\n  try {\n    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n    if (!r.ok) throw new Error('AI request failed');\n    const d=await r.json(), rp=d.reply||'everything looks good!';\n    msg.textContent=''; let i=0;\n    const tw=setInterval(() => { if (i<rp.length) { msg.textContent+=rp.charAt(i); i++; } else clearInterval(tw); },20);\n  } catch(e) { console.error('AI error:',e); msg.textContent='could not reach AI mayor. try building more infrastructure!'; }\n});\n\ndocument.getElementById('closeAiBtn').addEventListener('click', () => { plySnd('click'); document.getElementById('aiPanel').classList.add('hidden'); });\ndocument.getElementById('closeInfoBtn').addEventListener('click', () => {\n  plySnd('click');\n  document.getElementById('infoPanel').classList.add('hidden');\n  currentInfoType = null;\n  setLandValueOverlay(false);\n  setCrimeOverlay(false);\n});\n\nfunction statItem(label, value, colorClass = '') {\n  return `<div class=\"flex flex-col flex-shrink-0\"><div class=\"text-xs text-neutral-400\">${label}</div><div class=\"${colorClass}\">${value}</div></div>`;\n}\nfunction getStatsContent(infoType) {\n  const cnts = {};\n  st.grid.flat().forEach(c => cnts[c.type] = (cnts[c.type] || 0) + 1);\n  const getCount = type => cnts[type] || 0;\n  \n  let content = '';\n  let title = '';\n  \n  if (infoType === 'rci') {\n    title = 'RCI Demand';\n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('residential', `${st.rDemand}%`, 'text-green-500')}${statItem('commercial', `${st.cDemand}%`, 'text-blue-500')}${statItem('industrial', `${st.iDemand}%`, 'text-yellow-500')}</div><div class=\"mt-3 text-xs text-neutral-400\">Higher demand means more zones needed</div>`;\n  } else if (infoType === 'pop') {\n    title = 'Population';\n    const bPR=10; let popL1=0, popL2=0, popL3=0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n        const sM=(c.w||1)*(c.h||1);\n        if (c.level===3) popL3+=Math.floor(bPR*sM*1.5);\n        else if (c.level===2) popL2+=Math.floor(bPR*sM*1.2);\n        else if (c.level>=1) popL1+=Math.floor(bPR*sM*1);\n      }\n    }\n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('total', st.population.toLocaleString())}${statItem('zones', cnts.residential||0)}${statItem('employment', `${st.employment}%`)}${statItem('L1', popL1.toLocaleString())}${statItem('L2', popL2.toLocaleString())}${statItem('L3', popL3.toLocaleString())}</div><div class=\"mt-3 text-xs text-neutral-400\">Build more residential zones to grow, levels upgrade with parks, services, and education</div>`;\n  } else if (infoType === 'power') {\n    title = 'Energy';\n    // Calculate power stats\n    let totalPowerGeneration = 0, totalPowerConsumption = 0;\n    let coalGen = 0, nuclearGen = 0, windGen = 0;\n    let coalCount = 0, nuclearCount = 0, windCount = 0;\n    let residentialConsumption = 0, commercialConsumption = 0, industrialConsumption = 0;\n    \n    // Track processed power structures so each building counts once (by buildingId when available)\n    const processedPowerPlants = new Set();\n    const processedPowerBuildings = new Set();\n    \n    for (let y=0; y<GR_SZ; y++) {\n      for (let x=0; x<GR_SZ; x++) {\n        const c = st.grid[y][x];\n        \n          if (c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind') {\n            const plantKey=getBuildingPowerKey(x,y);\n            if (plantKey && !processedPowerPlants.has(plantKey)) {\n              processedPowerPlants.add(plantKey);\n              if (c.type === 'coal') {\n                coalGen += POWER_GENERATION.coal;\n                coalCount++;\n                totalPowerGeneration += POWER_GENERATION.coal;\n              } else if (c.type === 'nuclear') {\n                nuclearGen += POWER_GENERATION.nuclear;\n                nuclearCount++;\n                totalPowerGeneration += POWER_GENERATION.nuclear;\n              } else if (c.type === 'wind') {\n                windGen += POWER_GENERATION.wind;\n                windCount++;\n                totalPowerGeneration += POWER_GENERATION.wind;\n              }\n            }\n          }\n        \n        if (c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') {\n            const buildingKey=getBuildingPowerKey(x,y);\n            if (!buildingKey || processedPowerBuildings.has(buildingKey)) continue;\n            processedPowerBuildings.add(buildingKey);\n          const level = c.level || 0;\n          const consumption = getPowerConsumption(c.type, level);\n          totalPowerConsumption += consumption;\n          if (c.type === 'residential') residentialConsumption += consumption;\n          else if (c.type === 'commercial') commercialConsumption += consumption;\n          else if (c.type === 'industrial') industrialConsumption += consumption;\n        }\n      }\n    }\n    const powerSurplus = totalPowerGeneration - totalPowerConsumption;\n    const powerColor = powerSurplus >= 0 ? 'text-green-500' : 'text-red-500';\n    const surplusDisplay = powerSurplus >= 0 ? `+${powerSurplus}` : powerSurplus.toString();\n    \n    content = `<div class=\"flex flex-wrap gap-6 py-2\">\n      ${statItem('generation', `+${totalPowerGeneration}`, 'text-green-500')}\n      ${statItem('consumption', `-${totalPowerConsumption}`, 'text-red-500')}\n      ${statItem('surplus', surplusDisplay, powerColor)}\n    </div>\n    <div class=\"mt-4 space-y-3\">\n      <div>\n        <div class=\"text-xs text-neutral-300 mb-1\">Power Plants</div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${coalCount > 0 ? statItem('Coal', `+${coalGen} (${coalCount})`, '') : ''}\n          ${nuclearCount > 0 ? statItem('Nuclear', `+${nuclearGen} (${nuclearCount})`, '') : ''}\n          ${windCount > 0 ? statItem('Wind', `+${windGen} (${windCount})`, '') : ''}\n          ${coalCount === 0 && nuclearCount === 0 && windCount === 0 ? '<div class=\"text-xs text-neutral-500\">No power plants built</div>' : ''}\n        </div>\n      </div>\n      <div>\n        <div class=\"text-xs text-neutral-300 mb-1\">Consumption Breakdown</div>\n        <div class=\"flex flex-wrap gap-6 py-2\">\n          ${residentialConsumption > 0 ? statItem('Residential', `-${residentialConsumption}`, 'text-green-500') : ''}\n          ${commercialConsumption > 0 ? statItem('Commercial', `-${commercialConsumption}`, 'text-blue-500') : ''}\n          ${industrialConsumption > 0 ? statItem('Industrial', `-${industrialConsumption}`, 'text-yellow-500') : ''}\n          ${totalPowerConsumption === 0 ? '<div class=\"text-xs text-neutral-500\">No buildings consuming power</div>' : ''}\n        </div>\n      </div>\n    </div>\n    <div class=\"mt-3 text-xs text-neutral-400\">Power flows via roads from power plants. L2+L3 residential, all commercial and industrial require power.</div>`;\n  } else if (infoType === 'money') {\n    title = 'Budget';\n    // Calculate income breakdown (same logic as simTk)\n    let residentialIncome = 0, commercialRevenue = 0, industrialRevenue = 0, tourismIncome = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseTax=2.5; // Increased to balance expenses\n        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n        const landValueMultiplier=1+(lv-50)/100;\n        const popPerCell=Math.floor(10*size*levelMultiplier);\n        residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);\n      } else if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseRevenue=18; // Increased to balance expenses\n        const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));\n        const landValueMultiplier=1+(lv-50)/80;\n        const employmentMultiplier=0.5+(st.employment/200);\n        const populationMultiplier=Math.min(2.0,1+(st.population/5000));\n        commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);\n      } else if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {\n        const lv=st.landValue[y][x]||50;\n        const level=c.level||0;\n        const size=(c.w||1)*(c.h||1);\n        const baseRevenue=24; // Increased to balance expenses\n        const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));\n        const landValueMultiplier=1+(lv-50)/100;\n        const employmentMultiplier=0.4+(st.employment/167);\n        industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);\n      } else if (c.type && c.type.startsWith('park')) {\n        const size=(c.w||1)*(c.h||1);\n        const baseTourism=6; // Increased to balance expenses\n        const populationMultiplier=Math.min(3.0,1+(st.population/3000));\n        const happinessMultiplier=0.7+(st.happiness/143);\n        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);\n      }\n    }\n    const taxMultiplier=0.5+(st.taxRate/20);\n    const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);\n    \n    // Calculate maintenance (same logic as simTk) - UPDATED\n    let buildingMaintenance = 0, infrastructureCost = 0, serviceCosts = 0, crimeExpenses = 0, roadMaintenanceBonus = 0;\n    \n    // Base building maintenance\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x];\n      if (c.type==='road') buildingMaintenance+=2;\n      else if (c.type==='residential' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n        buildingMaintenance+=Math.floor(5*levelMultiplier);\n      }\n      else if (c.type==='commercial' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));\n        buildingMaintenance+=Math.floor(8*levelMultiplier);\n      }\n      else if (c.type==='industrial' && !c.abandoned) {\n        const level=c.level||0;\n        const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));\n        buildingMaintenance+=Math.floor(12*levelMultiplier);\n      }\n      else if (c.type && c.type.startsWith('park')) buildingMaintenance+=4;\n      else if (c.type==='police') buildingMaintenance+=25;\n      else if (c.type==='fire') buildingMaintenance+=25;\n      else if (c.type==='school') buildingMaintenance+=40;\n      else if (c.type==='hospital') buildingMaintenance+=60;\n    }\n    \n    // Population-based costs\n    if (st.population > 0) {\n      infrastructureCost = Math.floor(st.population * 0.5);\n      \n      // Service operation costs\n      let avgCrime = 0;\n      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n        avgCrime += st.crime[y][x] || 30;\n      }\n      avgCrime = avgCrime / (GR_SZ * GR_SZ);\n      const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100));\n      const fireOpCost = Math.floor(st.population * 0.2);\n      const educationCost = Math.floor(st.population * 0.4);\n      const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));\n      serviceCosts = policeOpCost + fireOpCost + educationCost + healthCost;\n      \n      // Crime expenses\n      if (avgCrime > 40) {\n        crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20);\n      }\n    }\n    \n    // Road maintenance bonus\n    const rdC = getCount('road');\n    roadMaintenanceBonus = Math.floor(rdC * 0.1);\n    \n    const totalMaintenance = buildingMaintenance + infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;\n    const netIncome = totalIncome - totalMaintenance;\n    \n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('balance', `$${st.money.toLocaleString()}`)}${statItem('income/mo', netIncome>=0?`+$${netIncome.toLocaleString()}`:`-$${Math.abs(netIncome).toLocaleString()}`, netIncome>=0?'text-green-500':'text-red-400')}${statItem('expenses/mo', `-$${totalMaintenance.toLocaleString()}`, 'text-red-400')}</div>\n      <div class=\"mt-4 space-y-3\">\n        <div>\n          <div class=\"text-xs text-neutral-300 mb-1\">Income Sources</div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('Residential Tax', `$${Math.floor(residentialIncome*taxMultiplier).toLocaleString()}`, 'text-green-400')}\n            ${statItem('Commercial', `$${Math.floor(commercialRevenue*taxMultiplier).toLocaleString()}`, 'text-blue-400')}\n            ${statItem('Industrial', `$${Math.floor(industrialRevenue*taxMultiplier).toLocaleString()}`, 'text-yellow-400')}\n            ${statItem('Tourism', `$${Math.floor(tourismIncome*taxMultiplier).toLocaleString()}`, 'text-emerald-400')}\n          </div>\n        </div>\n        <div>\n          <div class=\"text-xs text-neutral-300 mb-1\">Expenses Breakdown</div>\n          <div class=\"flex flex-wrap gap-6 py-2\">\n            ${statItem('Buildings', `-$${buildingMaintenance.toLocaleString()}`, 'text-red-400')}\n            ${infrastructureCost > 0 ? statItem('Infrastructure', `-$${infrastructureCost.toLocaleString()}`, 'text-red-400') : ''}\n            ${serviceCosts > 0 ? statItem('Services', `-$${serviceCosts.toLocaleString()}`, 'text-red-400') : ''}\n            ${crimeExpenses > 0 ? statItem('Crime', `-$${crimeExpenses.toLocaleString()}`, 'text-red-400') : ''}\n            ${roadMaintenanceBonus > 0 ? statItem('Roads', `-$${roadMaintenanceBonus.toLocaleString()}`, 'text-red-400') : ''}\n          </div>\n        </div>\n        <div class=\"mt-3 pt-3 border-t border-neutral-700\">\n          <label class=\"text-xs text-neutral-400 block mb-2\" id=\"taxRateLabel\">Tax Rate: ${st.taxRate}%</label>\n          <input type=\"range\" id=\"taxRateSlider\" min=\"0\" max=\"20\" value=\"${st.taxRate}\" \n            class=\"w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-green-600\"\n            oninput=\"st.taxRate=parseInt(this.value); const lbl=document.getElementById('taxRateLabel'); if(lbl) lbl.textContent='Tax Rate: '+st.taxRate+'%'; updateStatsPanel(); sv();\">\n          <div class=\"text-xs text-neutral-500 mt-1\">Lower taxes boost happiness, higher taxes boost income</div>\n        </div>\n      </div>`;\n  } else if (infoType === 'happy') {\n    title = 'Happiness';\n    let avgCrime = 0;\n    for (let y = 0; y < GR_SZ; y++) {\n      for (let x = 0; x < GR_SZ; x++) {\n        avgCrime += st.crime[y][x] || 30;\n      }\n    }\n    avgCrime = Math.floor(avgCrime / (GR_SZ * GR_SZ));\n    content = `<div class=\"flex flex-wrap gap-6 py-2\">${statItem('level', `${st.happiness}/100`)}${statItem('parks', cnts.park||0)}${statItem('services', (cnts.police||0)+(cnts.fire||0)+(cnts.school||0)+(cnts.hospital||0))}${statItem('crime', `${avgCrime}%`)}${statItem('crimes', st.crimeEvents.length)}</div><div class=\"mt-3 text-xs text-neutral-400\">Build parks, services, and police to increase</div>`;\n  }\n  \n  return { title, content };\n}\n\ndocument.getElementById('rciBtn').addEventListener('click', () => {\n  const { title, content } = getStatsContent('rci');\n  shwInfo(title, content, 'rci');\n});\n\ndocument.getElementById('popBtn').addEventListener('click', () => {\n  const { title, content } = getStatsContent('pop');\n  shwInfo(title, content, 'pop');\n});\n\ndocument.getElementById('moneyBtn').addEventListener('click', () => {\n  const { title, content } = getStatsContent('money');\n  shwInfo(title, content, 'money');\n});\n\ndocument.getElementById('happyBtn').addEventListener('click', () => {\n  const { title, content } = getStatsContent('happy');\n  shwInfo(title, content, 'happy');\n});\n\ndocument.getElementById('powerBtn').addEventListener('click', () => {\n  const { title, content } = getStatsContent('power');\n  shwInfo(title, content, 'power');\n});\n\nfunction updateStatsPanel() {\n  if (!currentInfoType) return;\n  const pnl = document.getElementById('infoPanel');\n  if (!pnl || pnl.classList.contains('hidden')) return;\n  \n  const { title, content } = getStatsContent(currentInfoType);\n  \n  if (title && content) {\n    document.getElementById('infoTitle').innerHTML = title;\n    document.getElementById('infoContent').innerHTML = content;\n  }\n}\n\nfunction hasRdAcc(x,y) {\n  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const cx=x+dx, cy=y+dy;\n    for (let ndy=-1; ndy<=1; ndy++) for (let ndx=-1; ndx<=1; ndx++) {\n      if (ndx===0 && ndy===0) continue;\n      const nx=cx+ndx, ny=cy+ndy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='road') return true;\n    }\n  }\n  return false;\n}\n\nfunction calculatePowerGrid() {\n  // Initialize power grid\n  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) {\n    st.powerGrid = [];\n    for (let y=0; y<GR_SZ; y++) {\n      const row = [];\n      for (let x=0; x<GR_SZ; x++) row.push(false);\n      st.powerGrid.push(row);\n    }\n  } else {\n    // Reset power grid\n    for (let y=0; y<GR_SZ; y++) {\n      for (let x=0; x<GR_SZ; x++) {\n        st.powerGrid[y][x] = false;\n      }\n    }\n  }\n  \n  // Find all power plants\n  const powerPlants = [];\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell = st.grid[y][x];\n      if (cell.type === 'coal' || cell.type === 'nuclear' || cell.type === 'wind') {\n        powerPlants.push({x, y});\n      }\n    }\n  }\n  \n  const distanceGrid = [];\n  for (let y=0; y<GR_SZ; y++) {\n    const row = [];\n    for (let x=0; x<GR_SZ; x++) row.push(Infinity);\n    distanceGrid.push(row);\n  }\n  \n  const visited = new Set();\n  const queue = [];\n  const poweredRoads = [];\n  \n  if (powerPlants.length > 0) {\n    // Start BFS from each power plant's adjacent road tiles\n    for (const plant of powerPlants) {\n      for (let dy=-1; dy<=1; dy++) {\n        for (let dx=-1; dx<=1; dx++) {\n          if (dx===0 && dy===0) continue;\n          const nx = plant.x + dx, ny = plant.y + dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.grid[ny][nx].type === 'road') {\n              const key = `${nx},${ny}`;\n              if (!visited.has(key)) {\n                visited.add(key);\n                queue.push({x: nx, y: ny, distance: 1});\n                poweredRoads.push({x: nx, y: ny});\n                st.powerGrid[ny][nx] = true;\n                distanceGrid[ny][nx] = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  const directions = [[0,-1], [0,1], [-1,0], [1,0]];\n  while (queue.length > 0) {\n    const current = queue.shift();\n    for (const [dx, dy] of directions) {\n      const nx = current.x + dx, ny = current.y + dy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        const key = `${nx},${ny}`;\n        if (!visited.has(key) && st.grid[ny][nx].type === 'road') {\n          visited.add(key);\n          const nextDistance = current.distance + 1;\n          queue.push({x: nx, y: ny, distance: nextDistance});\n          poweredRoads.push({x: nx, y: ny});\n          st.powerGrid[ny][nx] = true;\n          distanceGrid[ny][nx] = nextDistance;\n        }\n      }\n    }\n  }\n  \n  for (const road of poweredRoads) {\n    // Mark tiles adjacent to powered roads (including diagonals)\n    for (let dy=-1; dy<=1; dy++) {\n      for (let dx=-1; dx<=1; dx++) {\n        const nx = road.x + dx, ny = road.y + dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          if (!st.powerGrid[ny][nx]) {\n            st.powerGrid[ny][nx] = true;\n          }\n        }\n      }\n    }\n  }\n  \n  updateBuildingPowerAssignments(distanceGrid);\n}\n\nfunction getNearestPoweredRoadDistance(x,y,w,h,distanceGrid) {\n  let minDistance=Infinity;\n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx=x+dx, cy=y+dy;\n      for (let ndy=-1; ndy<=1; ndy++) {\n        for (let ndx=-1; ndx<=1; ndx++) {\n          if (ndx===0 && ndy===0) continue;\n          const nx=cx+ndx, ny=cy+ndy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            const neighbor=st.grid[ny][nx];\n            if (neighbor && neighbor.type==='road') {\n              const distance=distanceGrid[ny][nx];\n              if (Number.isFinite(distance)) {\n                minDistance=Math.min(minDistance,distance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return minDistance;\n}\n\nfunction updateBuildingPowerAssignments(distanceGrid) {\n  const assignments={};\n  const processedPowerPlants=new Set();\n  const buildingCandidates=[];\n  const processedConsumerBuildings=new Set();\n  let totalPowerGeneration=0;\n  \n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const cell=st.grid[y][x];\n      if (!cell) continue;\n      \n      if ((cell.type==='coal'||cell.type==='nuclear'||cell.type==='wind')) {\n        if (!isTopLeftCell(x,y)) continue;\n        const plantKey=getBuildingPowerKey(x,y);\n        if (plantKey && !processedPowerPlants.has(plantKey)) {\n          processedPowerPlants.add(plantKey);\n          totalPowerGeneration+=POWER_GENERATION[cell.type]||0;\n        }\n        continue;\n      }\n      \n      if (!(cell.type==='residential'||cell.type==='commercial'||cell.type==='industrial')) continue;\n      const key=getBuildingPowerKey(x,y);\n      if (!key || processedConsumerBuildings.has(key)) continue;\n      processedConsumerBuildings.add(key);\n\n      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);\n      const baseCell=st.grid[startY]?.[startX];\n      if (!baseCell) continue;\n      const consumption=getPowerConsumption(baseCell.type,baseCell.level||0);\n      if (consumption<=0) {\n        assignments[key]=true;\n        continue;\n      }\n      if (!hasPowerConnectivity(startX,startY)) {\n        assignments[key]=false;\n        continue;\n      }\n      const distance=getNearestPoweredRoadDistance(startX,startY,baseCell.w||1,baseCell.h||1,distanceGrid);\n      buildingCandidates.push({key,consumption,distance:Number.isFinite(distance)?distance:Infinity});\n    }\n  }\n  \n  buildingCandidates.sort((a,b)=>{\n    const aFinite=Number.isFinite(a.distance);\n    const bFinite=Number.isFinite(b.distance);\n    if (aFinite && bFinite && a.distance!==b.distance) return a.distance-b.distance;\n    if (aFinite!==bFinite) return aFinite?-1:1;\n    return a.consumption-b.consumption;\n  });\n  \n  let remainingPower=totalPowerGeneration;\n  for (const candidate of buildingCandidates) {\n    if (!Number.isFinite(candidate.distance)) {\n      assignments[candidate.key]=false;\n      continue;\n    }\n    if (candidate.consumption<=remainingPower) {\n      assignments[candidate.key]=true;\n      remainingPower-=candidate.consumption;\n    } else {\n      assignments[candidate.key]=false;\n    }\n  }\n  \n  st.buildingPowerAssignments=assignments;\n}\n\nfunction hasPowerConnectivity(x,y) {\n  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) return false;\n  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;\n  \n  for (let dy=0; dy<h; dy++) {\n    for (let dx=0; dx<w; dx++) {\n      const cx=x+dx, cy=y+dy;\n      // Check adjacent tiles (including diagonals)\n      for (let ndy=-1; ndy<=1; ndy++) {\n        for (let ndx=-1; ndx<=1; ndx++) {\n          if (ndx===0 && ndy===0) continue;\n          const nx=cx+ndx, ny=cy+ndy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            if (st.powerGrid[ny][nx]) return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction hasPowerAccess(x,y) {\n  const cell=st.grid[y][x];\n  if (!cell) return false;\n  const needsPower=getPowerConsumption(cell.type,cell.level||0)>0;\n  if (!needsPower) return true;\n  if (!hasPowerConnectivity(x,y)) return false;\n  const assignments=st.buildingPowerAssignments;\n  if (assignments) {\n    const key=getBuildingPowerKey(x,y);\n    if (key && Object.prototype.hasOwnProperty.call(assignments,key)) {\n      return !!assignments[key];\n    }\n  }\n  return true;\n}\n\nfunction hasSchoolCoverage(x,y) {\n  // Check if building at (x,y) is within a school's bounds (8-tile radius)\n  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;\n  // Check each cell of the building\n  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n    const cx=x+dx, cy=y+dy;\n    // Check for schools within 8-tile radius\n    for (let sdy=-8; sdy<=8; sdy++) for (let sdx=-8; sdx<=8; sdx++) {\n      const nx=cx+sdx, ny=cy+sdy;\n      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n        const d=Math.abs(sdx)+Math.abs(sdy);\n        if (d<=8 && st.grid[ny][nx].type==='school') {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction calcLV(x,y) {\n  let v=50; const tr=st.terrain[y][x];\n  if (tr==='water') for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) { const d=Math.abs(dx)+Math.abs(dy); if (d<=2) v+=(3-d)*5; }\n  }\n  let pk=0, pl=0, sv=0;\n  for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), c=st.grid[ny][nx];\n      if (c.type.startsWith('park')) { const m=(c.w||1)*(c.h||1); const sizeBoost=m>1?1.5:1; pk+=(7-d)*2*m*sizeBoost; }\n      else if (c.type==='industrial') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*2*m; }\n      else if (c.type==='coal') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*3*m; } // Coal plants pollute more than industrial\n      else if (c.type==='police'||c.type==='fire'||c.type==='school'||c.type==='hospital') sv+=(7-d);\n    }\n  }\n  v+=Math.min(pk,30); v-=Math.min(pl,40); v+=Math.min(sv,20);\n  if (!hasRdAcc(x,y)) v-=30;\n  return Math.max(0,Math.min(100,v));\n}\n\nfunction calcCrime(x,y) {\n  let c=30; const tr=st.terrain[y][x];\n  if (tr==='water'||tr==='cliff') return 0;\n  \n  // Reduce crime near police stations (8-tile radius)\n  let policeCoverage=0;\n  for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {\n    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n      const d=Math.abs(dx)+Math.abs(dy), cell=st.grid[ny][nx];\n      if (cell.type==='police' && d<=8) {\n        policeCoverage+=(9-d)*3;\n      }\n    }\n  }\n  c-=Math.min(policeCoverage,50);\n  \n  // Increase crime in high-population areas without police coverage\n  const cell=st.grid[y][x];\n  if ((cell.type==='residential'||cell.type==='commercial') && !cell.abandoned) {\n    const popDensity=(cell.w||1)*(cell.h||1)*(cell.level||0);\n    if (policeCoverage<10) c+=popDensity*5;\n  }\n  \n  // Factor in happiness (low happiness = more crime)\n  if (st.happiness<50) c+=20;\n  else if (st.happiness<70) c+=10;\n  \n  // Increase crime if no road access\n  if (!hasRdAcc(x,y)) c+=15;\n  \n  // Check for active crime events nearby\n  for (const evt of st.crimeEvents) {\n    const dx=Math.abs(x-evt.x), dy=Math.abs(y-evt.y), d=dx+dy;\n    if (d<=3) c+=Math.max(0,(4-d)*10);\n  }\n  \n  return Math.max(0,Math.min(100,c));\n}\n\nfunction updLV() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.landValue[y][x]=calcLV(x,y); }\nfunction updCrime() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.crime[y][x]=calcCrime(x,y); }\n\nfunction calcDmd(rC,cC,iC,p) {\n  let rD=50, cD=50, iD=50; const tZ=rC+cC+iC;\n  if (tZ===0) { rD=80; cD=40; iD=40; }\n  else {\n    const iR={r:0.5,c:0.25,i:0.25}, aR={r:rC/tZ,c:cC/tZ,i:iC/tZ};\n    rD=Math.max(0,Math.min(100,50+(iR.r-aR.r)*200)); cD=Math.max(0,Math.min(100,50+(iR.c-aR.c)*200)); iD=Math.max(0,Math.min(100,50+(iR.i-aR.i)*200));\n    if (p>0) { const jA=cC*5+iC*8, jN=p*0.6; if (jA<jN) { cD=Math.min(100,cD+20); iD=Math.min(100,iD+20); } }\n    if (st.happiness<50) rD=Math.max(0,rD-20); else if (st.happiness>80) rD=Math.min(100,rD+10);\n  }\n  return {rDemand:rD,cDemand:cD,iDemand:iD};\n}\n\nfunction cleanupNewsEvents() {\n  // Remove all event messages (fire, robbery, earthquake, etc.) - they have emojis\n  st.newsEvents = st.newsEvents.filter(ev => !ev.includes('üî•') && !ev.includes('üö®') && !ev.includes('üåé'));\n  \n  // Keep only the 3 most recent AI news items\n  const aiNews = st.newsEvents.filter(ev => !ev.includes('Welcome to'));\n  const welcomeMsgs = st.newsEvents.filter(ev => ev.includes('Welcome to'));\n  st.newsEvents = [...welcomeMsgs, ...aiNews.slice(-3)];\n}\n\nasync function genNws() {\n  if (aiReq) return; aiReq=true;\n  cleanupNewsEvents(); // Clean old events and AI news before generating new one\n  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);\n  const ctx=`${st.cityName}, ${st.year}, pop ${st.population}, $${(st.money/1000).toFixed(0)}k, happiness ${st.happiness}, ${cnts.residential||0}R ${cnts.commercial||0}C ${cnts.industrial||0}I`;\n  const prm=`Generate ONE dramatic news headline (8 words max) for SimCity game. Context: ${ctx}. Topics: politics, pop culture, tech, disasters, economy, society. Include brief stat at end like (+200 pop) or (-$2k) or (+5 joy). Be punchy and dramatic. Return ONLY headline.`;\n  try {\n    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});\n    if (!r.ok) throw new Error('AI request failed');\n    const d=await r.json(); let ev=d.reply||'City continues to grow';\n    ev=ev.replace(/^[\"']|[\"']$/g,'').trim();\n    const m=ev.match(/\\(([^)]+)\\)/);\n    if (m) {\n      const ch=m[1];\n      if (ch.includes('pop')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0); st.population=Math.max(0,st.population+vl); }\n      else if (ch.includes('$')||ch.includes('k')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0), mt=ch.includes('k')?1000:1; st.money+=vl*mt; }\n      else if (ch.includes('joy')||ch.includes('happiness')) { const vl=parseInt(ch.match(/-?\\d+/)?.[0]||0); st.happiness=Math.max(0,Math.min(100,st.happiness+vl)); }\n    }\n    st.newsEvents.push(ev);\n    nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();\n  } catch(e) { console.error('News generation error:',e); } finally { aiReq=false; }\n}\nfunction tryMrgPark(x,y) {\n  const c=st.grid[y][x]; if (!c||!c.type.startsWith('park')) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  \n  // Try to merge 2x1 tiles into 2x2\n  if (c.w===2&&c.h===1) {\n    // Check if there's a 2x1 tile directly above or below\n    const checkAbove=y>0 && x+1<GR_SZ;\n    const checkBelow=y+1<GR_SZ && x+1<GR_SZ;\n    \n    if (checkAbove) {\n      const above=st.grid[y-1][x];\n      if (above.type===c.type&&above.w===2&&above.h===1 && y-1>=0 && x+1<GR_SZ && st.grid[y-1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y-1>=0 && y<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y-1+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkBelow) {\n      const below=st.grid[y+1][x];\n      if (below.type===c.type&&below.w===2&&below.h===1 && y+1<GR_SZ && x+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Try to merge 1x2 tiles into 2x2\n  if (c.w===1&&c.h===2) {\n    // Check if there's a 1x2 tile directly left or right\n    const checkLeft=x>0 && y+1<GR_SZ;\n    const checkRight=x+1<GR_SZ && y+1<GR_SZ;\n    \n    if (checkLeft) {\n      const left=st.grid[y][x-1];\n      if (left.type===c.type&&left.w===1&&left.h===2 && x-1>=0 && y+1<GR_SZ && st.grid[y+1][x-1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x-1>=0 && x<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x-1+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    \n    if (checkRight) {\n      const right=st.grid[y][x+1];\n      if (right.type===c.type&&right.w===1&&right.h===2 && x+1<GR_SZ && y+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {\n        // Merge into 2x2 - ensure all cells are within bounds\n        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {\n          const buildingId = nextBuildingId++;\n          for (let dy=0; dy<2; dy++) {\n            for (let dx=0; dx<2; dx++) {\n              const nx=x+dx, ny=y+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n  }\n  \n  // Original logic: merge 1x1 tiles\n  if (c.w!==1||c.h!==1) return false;\n  \n  // Try to merge with adjacent parks of the same type\n  const dirs=[{dx:0,dy:0,w:2,h:2},{dx:-1,dy:0,w:2,h:1},{dx:0,dy:-1,w:1,h:2},{dx:-1,dy:-1,w:2,h:2},{dx:0,dy:0,w:2,h:1},{dx:0,dy:0,w:1,h:2}];\n  for (const d of dirs) {\n    const sx=x+d.dx, sy=y+d.dy;\n    if (sx<0||sy<0||sx+d.w>GR_SZ||sy+d.h>GR_SZ) continue;\n    \n    // Check if all cells in the area are the same park type and 1x1\n    let canMerge=true;\n    for (let dy=0; dy<d.h; dy++) for (let dx=0; dx<d.w; dx++) {\n      const nx=sx+dx, ny=sy+dy, nb=st.grid[ny][nx];\n      if (nb.type!==c.type||nb.w!==1||nb.h!==1) { canMerge=false; break; }\n    }\n    \n    if (canMerge) {\n      // Merge the parks - ensure all cells are within bounds\n      const buildingId = nextBuildingId++;\n      for (let dy=0; dy<d.h; dy++) {\n        for (let dx=0; dx<d.w; dx++) {\n          const nx=sx+dx, ny=sy+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:d.w,h:d.h,buildingId:buildingId};\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n// First step: merge 1x1 buildings to 2x1 or 1x2\nfunction tryMrgTo2x1(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge mature 1x1 buildings\n  const w=c.w||1, h=c.h||1;\n  if (w!==1 || h!==1) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const targets=[\n    {dx:1, dy:0, w:2, h:1}, // Merge to the right (2x1)\n    {dx:0, dy:1, w:1, h:2}  // Merge downward (1x2)\n  ];\n  \n  for (const target of targets) {\n    const adjX=x+target.dx, adjY=y+target.dy;\n    if (adjX<0||adjX>=GR_SZ||adjY<0||adjY>=GR_SZ) continue;\n    const adj=st.grid[adjY][adjX];\n    if (!adj) continue;\n    if (adj.type!==c.type) continue;\n    if ((adj.w||1)!==1 || (adj.h||1)!==1) continue;\n    \n    const adjLevel=adj.level||0;\n    if (adjLevel<=0 && !adj.abandoned) continue; // keep level-0 zones 1x1\n    \n    const topLeftX=Math.min(x,adjX);\n    const topLeftY=Math.min(y,adjY);\n    const bestAge=Math.max(c.age||0,adj.age||0);\n    const bestLevel=Math.max(1,Math.min(c.level||1,adj.level||c.level||1));\n    const isAbandoned=c.abandoned && adj.abandoned;\n    \n    const buildingId = nextBuildingId++;\n    for (let dy=0; dy<target.h; dy++) {\n      for (let dx=0; dx<target.w; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n          st.grid[ny][nx]={type:c.type,age:bestAge,level:bestLevel,w:target.w,h:target.h,abandoned:isAbandoned,buildingId:buildingId};\n        }\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction tryMrg(x,y) {\n  const c=st.grid[y][x]; if (!c) return false;\n  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;\n  \n  // Only merge buildings that are 1x2 or 2x1 (not 1x1 - those merge first)\n  const w=c.w||1, h=c.h||1;\n  if (!((w===1&&h===2) || (w===2&&h===1))) return false;\n  if (!isTopLeftCell(x,y)) return false;\n  if (c.level<=0 || c.abandoned) return false;\n  \n  const baseLevel=Math.max(1,c.level||1);\n  const baseAge=c.age||0;\n  const expansions=[];\n  \n  if (w===2 && h===1) {\n    if (y>0) expansions.push({topLeftX:x, topLeftY:y-1, fillCells:[{x:x,y:y-1},{x:x+1,y:y-1}]});\n    if (y+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x,y:y+1},{x:x+1,y:y+1}]});\n  } else if (w===1 && h===2) {\n    if (x>0) expansions.push({topLeftX:x-1, topLeftY:y, fillCells:[{x:x-1,y:y},{x:x-1,y:y+1}]});\n    if (x+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x+1,y:y},{x:x+1,y:y+1}]});\n  }\n  \n  for (const option of expansions) {\n    const {topLeftX, topLeftY, fillCells}=option;\n    if (topLeftX<0 || topLeftY<0 || topLeftX+1>=GR_SZ || topLeftY+1>=GR_SZ) continue;\n    \n    let canExpand=true;\n    let mergedAge=baseAge;\n    for (const pos of fillCells) {\n      if (pos.x<0 || pos.x>=GR_SZ || pos.y<0 || pos.y>=GR_SZ) { canExpand=false; break; }\n      const target=st.grid[pos.y][pos.x];\n      if (!target) { canExpand=false; break; }\n      if (target.type!==c.type) { canExpand=false; break; }\n      if ((target.w||1)!==1 || (target.h||1)!==1) { canExpand=false; break; }\n      const targetLevel=target.level||0;\n      if (targetLevel>0 && !target.abandoned) { canExpand=false; break; }\n      mergedAge=Math.max(mergedAge,target.age||0);\n    }\n    \n    if (!canExpand) continue;\n    \n    const buildingId = nextBuildingId++;\n    for (let dy=0; dy<2; dy++) {\n      for (let dx=0; dx<2; dx++) {\n        const nx=topLeftX+dx, ny=topLeftY+dy;\n        st.grid[ny][nx]={type:c.type,age:mergedAge,level:baseLevel,w:2,h:2,abandoned:false,buildingId:buildingId};\n      }\n    }\n    return true;\n  }\n  \n  return false;\n}\n\nfunction updFires() {\n  st.fires=st.fires.filter(f => {\n    f.age++;\n    \n    // Count fire trucks at scene (from vehicles that have arrived)\n    const trucksAtScene = st.cars.filter(c => \n      c.mission && \n      c.mission.type === 'fire' && \n      c.mission.arrived && \n      c.mission.targetX === f.x && \n      c.mission.targetY === f.y\n    ).length;\n    \n    // Fires REQUIRE fire trucks to be extinguished - they won't go out on their own\n    // With trucks: extinguish faster (10 ticks per truck, min 5 ticks)\n    // Without trucks: fire continues indefinitely (but building will eventually be destroyed)\n    if (trucksAtScene === 0) {\n      // No fire trucks - fire continues burning\n      // After 60 ticks without trucks, building is destroyed anyway\n      if (f.age > 60) {\n        sendEmergencyVehiclesHome('fire', f.x, f.y);\n        \n        const cell=st.grid[f.y][f.x];\n        if (cell && cell.type!=='empty') {\n          const bounds=getBuildingBoundsFromCell(f.x,f.y);\n          const w=bounds.w||1, h=bounds.h||1;\n          for (let dy=0; dy<h; dy++) {\n            for (let dx=0; dx<w; dx++) {\n              const nx=bounds.startX+dx, ny=bounds.startY+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                normalizeEmptyCell(nx,ny);\n              }\n            }\n          }\n        }\n        return false; // Remove fire after building destroyed\n      }\n      return true; // Keep fire burning\n    }\n    \n    // Fire trucks are at scene - extinguish fire\n    // More trucks = faster extinguishing (15 ticks with 1 truck, down to 5 ticks with 3+ trucks)\n    const maxAge = trucksAtScene >= 1 ? Math.max(5, 15 - (trucksAtScene - 1) * 5) : 60;\n    \n    if (f.age>maxAge) { \n      sendEmergencyVehiclesHome('fire', f.x, f.y);\n      \n      // If fire trucks arrived (trucksAtScene > 0), save the building\n      if (trucksAtScene > 0) {\n        // Fire extinguished successfully - building saved!\n        return false; // Remove fire\n      } else {\n        // No fire trucks - building destroyed\n        const cell=st.grid[f.y][f.x];\n        if (cell && cell.type!=='empty') {\n          const bounds=getBuildingBoundsFromCell(f.x,f.y);\n          const w=bounds.w||1, h=bounds.h||1;\n          for (let dy=0; dy<h; dy++) {\n            for (let dx=0; dx<w; dx++) {\n              const nx=bounds.startX+dx, ny=bounds.startY+dy;\n              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n                normalizeEmptyCell(nx,ny);\n              }\n            }\n          }\n        }\n        return false; \n      }\n    }\n    const c=st.grid[f.y][f.x]; if (c.type==='empty') return false;\n    let hasFr=false; for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {\n      const nx=f.x+dx, ny=f.y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='fire') hasFr=true;\n    }\n    // With fire trucks, fires can be extinguished earlier\n    const minAgeForSpread = trucksAtScene > 0 ? 5 : 10;\n    if (hasFr && f.age>minAgeForSpread) return false; return true;\n  });\n}\n\nfunction startFire() {\n  const blds=[]; for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x]; if ((c.type==='residential'||c.type==='commercial'||c.type==='industrial') && !c.abandoned) blds.push({x,y});\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)]; \n    st.fires.push({x:b.x,y:b.y,age:0,fireTrucksAtScene:0});\n    \n    // Dispatch fire truck from nearest fire station\n    const dispatched = dispatchEmergencyVehicle('fire', b.x, b.y, 'fire');\n    if (dispatched) {\n      st.newsEvents.push(`üî• Fire breaks out in ${st.cityName}! Fire truck dispatched. (-$5k)`);\n    } else {\n      st.newsEvents.push(`üî• Fire breaks out in ${st.cityName}! No fire station nearby! (-$5k)`);\n    }\n    st.money-=5000;\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\n\nfunction startQuake() {\n  const gr=document.getElementById('grid'); gr.classList.add('earthquake');\n  setTimeout(() => gr.classList.remove('earthquake'),500);\n  const blds=[]; \n  const processedBuildings=new Set(); // Track buildings we've already added\n  \n  // Collect buildings, but only add the top-left cell of each building\n  for (let y=0; y<GR_SZ; y++) {\n    for (let x=0; x<GR_SZ; x++) {\n      const c=st.grid[y][x]; \n      if (c.type==='empty' || c.type==='road') continue;\n      \n      // Skip level 0 RCI zones (empty zones), but allow abandoned buildings\n      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';\n      if (isZone && (c.level||0)===0 && !c.abandoned) continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only add the top-left cell of each building to avoid duplicates\n      // Check if this is the top-left cell\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (isTopLeft) {\n        // Ensure this building's footprint does not include any roads (which can happen\n        // with older saves or after complex merges next to roads)\n        let hasRoadInFootprint=false;\n        for (let dy=0; dy<h && !hasRoadInFootprint; dy++) {\n          for (let dx=0; dx<w; dx++) {\n            const nx=x+dx, ny=y+dy;\n            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n              if (st.grid[ny][nx].type==='road') {\n                hasRoadInFootprint=true;\n                break;\n              }\n            }\n          }\n        }\n        if (hasRoadInFootprint) continue;\n\n        const buildingKey=`${x},${y},${c.type},${w},${h}`;\n        if (!processedBuildings.has(buildingKey)) {\n          processedBuildings.add(buildingKey);\n          blds.push({x,y,w,h});\n        }\n      }\n    }\n  }\n  \n  const dmg=Math.min(5,Math.floor(blds.length*0.1));\n  for (let i=0; i<dmg; i++) {\n    if (blds.length>0) {\n      const b=blds.splice(Math.floor(Math.random()*blds.length),1)[0];\n      // Destroy all cells that are part of this building using robust bounds\n      const bounds=getBuildingBoundsFromCell(b.x,b.y);\n      const w=bounds.w||1, h=bounds.h||1;\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=bounds.startX+dx, ny=bounds.startY+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            // Only destroy if it's not a road\n            if (st.grid[ny][nx].type!=='road') {\n              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};\n              normalizeEmptyCell(nx,ny); // Ensure it's 1x1\n            }\n          }\n        }\n      }\n    }\n  }\n  st.newsEvents.push(`üåé Earthquake hits ${st.cityName}! ${dmg} buildings damaged (-$10k)`); st.money-=10000;\n  nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n}\n\nfunction updCrimeEvents() {\n  st.crimeEvents=st.crimeEvents.filter(evt => {\n    evt.age++;\n    \n    // Count police cars at scene (from vehicles that have arrived)\n    const policeAtScene = st.cars.filter(c => \n      c.mission && \n      c.mission.type === 'crime' && \n      c.mission.arrived && \n      c.mission.targetX === evt.x && \n      c.mission.targetY === evt.y\n    ).length;\n    \n    // Crimes REQUIRE police cars to resolve - they won't resolve on their own\n    // Without police cars: crime continues indefinitely (causing ongoing costs)\n    if (policeAtScene === 0) {\n      // No police cars - crime continues\n      // After 100 ticks without police, crime eventually stops (but damage is done)\n      if (evt.age > 100) {\n        // Crime resolved after long time without police (but should have been handled)\n        return false;\n      }\n      // Continue costing money while crime is active\n      if (evt.age % 10 === 0) {\n        st.money -= 500; // Ongoing cost every 10 ticks\n      }\n      return true; // Keep crime active\n    }\n    \n    // Police cars are at scene - resolve crime quickly\n    // Resolve faster with more cars: 5 ticks per car (min 2 ticks)\n    const maxAge = Math.max(2, 20 - policeAtScene * 5);\n    \n    if (evt.age>maxAge) {\n      sendEmergencyVehiclesHome('crime', evt.x, evt.y);\n      return false;\n    }\n    return true;\n  });\n}\n\nfunction startCrimeEvent() {\n  const blds=[];\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    // Higher crime areas are more likely to have crime events\n    const crimeLevel=st.crime[y][x]||30;\n    if ((c.type==='residential'||c.type==='commercial') && !c.abandoned && crimeLevel>40) {\n      // Weight by crime level - higher crime = more likely\n      for (let i=0; i<Math.floor(crimeLevel/20); i++) blds.push({x,y,crimeLevel});\n    }\n  }\n  if (blds.length>0) {\n    const b=blds[Math.floor(Math.random()*blds.length)];\n    const crimeTypes=['robbery','break-in','vandalism'];\n    const crimeType=crimeTypes[Math.floor(Math.random()*crimeTypes.length)];\n    st.crimeEvents.push({x:b.x,y:b.y,type:crimeType,age:0,policeCarsAtScene:0});\n    \n    // Dispatch police car from nearest police station\n    const dispatched = dispatchEmergencyVehicle('police', b.x, b.y, 'crime');\n    const cost=Math.floor(Math.random()*3000)+2000;\n    st.money-=cost;\n    const dispatchedMsg = dispatched ? ' Police car dispatched.' : ' No police station nearby!';\n    const msg=crimeType==='robbery'?`üö® Robbery reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`:\n           crimeType==='break-in'?`üö® Break-in reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`:\n           `üö® Vandalism reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`;\n    st.newsEvents.push(msg);\n    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();\n  }\n}\nfunction simTk() {\n  st.tickCount++; st.ticksSinceNews++;\n  if (st.tickCount%12===0) {\n    st.year++;\n    // Clean up old event messages and AI news every year\n    cleanupNewsEvents();\n  }\n  // Recalculate power grid each tick\n  calculatePowerGrid();\n  let rC=0, cC=0, iC=0, pC=0, poC=0, fC=0, sC=0, hC=0, rdC=0; const cntd={};\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const k=`${x},${y}`; if (cntd[k]) continue;\n    const c=st.grid[y][x]; \n    // Normalize empty cells to ensure they're always 1x1\n    if (c.type==='empty') normalizeEmptyCell(x,y);\n    if (c.type!=='empty') {\n      const w=c.w||1, h=c.h||1;\n      // Only increment age once per building (only for the top-left cell being processed)\n      c.age++;\n      // For multi-tile buildings, sync age to all cells\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=x+dx, ny=y+dy;\n          if (nx<GR_SZ && ny<GR_SZ) {\n            st.grid[ny][nx].age = c.age; // Sync age across all cells\n          }\n          cntd[`${nx},${ny}`]=true;\n        }\n      }\n    }\n    if (c.type==='residential') rC++; else if (c.type==='commercial') cC++; else if (c.type==='industrial') iC++;\n    else if (c.type.startsWith('park')) pC++;     else if (c.type==='police') poC++; else if (c.type==='fire') fC++;\n    else if (c.type==='school') sC++; else if (c.type==='hospital') hC++; else if (c.type==='road') rdC++;\n    else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {\n      // Count power plants (for stats)\n    }\n  }\n  updLV();\n  updCrime();\n  // Track processed buildings to avoid duplicate updates for merged buildings\n  const processedBuildings = new Set();\n  const processedCells = new Set(); // Track individual cells that have been processed\n  \n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential'||c.type==='commercial'||c.type==='industrial') {\n      // Skip if this cell has already been processed (e.g., as part of a merged building)\n      const cellKey = `${x},${y}`;\n      if (processedCells.has(cellKey)) continue;\n      \n      const w=c.w||1, h=c.h||1;\n      // Only process the top-left cell of each building\n      let isTopLeft=true;\n      if (w>1 || h>1) {\n        // Check if there's a cell to the left or above with the same building\n        if (x>0) {\n          const leftCell=st.grid[y][x-1];\n          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n        if (y>0) {\n          const aboveCell=st.grid[y-1][x];\n          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {\n            isTopLeft=false;\n          }\n        }\n      }\n      \n      if (!isTopLeft) continue;\n      \n      // Skip if this building has already been processed\n      const buildingKey = `${x},${y},${c.type},${w},${h}`;\n      if (processedBuildings.has(buildingKey)) continue;\n      processedBuildings.add(buildingKey);\n      \n      // Mark all cells of this building as processed\n      for (let dy=0; dy<h; dy++) {\n        for (let dx=0; dx<w; dx++) {\n          const nx=x+dx, ny=y+dy;\n          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n            processedCells.add(`${nx},${ny}`);\n          }\n        }\n      }\n      \n      const lv=st.landValue[y][x], hr=hasRdAcc(x,y), mv=c.type==='industrial'?10:20;\n      const level = c.level || 0;\n      \n        // Check power requirements\n        const needsPower = getPowerConsumption(c.type, level) > 0;\n      \n      const hasPower = hasPowerAccess(x, y);\n      \n      // Track ticks without road access\n      if (!hr) {\n        c.ticksNoRoad = (c.ticksNoRoad || 0) + 1;\n      } else {\n        c.ticksNoRoad = 0;\n      }\n      \n      // Track ticks without power (if building needs it)\n      if (needsPower && !hasPower) {\n        c.ticksNoPower = (c.ticksNoPower || 0) + 1;\n      } else {\n        c.ticksNoPower = 0;\n      }\n      \n      // Immediate abandonment if land value too low OR no power for extended period (15 ticks)\n      if (lv<mv || (needsPower && !hasPower && c.ticksNoPower > 15)) { \n        c.abandoned=true;\n        // Keep level but mark as abandoned - don't set to 0\n        // Update all cells of merged building\n        const w=c.w||1, h=c.h||1;\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=true;\n          }\n        }\n      }\n      // Gradual decline without road access\n      else if (!hr) {\n        // Downgrade every 3 ticks without road\n        if (c.ticksNoRoad > 3 && c.level > 1) {\n          c.level--;\n          c.ticksNoRoad = 0; // Reset counter after downgrade\n          // Update all cells of merged building\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n          }\n        }\n        // Become abandoned after being at level 1 for 5 ticks without road\n        else if (c.ticksNoRoad > 5 && c.level >= 1) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n        // Immediately abandon if no road for 10+ ticks\n        else if (c.ticksNoRoad > 10) {\n          c.abandoned = true;\n          // Keep the level, just mark as abandoned\n          const w=c.w||1, h=c.h||1;\n          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n            if (x+dx<GR_SZ && y+dy<GR_SZ) {\n              st.grid[y+dy][x+dx].abandoned=true;\n            }\n          }\n        }\n      }\n      else {\n        c.abandoned=false;\n        // Update all cells of merged building to un-abandon\n        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n          if (x+dx<GR_SZ && y+dy<GR_SZ) {\n            st.grid[y+dy][x+dx].abandoned=false;\n          }\n        }\n        \n        // Check for downgrades first (more important)\n        let downgraded = false;\n        \n        // Downgrade if no power and building needs it (after 5 ticks)\n        if (needsPower && !hasPower && c.ticksNoPower > 5 && c.level > 0) {\n          // For residential: downgrade L3->L2, L2->L1 (but L1 doesn't need power so stop there)\n          // For commercial/industrial: downgrade by 1 level\n          if (c.type === 'residential' && c.level >= 2) {\n            const newLevel = c.level - 1;\n            c.level = newLevel;\n            downgraded = true;\n            c.ticksNoPower = 0;\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          } else if ((c.type === 'commercial' || c.type === 'industrial') && c.level > 1) {\n            const newLevel = c.level - 1;\n            c.level = newLevel;\n            downgraded = true;\n            c.ticksNoPower = 0;\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          }\n        }\n        \n        if (!downgraded) {\n          if (lv<30 && c.level>1) { \n            const newLevel = Math.max(1,c.level-1);\n            c.level = newLevel;\n            downgraded = true;\n            // Update all cells of merged building\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;\n            }\n          }\n          // Level 3 downgrades: need land value >= 40 AND school coverage (same criteria as upgrade)\n          else if (c.level===3 && (lv<40 || !hasSchoolCoverage(x,y))) { \n            c.level=2; \n            downgraded = true;\n            // Update all cells of merged building\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=2;\n            }\n          }\n        }\n        \n          // Upgrade logic - only if not downgraded, gradual one level at a time\n          // Slowed down upgrades: require more age and better conditions\n          // Also require power if building needs it\n          if (!downgraded) {\n            let upgraded = false;\n            // Level 0 -> 1: needs age > 10 ticks (was 5)\n            if (c.level===0 && c.age>10) {\n              // Check if level 1 would need power\n              const wouldNeedPower = (c.type === 'commercial' || c.type === 'industrial');\n              if (!wouldNeedPower || hasPower) {\n                c.level=1;\n                upgraded = true;\n              }\n            }\n            // Level 1 -> 2: needs age > 30 AND land value > 55 (was 15 and 50)\n            // For residential: also needs power (L2 requires power)\n            // For commercial/industrial: also needs power\n            else if (c.level===1 && c.age>30 && lv>55) {\n              if (hasPower) {\n                c.level=2;\n                upgraded = true;\n              }\n            }\n            // Level 2 -> 3: needs age > 50 AND land value >= 40 AND school coverage\n            // Also needs power (L3 requires power for residential, commercial, industrial)\n            else if (c.level===2 && c.age>50 && lv>=40 && hasSchoolCoverage(x,y)) {\n              if (hasPower) {\n                c.level=3;\n                upgraded = true;\n              }\n            }\n          \n          // Update all cells of merged building if upgraded\n          if (upgraded) {\n            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {\n              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;\n            }\n          }\n        }\n        \n        // Two-step merging process:\n        // Step 1: Try to merge 1x1 buildings to 2x1 or 1x2 first\n        if (c.age>8 && w===1 && h===1 && c.level>0) {\n          const merged=tryMrgTo2x1(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged building as processed\n            // The merged building is now 2x1 or 1x2, so we need to update processedCells\n            // But we don't know which direction it merged, so we'll let the next iteration handle it\n            // For now, just mark the current cell as processed\n            processedCells.add(`${x},${y}`);\n            if (x+1<GR_SZ) processedCells.add(`${x+1},${y}`); // If merged right (2x1)\n            if (y+1<GR_SZ) processedCells.add(`${x},${y+1}`); // If merged down (1x2)\n          }\n        }\n        // Step 2: Try to merge 2x1 or 1x2 buildings to 2x2 (only if at least one is 2x1/1x2)\n        if (c.age>12 && ((w===1&&h===2) || (w===2&&h===1)) && c.level>0) {\n          // Only try merge if this is the top-left cell of the building\n          // For 1x2: always top-left (spans down)\n          // For 2x1: always top-left (spans right)\n          const merged=tryMrg(x,y);\n          if (merged) {\n            // Mark all cells of the newly merged 2x2 building as processed\n            // After merge, the grid has been updated with a 2x2 building\n            // Check the current cell and nearby cells to find the 2x2 building's top-left\n            let found2x2=false;\n            for (let checkY=Math.max(0,y-1); checkY<=Math.min(GR_SZ-2,y+1) && !found2x2; checkY++) {\n              for (let checkX=Math.max(0,x-1); checkX<=Math.min(GR_SZ-2,x+1) && !found2x2; checkX++) {\n                const checkCell=st.grid[checkY][checkX];\n                if (checkCell.type===c.type && (checkCell.w||1)===2 && (checkCell.h||1)===2) {\n                  // This is the top-left of the merged 2x2 building\n                  // Mark all 4 cells as processed\n                  for (let dy=0; dy<2; dy++) {\n                    for (let dx=0; dx<2; dx++) {\n                      const nx=checkX+dx, ny=checkY+dy;\n                      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {\n                        processedCells.add(`${nx},${ny}`);\n                      }\n                    }\n                  }\n                  found2x2=true;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else if (c.type.startsWith('park')) {\n      // Try to merge parks of the same type\n      tryMrgPark(x,y);\n    }\n  }\n  const bPR=10; let nP=0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n      const sM=(c.w||1)*(c.h||1), lM=c.level===3?1.5:(c.level===2?1.2:1);\n      nP+=Math.floor(bPR*sM*lM);\n    }\n  }\n  st.population=nP;\n  const jA=cC*5+iC*8, jN=nP*0.6;\n  if (jA<=0 || jN<=0) st.employment=0;\n  else st.employment=Math.min(100,Math.floor((Math.min(jA,jN)/jN)*100));\n  \n  // IMPROVED ECONOMY CALCULATIONS\n  // 1. Residential tax income (scaled by level and land value)\n  let residentialIncome = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseTax=2.5; // Base tax per person (increased to balance expenses)\n      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n      const landValueMultiplier=1+(lv-50)/100; // +1% per point above 50\n      const popPerCell=Math.floor(10*size*levelMultiplier);\n      residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);\n    }\n  }\n  \n  // 2. Commercial revenue (based on population served, level, land value, employment)\n  let commercialRevenue = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseRevenue=18; // Base revenue per cell (increased to balance expenses)\n      const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));\n      const landValueMultiplier=1+(lv-50)/80;\n      const employmentMultiplier=0.5+(st.employment/200); // 0.5x to 1.0x based on employment\n      const populationMultiplier=Math.min(2.0,1+(st.population/5000)); // More population = more customers\n      commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);\n    }\n  }\n  \n  // 3. Industrial revenue (based on employment, level, land value)\n  let industrialRevenue = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {\n      const lv=st.landValue[y][x]||50;\n      const level=c.level||0;\n      const size=(c.w||1)*(c.h||1);\n      const baseRevenue=24; // Base revenue per cell (increased to balance expenses)\n      const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));\n      const landValueMultiplier=1+(lv-50)/100;\n      const employmentMultiplier=0.4+(st.employment/167); // 0.4x to 1.0x based on employment\n      industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);\n    }\n  }\n  \n  // 4. Tourism income from parks (scaled by park size and city population)\n  let tourismIncome = 0;\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type && c.type.startsWith('park')) {\n      const size=(c.w||1)*(c.h||1);\n        const baseTourism=6; // Base tourism per cell (increased to balance expenses)\n        const populationMultiplier=Math.min(3.0,1+(st.population/3000)); // More people = more visitors\n        const happinessMultiplier=0.7+(st.happiness/143); // Higher happiness = more tourism\n        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);\n    }\n  }\n  \n  // 5. Apply tax rate multiplier (taxRate is 0-20, convert to 0.5-1.5 multiplier)\n  const taxMultiplier=0.5+(st.taxRate/20); // 10% tax = 1.0x, 20% = 1.5x, 0% = 0.5x\n  const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);\n  \n  // 6. Improved maintenance (scaled by building level) - INCREASED COSTS\n  let totalMaintenance = 0;\n  \n  // Base building maintenance (increased)\n  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n    const c=st.grid[y][x];\n    if (c.type==='road') totalMaintenance+=2; // Increased from 1\n    else if (c.type==='residential' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));\n      totalMaintenance+=Math.floor(5*levelMultiplier); // Increased from 2\n    }\n    else if (c.type==='commercial' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));\n      totalMaintenance+=Math.floor(8*levelMultiplier); // Increased from 3\n    }\n    else if (c.type==='industrial' && !c.abandoned) {\n      const level=c.level||0;\n      const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));\n      totalMaintenance+=Math.floor(12*levelMultiplier); // Increased from 5\n    }\n    else if (c.type && c.type.startsWith('park')) totalMaintenance+=4; // Increased from 2\n    else if (c.type==='police') totalMaintenance+=25; // Increased from 10\n    else if (c.type==='fire') totalMaintenance+=25; // Increased from 10\n    else if (c.type==='school') totalMaintenance+=40; // Increased from 15\n    else if (c.type==='hospital') totalMaintenance+=60; // Increased from 20\n  }\n  \n  // Population-based infrastructure costs (utilities, waste management, etc.)\n  const infrastructureCost = Math.floor(st.population * 0.5); // $0.50 per person\n  \n  // Service operation costs (based on population served)\n  let serviceCosts = 0;\n  if (st.population > 0) {\n    // Police operation cost (scales with population and crime)\n    let avgCrime = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime += st.crime[y][x] || 30;\n    }\n    avgCrime = avgCrime / (GR_SZ * GR_SZ);\n    const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100)); // Higher crime = more police costs\n    serviceCosts += policeOpCost;\n    \n    // Fire department operation cost\n    const fireOpCost = Math.floor(st.population * 0.2);\n    serviceCosts += fireOpCost;\n    \n    // Education costs (scales with population)\n    const educationCost = Math.floor(st.population * 0.4);\n    serviceCosts += educationCost;\n    \n    // Healthcare costs (scales with population and affected by happiness)\n    const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));\n    serviceCosts += healthCost;\n  }\n  \n  // Crime-related expenses (damage, insurance, etc.)\n  let crimeExpenses = 0;\n  if (st.population > 0) {\n    let avgCrime = 0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime += st.crime[y][x] || 30;\n    }\n    avgCrime = avgCrime / (GR_SZ * GR_SZ);\n    if (avgCrime > 40) {\n      crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20); // $1 per person per 20 crime points above 40\n    }\n  }\n  \n  // Road maintenance (increases with city size and traffic)\n  const roadMaintenanceBonus = Math.floor(rdC * 0.1); // Additional cost for extensive road networks\n  \n  totalMaintenance += infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;\n  \n  const inc=totalIncome, mnt=totalMaintenance;\n  st.money+=inc-mnt;\n  let hp=70;\n  if (st.population>0) {\n    const pR=pC/(rC+1); hp+=Math.min(pR*50,15);\n    const sR=(poC+fC+sC+hC)/(st.population/100+1); hp+=Math.min(sR*20,10);\n    const jR=(cC+iC)/(rC+1); if (jR<0.5) hp-=10; else if (jR>2) hp-=5;\n    if (st.money<0) hp-=15;\n    // Tax rate affects happiness: 10% is neutral, lower = happier, higher = unhappier\n    const taxImpact=(st.taxRate-10)*0.8; // -8 to +8 happiness based on tax rate (0-20%)\n    hp-=taxImpact;\n    // Factor in crime - calculate average city crime\n    let avgCrime=0;\n    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {\n      avgCrime+=st.crime[y][x]||30;\n    }\n    avgCrime=avgCrime/(GR_SZ*GR_SZ);\n    // High crime reduces happiness (up to -15 points)\n    if (avgCrime>60) hp-=Math.min(15,Math.floor((avgCrime-60)/2));\n    else if (avgCrime>40) hp-=Math.min(8,Math.floor((avgCrime-40)/3));\n    // Police coverage improves happiness\n    if (poC>0 && st.population>0) {\n      const policeRatio=poC/(st.population/500+1);\n      hp+=Math.min(5,policeRatio*2);\n    }\n  }\n  st.happiness=Math.max(0,Math.min(100,Math.floor(hp)));\n  const dmd=calcDmd(rC,cC,iC,st.population); st.rDemand=Math.floor(dmd.rDemand); st.cDemand=Math.floor(dmd.cDemand); st.iDemand=Math.floor(dmd.iDemand);\n  const tB=rC+cC+iC+pC+poC+fC+sC+hC;\n  if (st.ticksSinceNews>=20 && tB>5 && !aiReq) { st.ticksSinceNews=0; genNws(); }\n    if (Math.random()<0.02 && tB>10) startFire();\n    if (Math.random()<0.01 && tB>20) startQuake();\n    if (Math.random()<0.02 && st.population>50) startCrimeEvent();\n    ensureEmergencyCoverage();\n    updFires(); updCrimeEvents(); drGr(); updUI(); updateStatsPanel(); sv();\n}\n\nconst aC=new (window.AudioContext||window.webkitAudioContext)();\nfunction plySnd(t) {\n  const n=aC.currentTime;\n  if (t==='place') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); }\n  else if (t==='bulldoze') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sawtooth'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(200,n); g.gain.setValueAtTime(0.15,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); }\n  else if (t==='click') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(600,n); g.gain.setValueAtTime(0.08,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.05); o.start(n); o.stop(n+0.05); }\n  else if (t==='error') { const o=aC.createOscillator(), g=aC.createGain(); o.type='square'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(300,n); o.frequency.setValueAtTime(200,n+0.1); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); }\n}\n\nif (!ld()) { initGr('balanced'); st.newsEvents=['Welcome to '+st.cityName+'!']; }\nif (!st.zoom) st.zoom=1;\nif (st.disastersEnabled === undefined) st.disastersEnabled = true;\nconst disastersToggleEl = document.getElementById('disastersToggle');\nif (disastersToggleEl) {\n  disastersToggleEl.checked = st.disastersEnabled;\n  disastersToggleEl.addEventListener('change', (e) => {\n    st.disastersEnabled = e.target.checked;\n    updateDisasterButtonsVisibility();\n    sv();\n  });\n}\nupdateDisasterButtonsVisibility();\napplyZoom();\ndrGr(); updUI(); updNwsTk(); selTl('road');\nif (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); }\n\n// Center canvas after page is fully loaded\nwindow.addEventListener('load', () => {\n  setTimeout(centerCanvas, 100);\n});\n\n// Re-center canvas when window is resized\nlet resizeTimeout;\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimeout);\n  resizeTimeout = setTimeout(centerCanvas, 100);\n});\n\nsetInterval(() => { if (st.speed>0) { updCars(); drGr(); } },50);\n\n// Building info panel for stat view\nfunction showBuildingInfo(x, y) {\n  const c = st.grid[y][x];\n  if (!c || c.type === 'empty') return;\n  \n  const panel = document.getElementById('buildingInfoPanel');\n  const title = document.getElementById('buildingInfoTitle');\n  const content = document.getElementById('buildingInfoContent');\n  \n  // Get building icon\n  const icon = {\n    'residential': 'üè†',\n    'commercial': 'üè¢',\n    'industrial': 'üè≠',\n    'road': 'üõ£Ô∏è',\n    'park': 'üå≥',\n    'park2': 'üå∏',\n    'park3': 'üå≤',\n    'park4': 'üåª',\n    'police': 'üëÆ',\n    'fire': 'üöí',\n    'school': 'üè´',\n    'hospital': 'üè•'\n  }[c.type] || 'üèóÔ∏è';\n  \n  // Format building name\n  const name = c.type.charAt(0).toUpperCase() + c.type.slice(1).replace(/\\d+$/, '');\n  title.textContent = `${icon} ${name}`;\n  \n  // Build content\n  let statItems = [];\n  \n  // Size info for multi-tile buildings\n  if (c.w > 1 || c.h > 1) {\n    statItems.push(statItem('size', `${c.w}√ó${c.h}`));\n  }\n  \n  // Level info for zones\n  if (c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') {\n    if (c.abandoned) {\n      statItems.push(statItem('status', 'Abandoned', 'text-red-400'));\n    } else {\n      statItems.push(statItem('level', c.level));\n    }\n  }\n  \n  // Age info\n  if (c.age !== undefined) {\n    const years = Math.floor(c.age / 12);\n    statItems.push(statItem('age', `${years} year${years !== 1 ? 's' : ''}`));\n  }\n  \n  // Land value and crime for this tile\n  const landValue = st.landValue[y] && st.landValue[y][x] !== undefined ? st.landValue[y][x] : 50;\n  const crime = st.crime[y] && st.crime[y][x] !== undefined ? st.crime[y][x] : 30;\n  \n  if (showLandValueOverlay) {\n    const lvColor = landValue >= 80 ? 'text-green-400' : landValue >= 50 ? 'text-yellow-400' : 'text-orange-400';\n    statItems.push(statItem('land value', landValue.toFixed(0), lvColor));\n  }\n  \n  if (showCrimeOverlay) {\n    const crimeColor = crime >= 70 ? 'text-red-400' : crime >= 30 ? 'text-yellow-400' : 'text-green-400';\n    const crimeLevel = crime >= 70 ? 'High' : crime >= 30 ? 'Medium' : 'Low';\n    statItems.push(statItem('crime', `${crimeLevel} (${crime.toFixed(0)})`, crimeColor));\n  }\n  \n  if (statItems.length > 0) {\n    content.innerHTML = `<div class=\"flex flex-wrap gap-6 py-2\">${statItems.join('')}</div>`;\n  } else {\n    content.innerHTML = '';\n  }\n  panel.classList.remove('hidden');\n  \n  // Set highlighted building (get full building bounds from top-left corner)\n  const bounds = getBuildingBoundsFromCell(x, y);\n  highlightedBuilding = {\n    x: bounds.startX,\n    y: bounds.startY,\n    w: bounds.w,\n    h: bounds.h\n  };\n  drGr(); // Redraw to show highlight\n}\n\nfunction hideBuildingInfo() {\n  const panel = document.getElementById('buildingInfoPanel');\n  panel.classList.add('hidden');\n  highlightedBuilding = null;\n  drGr(); // Redraw to remove highlight\n}\n</script>\n</body>\n</html>",
  "title": "AI SimCity",
  "icon": "üèôÔ∏è",
  "name": "AI SimCity.app",
  "windowWidth": 420,
  "windowHeight": 625,
  "createdAt": 1763199645021,
  "createdBy": "ryo",
  "updatedAt": 1763199645021,
  "featured": true
}