<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <link rel="stylesheet" href="https://os.ryo.lu/fonts/fonts.css">
    <!-- ts=1763051833299 --> 
    
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "sans-serif"],
              mono: ["Monaco", "ArkPixel", "SerenityOS-Emoji", "ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", "monospace"],
              serif: ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "SerenityOS-Emoji", "serif"],
              emoji: ["SerenityOS-Emoji", "AppleColorEmoji", "AppleColorEmojiFallback"],
              'geneva': ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "system-ui", "-apple-system", "sans-serif"],
              'mondwest': ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "Yu Mincho", "Hiragino Mincho Pro", "serif"],
              'neuebit': ["NeueBit", "ArkPixel", "SerenityOS-Emoji", "Helvetica", "Arial", "Hiragino Sans", "sans-serif"],
              'monaco': ["Monaco", "ArkPixel", "SerenityOS-Emoji", "monospace"],
              'jacquard': ["Jacquard", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "serif"]
            }
          }
        }
      }
    </script>
  <style>
    * {
      box-sizing: border-box;
      
    }
    html, body {
      margin: 0;
      overflow-x: auto; /* Allow horizontal scroll if content overflows */
      width: 100%;
      height: 100%;
      max-width: 100%; /* Prevent body from exceeding viewport width */
      
    }
    
    /* Ensure pre doesn't break layout */
    pre {
      white-space: pre-wrap; /* Allow wrapping */
      word-break: break-all; /* Break long words */
    }
  </style>
  
  <!-- Move click interceptor script to head for earlier execution -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      document.addEventListener('click', function(event) {
        var targetElement = event.target.closest('a');
        // Only intercept if it's a valid link and NOT inside the draggable toolbar
        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {
          event.preventDefault();
          event.stopPropagation();
          try {
            // Resolve relative URLs against the document's base URI (if set) or window location
            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;
            // Use a specific message type for AI HTML navigation
            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');
            console.log('Intercepted link click:', absoluteUrl);
          } catch (e) { console.error("Error resolving/posting URL:", e); }
        }
      }, true); // Use capture phase to intercept early
    });
    
    // Also add immediate execution version for documents that load quickly
    // This helps ensure we don't miss any clicks during initial page load
    (function() {
      document.addEventListener('click', function(event) {
        var targetElement = event.target.closest('a');
        // Only intercept if it's a valid link and NOT inside the draggable toolbar
        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]')) {
          event.preventDefault();
          event.stopPropagation();
          try {
            // Resolve relative URLs against the document's base URI (if set) or window location
            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;
            // Use a specific message type for AI HTML navigation
            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');
            console.log('Intercepted link click (immediate handler):', absoluteUrl);
          } catch (e) { console.error("Error resolving/posting URL:", e); }
        }
      }, true); // Use capture phase to intercept early
    })();
  </script>
 
</head>
<body>
  <div class="w-full h-screen bg-neutral-900 text-neutral-100 font-geneva flex flex-col overflow-hidden">
  <div class="border-b border-neutral-700 bg-neutral-800 px-3 py-2 flex items-center justify-between flex-shrink-0">
    <div class="flex items-center gap-3">
      <button id="menuBtn" class="text-sm text-neutral-300 hover:text-neutral-100 transition-colors">‚ò∞</button>
      <div class="flex items-center gap-1">
        <div class="text-sm text-neutral-400">
          <input id="cityName" type="text" value="new city" class="bg-transparent border-none outline-none text-white cursor-pointer hover:bg-neutral-700 px-1 rounded transition-colors">
        </div>
        <button id="speedToggle" class="text-xs text-neutral-300 hover:text-neutral-100 transition-colors">‚è∏</button>
      </div>
    </div>
    
    <div class="flex items-center gap-3">
      <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="rciBtn">
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="rDemand" class="w-full bg-green-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="cDemand" class="w-full bg-blue-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="iDemand" class="w-full bg-yellow-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
      </div>
      
      <div class="flex items-center gap-3 text-xs">
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="popBtn">
          <span class="text-neutral-500">‚òª</span>
          <span id="population" class="text-white tabular-nums">0</span>
        </div>
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="moneyBtn">
          <span class="text-neutral-500">$</span>
          <span id="money" class="text-white tabular-nums">50k</span>
        </div>
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="happyBtn">
          <span class="text-neutral-500">‚ô•</span>
          <span id="happiness" class="text-white tabular-nums">70</span>
        </div>
      </div>
    </div>
  </div>

  <div class="border-b border-neutral-700 bg-neutral-800 px-3 py-1.5 flex items-center gap-3 text-xs flex-shrink-0">
    <div id="yearDisplay" class="text-neutral-400 font-mono tabular-nums">1990</div>
    <div class="flex-1 overflow-hidden relative" style="height: 1.25rem; line-height: 1.25rem;">
      <div id="newsTicker" class="text-neutral-300 whitespace-nowrap absolute left-0 transition-all duration-500" style="line-height: 1.25rem;"></div>
    </div>
  </div>

  <div id="menu" class="hidden border-b border-neutral-700 bg-neutral-800 p-3 flex-shrink-0">
    <div class="space-y-3">
      <div class="flex items-start gap-3">
        <div class="space-y-2 flex-1">
          <div class="text-xs text-neutral-500 tracking-wider px-1">zoom</div>
          <div class="flex items-center gap-1 w-full justify-between">
            <button id="zoomOutBtn" class="w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center">‚àí</button>
            <div id="zoomLevel" class="text-xs text-neutral-300 tabular-nums px-2">100%</div>
            <button id="zoomInBtn" class="w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center">+</button>
          </div>
        </div>
        <div class="space-y-2 flex-1">
          <div class="text-xs text-neutral-500 tracking-wider px-1">settings</div>
          <label class="flex items-center gap-2 px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors cursor-pointer">
            <input id="disastersToggle" type="checkbox" checked class="w-4 h-4 accent-green-600">
            <span>disasters</span>
          </label>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="aiSuggestBtn" class="flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors flex items-center justify-center gap-2">
          <span>ask AI mayor</span>
        </button>
        <button id="newCityBtn" class="flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors">
          new city
        </button>
      </div>
    </div>
  </div>

  <div id="newGamePanel" class="hidden border-b border-neutral-700 bg-neutral-800 p-4 flex-shrink-0">
    <div class="max-w-md mx-auto space-y-3">
      <div>
        <label class="text-xs text-neutral-400 block mb-1">city name</label>
        <input id="newCityName" type="text" value="" placeholder="new city" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none focus:border-neutral-500">
      </div>
      <div>
        <label class="text-xs text-neutral-400 block mb-1">terrain type</label>
        <select id="terrainType" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none">
          <option value="balanced">balanced</option>
          <option value="island">island</option>
          <option value="valley">valley</option>
          <option value="plains">plains</option>
        </select>
      </div>
      <div>
        <label class="text-xs text-neutral-400 block mb-1">difficulty</label>
        <select id="difficulty" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none">
          <option value="easy">easy ($100k)</option>
          <option value="normal" selected>normal ($50k)</option>
          <option value="hard">hard ($20k)</option>
        </select>
      </div>
      <button id="startGameBtn" class="w-full bg-green-700 hover:bg-green-600 text-white px-4 py-2 rounded text-sm transition-colors">
        start game
      </button>
    </div>
  </div>

  <div class="flex-1 overflow-hidden flex">
    <div id="grid" class="flex-1 overflow-auto p-4 relative">
      <canvas id="canvas" class="rounded" style="image-rendering: pixelated;"></canvas>
    </div>

    <div class="flex flex-shrink-0 relative" style="overflow: visible;">
      <div id="subToolbar" class="hidden absolute right-[calc(100%+1px)] w-14 border-r border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto rounded-lg z-10" style="overflow-x: visible;"></div>
      <div class="w-14 border-l border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto flex-shrink-0" id="mainToolbar" style="overflow-x: visible;">
        <button data-tool="road" data-tooltip="road" data-shortcut="R" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üõ£Ô∏è</button>
        <button data-tool="residential" data-tooltip="residential" data-shortcut="H" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè†</button>
        <button data-tool="commercial" data-tooltip="commercial" data-shortcut="C" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè¢</button>
        <button data-tool="industrial" data-tooltip="industrial" data-shortcut="I" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè≠</button>
        <button data-submenu="park" data-tooltip="park" data-shortcut="P" class="tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center">üå≥</button>
        <button data-tool="police" data-tooltip="police" data-shortcut="O" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üö®</button>
        <button data-tool="fire" data-tooltip="fire" data-shortcut="F" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üöí</button>
        <button data-tool="school" data-tooltip="school" data-shortcut="S" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè´</button>
        <button data-tool="hospital" data-tooltip="hospital" data-shortcut="T" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè•</button>
        <div class="w-full flex flex-col">
          <div class="h-1"></div>
          <div class="h-px w-full bg-neutral-700"></div>
          <div class="h-1"></div>
        </div>
        <button data-submenu="disaster" data-tooltip="disasters" data-shortcut="W" class="disaster-btn tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center" style="display: none;">‚ö†Ô∏è</button>
        <button data-tool="bulldoze" data-tooltip="demolish" data-shortcut="D" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üí•</button>
      </div>
    </div>
  </div>

  <div id="aiPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0">
    <div class="flex items-start gap-2 mb-2">
      <div class="flex-1">
        <div class="text-xs text-yellow-500 mb-1">AI Mayor</div>
        <div id="aiMessage" class="text-sm text-neutral-300 leading-relaxed"></div>
      </div>
      <button id="closeAiBtn" class="text-xs text-neutral-500 hover:text-neutral-300">‚úï</button>
    </div>
  </div>
  <!-- Building info panel for stat view -->
  <div id="buildingInfoPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 flex-shrink-0">
    <div class="flex items-start gap-2">
      <div class="flex-1">
        <div id="buildingInfoTitle" class="text-sm font-bold text-white mb-2"></div>
        <div id="buildingInfoContent" class="text-xs text-neutral-300 space-y-1"></div>
      </div>
    </div>
  </div>

  <div id="infoPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0">
    <div class="flex items-start gap-2 mb-2">
      <div class="flex-1">
        <div class="text-xs text-blue-400 mb-1" id="infoTitle">Info</div>
        <div id="infoContent" class="text-sm text-neutral-300 leading-relaxed space-y-1"></div>
      </div>
      <button id="closeInfoBtn" class="text-xs text-neutral-500 hover:text-neutral-300">‚úï</button>
    </div>
  </div>



  <div class="border-t border-neutral-700 bg-neutral-800 px-3 py-2 text-xs text-neutral-400 flex items-center justify-between flex-shrink-0">
    <div id="statusText">select a tool to start building</div>
    <div id="costText" class="text-neutral-500"></div>
  </div>
</div>

<style>
@keyframes tickerRollUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-100%); opacity: 0; }
}
@keyframes shake {
  0%, 100% { transform: translate(0, 0); }
  10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 1px); }
  20%, 40%, 60%, 80% { transform: translate(2px, -1px); }
}
.ticker-roll { animation: tickerRollUp 0.5s ease-out forwards; }
.earthquake { animation: shake 0.5s ease-in-out; }
.tool-btn {
  transition: opacity 0.2s ease, background-color 0.2s ease;
  position: relative;
}
.tooltip {
  position: fixed;
  background-color: rgb(30, 30, 30);
  color: rgb(229, 229, 229);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10000;
  border: 1px solid rgb(64, 64, 64);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.tooltip.show {
  opacity: 1;
}
.tooltip-shortcut {
  color: rgb(163, 163, 163);
  margin-left: 6px;
}
@media (hover: hover) and (pointer: fine) {
  .tool-btn:hover { background-color: rgb(64, 64, 64); opacity: 1 !important; }
  .tool-btn[data-tool="bulldoze"]:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }
  .tool-btn.submenu-active:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }
}
</style>

<script>
const GR_SZ = 32, CL_SZ = 16;
let TK_INT = 2000, tkTmr = null, aiReq = false, edtNm = false, nwsIdx = 0, tkrTmr = null, trans = false, nwsQ = [];
const COSTS = {road:100,residential:500,commercial:800,industrial:1000,park:300,park2:300,park3:300,park4:300,police:2000,fire:2000,school:3000,hospital:4000};
const LAND_VALUE_LOW_COLOR = {r:250,g:204,b:21};
const LAND_VALUE_HIGH_COLOR = {r:34,g:197,b:94};
const STATION_MAX_ACTIVE = 2;

let st = {cityName:'new city',money:50000,population:0,happiness:70,grid:[],terrain:[],landValue:[],crime:[],crimeEvents:[],selectedTool:null,tickCount:0,speed:3000,rDemand:50,cDemand:50,iDemand:50,year:1990,newsEvents:[],ticksSinceNews:0,fires:[],employment:0,cars:[],zoom:1.5,disastersEnabled:true,stationDispatches:{}};
let nextBuildingId = 1;
let showLandValueOverlay = false;
let showCrimeOverlay = false;
let highlightedBuilding = null; // {x, y, w, h} of highlighted building

const cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d');
cvs.width = GR_SZ * CL_SZ; cvs.height = GR_SZ * CL_SZ;

function genTerr(t) {
  const tr = [];
  for (let y=0; y<GR_SZ; y++) { const r=[]; for (let x=0; x<GR_SZ; x++) r.push('grass'); tr.push(r); }
  if (t==='island') {
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const dx=x-GR_SZ/2, dy=y-GR_SZ/2, d=Math.sqrt(dx*dx+dy*dy), n=(Math.sin(x*0.3)+Math.cos(y*0.3))*2;
      if (d+n>GR_SZ/2.3) tr[y][x]='water';
    }
    for (let i=0; i<3; i++) {
      const cx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), cy=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-cx, dy=y-cy, d=Math.sqrt(dx*dx+dy*dy);
        if (d<3 && tr[y][x]==='grass') tr[y][x]='cliff';
      }
    }
  } else if (t==='valley') {
    for (let y=0; y<GR_SZ; y++) {
      const cd=Math.abs(y-GR_SZ/2), th=GR_SZ/4+Math.sin(y*0.2)*2;
      if (cd>th) for (let x=0; x<GR_SZ; x++) tr[y][x]='cliff';
    }
    const ry=Math.floor(GR_SZ/2);
    for (let x=0; x<GR_SZ; x++) {
      const of=Math.floor(Math.sin(x*0.3)*3), r=ry+of;
      if (r>=0 && r<GR_SZ) { tr[r][x]='water'; if (r-1>=0 && Math.random()<0.5) tr[r-1][x]='water'; if (r+1<GR_SZ && Math.random()<0.5) tr[r+1][x]='water'; }
    }
  } else if (t==='plains') {
    for (let i=0; i<2; i++) {
      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;
        if (d+n<4) tr[y][x]='water';
      }
    }
  } else {
    for (let i=0; i<2; i++) {
      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;
        if (d+n<3.5) tr[y][x]='water';
      }
    }
    for (let i=0; i<2; i++) {
      const mx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), my=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-mx, dy=y-my, d=Math.sqrt(dx*dx+dy*dy);
        if (d<2.5 && tr[y][x]==='grass') tr[y][x]='cliff';
      }
    }
  }
  return tr;
}

// Helper function to ensure empty cells are always 1x1
function normalizeEmptyCell(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return;
  const c=st.grid[y][x];
  if (c.type==='empty' && ((c.w||1)!==1 || (c.h||1)!==1)) {
    st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
  }
}
  
  function snapCenterToPixelGrid(value, halfSize) {
    const fractional = halfSize - Math.floor(halfSize);
    if (Math.abs(fractional) < 1e-6) return Math.round(value);
    return Math.round(value - fractional) + fractional;
  }

function initGr(tt='balanced') {
  st.grid=[]; st.terrain=genTerr(tt); st.landValue=[]; st.crime=[]; st.fires=[]; st.cars=[]; st.crimeEvents=[]; st.stationDispatches={};
  for (let y=0; y<GR_SZ; y++) {
    const r=[], vr=[], cr=[];
    for (let x=0; x<GR_SZ; x++) { r.push({type:'empty',age:0,level:0,w:1,h:1,buildingId:null}); vr.push(50); cr.push(30); }
    st.grid.push(r); st.landValue.push(vr); st.crime.push(cr);
  }
}

function sv() { try { localStorage.setItem('simcity_state',JSON.stringify(st)); } catch(e) {} }
function ld() {
  try {
    const s=localStorage.getItem('simcity_state');
    if (s) {
      const p=JSON.parse(s);
        if (p.grid && p.grid.length===GR_SZ) {
        st=p;
        if (!st.rDemand) st.rDemand=50; if (!st.cDemand) st.cDemand=50; if (!st.iDemand) st.iDemand=50;
        if (!st.year) st.year=1990; if (!st.newsEvents) st.newsEvents=[]; if (!st.ticksSinceNews) st.ticksSinceNews=0;
        if (!st.terrain) st.terrain=genTerr('balanced'); if (!st.landValue) { st.landValue=[]; for (let y=0; y<GR_SZ; y++) { const vr=[]; for (let x=0; x<GR_SZ; x++) vr.push(50); st.landValue.push(vr); } }
        if (!st.crime) { st.crime=[]; for (let y=0; y<GR_SZ; y++) { const cr=[]; for (let x=0; x<GR_SZ; x++) cr.push(30); st.crime.push(cr); } }
          if (!st.fires) st.fires=[]; if (!st.employment) st.employment=0; if (!st.cars) st.cars=[]; if (!st.crimeEvents) st.crimeEvents=[];
          st.stationDispatches={};
          if (st.cars && st.cars.length>0) {
            st.cars.forEach(car => {
              if (car.stationKey) incrementStationDispatchCount(car.stationKey);
            });
          }
        if (!st.zoom) st.zoom=1;
        if (st.disastersEnabled === undefined) st.disastersEnabled = true;
        for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) { 
          if (!st.grid[y][x].level) st.grid[y][x].level=0; 
          if (!st.grid[y][x].w) st.grid[y][x].w=1; 
          if (!st.grid[y][x].h) st.grid[y][x].h=1; 
          // Normalize empty cells to ensure they're always 1x1
          if (st.grid[y][x].type==='empty') normalizeEmptyCell(x,y);
        }

        // Rebuild buildingId metadata after loading to ensure consistent grouping
        rebuildBuildingIdsFromGrid();
        return true;
      }
    }
  } catch(e) {}
  return false;
}

function isRd(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].type==='road'; }
function getRdNb(x,y) { return {top:isRd(x,y-1),right:isRd(x+1,y),bottom:isRd(x,y+1),left:isRd(x-1,y)}; }

function drRd(px,py,nb) {
  ctx.fillStyle='#3a3a3a'; ctx.fillRect(px,py,CL_SZ,CL_SZ);
  const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);
  ctx.fillStyle='#4a4a4a';
  if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }
  else if (rc===3) {
    if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }
    else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }
    else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }
    else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
  } else if (rc===2) {
    if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
    else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }
    else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
    else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
    else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }
    else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }
  } else if (rc===1) {
    if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
    else { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }
  } else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
}

function drTl(x,y,tp,lv,ab,w,h) {
  const px=x*CL_SZ, py=y*CL_SZ, wd=w*CL_SZ, ht=h*CL_SZ, tr=st.terrain[y][x];
  if (tp==='empty') {
    if (tr==='water') ctx.fillStyle='#1e40af'; 
    else if (tr==='cliff') ctx.fillStyle='#3e2723'; 
    else ctx.fillStyle='#2d5016';
    ctx.fillRect(px,py,CL_SZ,CL_SZ);
  } else if (tp==='road') { 
    const nb=getRdNb(x,y); drRd(px,py,nb); 
  }
  else if (tp==='residential') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(74,124,89,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-6, bh=ht-6; 
      ctx.fillRect(px+3,py+5,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+3,py+5,bw,Math.floor(bh*0.25)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+5,py+Math.floor(5+bh*0.35),2,2); 
      ctx.fillRect(px+9,py+Math.floor(5+bh*0.35),2,2); 
      if (w===2) ctx.fillRect(px+20,py+Math.floor(5+bh*0.35),2,2); 
    }
    else {
      // For 2x2 buildings, make them grow taller with level
      const sz=w===2&&h===2?(lv===3?wd-3:(lv===2?wd-3.5:wd-4)):w===2?wd-4:(lv===1?8:(lv===3?10:10));
      const of=w===2&&h===2?(lv===3?1.5:(lv===2?1.75:2)):w===2?2:(lv===1?4:(lv===3?3:3));
      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-7)):w===2?ht-7:(lv===1?8:(lv===3?12:(lv===2?14:11)));
      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:6)):w===1&&h===1?(lv===3?2:(lv===2?1:7)):6;
      ctx.fillStyle=w===2&&h===2?(lv===3?'#22c55e':(lv===2?'#16a34a':'#15803d')):w===2?'#16a34a':(lv===3?'#1a9e4a':(lv===2?'#16a34a':'#15803d')); 
      ctx.fillRect(px+of,py+yo,sz,bh);
      ctx.fillStyle=w===2&&h===2?(lv===3?'#16a34a':(lv===2?'#15803d':'#166534')):w===2?'#15803d':(lv===3?'#15803d':'#15803d'); 
      const roofHeight=w===2&&h===2&&lv===1?0.18:0.25;
      ctx.fillRect(px+of,py+yo,sz,Math.floor(bh*roofHeight));
      if (lv>=2 || w===2) {
        ctx.fillStyle='#4ade80';
        const wh=2, ww=2, gap=1;
        const floors=w===2&&h===2?(lv===3?4:(lv===2?3:2)):w===2&&h===1?1:(lv===3?2:(lv===2?2:1));
        const winStart=w===2&&h===2?0.35:0.4;
        for (let f=0; f<floors; f++) {
          const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));
          ctx.fillRect(px+5,wy,ww,wh); 
          ctx.fillRect(px+9,wy,ww,wh);
          if (w===2) { 
            ctx.fillRect(px+20,wy,ww,wh); 
            ctx.fillRect(px+24,wy,ww,wh); 
          }
        }
      } else if (lv===1) {
        ctx.fillStyle='#4ade80';
        const winStart=w===2&&h===2?0.35:0.4;
        const wy = py+Math.floor(yo+bh*winStart);
        ctx.fillRect(px+5,wy,2,2); 
        ctx.fillRect(px+9,wy,2,2);
      }
      ctx.fillStyle='#166534'; 
      if (w===1&&h===1&&lv===1) {
        ctx.fillRect(px+7,py+ht-3,2,3);
      } else if (w===1&&h===2) {
        // For 1x2 buildings, position door at bottom of building, centered
        ctx.fillRect(px+7,py+yo+bh-3,2,3);
      } else {
        ctx.fillRect(px+6,py+ht-3,3,3); 
      }
      if (w===2) ctx.fillRect(px+21,py+ht-3,3,3);
      // Add yard decorations for 1x2 tiles
      if (w===1&&h===2&&!ab) {
        ctx.fillStyle='#15803d';
        ctx.fillRect(px+3,py+ht-6,2,2); // Small bush left
        ctx.fillRect(px+11,py+ht-6,2,2); // Small bush right
        // Add more for higher levels
        if (lv>=2) {
          ctx.fillStyle='#16a34a';
          ctx.fillRect(px+1,py+ht-8,2,2); // Extra bush left
          ctx.fillRect(px+13,py+ht-8,2,2); // Extra bush right
        }
        if (lv>=3) {
          ctx.fillStyle='#4ade80';
          ctx.fillRect(px+7,py+ht-7,2,1); // Accent center
        }
      }
    }
  } else if (tp==='commercial') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(74,107,138,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-4, bh=ht-4; 
      ctx.fillRect(px+2,py+4,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+2,py+4,bw,Math.floor(bh*0.25)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+4,py+Math.floor(4+bh*0.4),3,3); 
      ctx.fillRect(px+9,py+Math.floor(4+bh*0.4),3,3); 
      if (w===2) ctx.fillRect(px+20,py+Math.floor(4+bh*0.4),3,3); 
    }
    else {
      // For 2x2 buildings, make them grow taller with level
      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-9)):w===2||h===2?ht-3:(lv===1?9:(lv===2?11:13));
      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:8)):w===2||h===2?2:(lv===1?6:(lv===2?4:1));
      ctx.fillStyle=w===2&&h===2?(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')):w===2||h===2?'#2563eb':(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')); 
      ctx.fillRect(px+2,py+yo,wd-4,bh);
      ctx.fillStyle=w===2&&h===2?(lv===3?'#2563eb':(lv===2?'#1e40af':'#1d4ed8')):w===2||h===2?'#1e40af':(lv===3?'#2563eb':'#1e40af'); 
      ctx.fillRect(px+2,py+yo,wd-4,Math.floor(bh*0.25));
      ctx.fillStyle='#87ceeb';
      const wh=3, ww=3, gap=1;
      const floors=w===2&&h===2?(lv===3?3:(lv===2?3:1)):w===2&&h===1?1:(w===2||h===2?2:1);
      const winStart=w===2&&h===2?0.35:0.4;
      for (let f=0; f<floors; f++) {
        const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));
        ctx.fillRect(px+4,wy,ww,wh); 
        ctx.fillRect(px+9,wy,ww,wh);
        if (w===2) { 
          ctx.fillRect(px+20,wy,ww,wh); 
          ctx.fillRect(px+25,wy,ww,wh); 
        }
      }
      ctx.fillStyle='#1e3a8a'; 
      ctx.fillRect(px+6,py+ht-4,4,4); 
      if (w===2) ctx.fillRect(px+22,py+ht-4,4,4);
    }
  } else if (tp==='industrial') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(138,124,74,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-4, bh=ht-6; 
      ctx.fillRect(px+2,py+6,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+2,py+6,bw,Math.floor(bh*0.4)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+5,py+11,2,2); 
      ctx.fillRect(px+9,py+11,2,2); 
      if (w===2) ctx.fillRect(px+21,py+11,2,2); 
    }
    else {
      // For 2x2 buildings, grow taller with level
      const bh=w===2&&h===2?(lv===3?ht-2:(lv===2?ht-3:ht-4)):w===2?ht-4:(lv===1?8:(lv===2?10:11));
      const yo=w===2&&h===2?(lv===3?2:(lv===2?2.5:3)):w===2?3:(lv===1?5:(lv===2?4:3));
      // Main building body
      ctx.fillStyle=w===2&&h===2?(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')):w===2?'#ca8a04':(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')); 
      ctx.fillRect(px+2,py+yo+1,wd-4,bh);
      // Slanted roof (darker top section)
      ctx.fillStyle=w===2&&h===2?(lv===3?'#ca8a04':(lv===2?'#a16207':'#854d0e')):w===2?'#a16207':(lv===3?'#ca8a04':'#854d0e'); 
      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));
      // Chimney structure
      ctx.fillStyle='#6b4423'; 
      const ch=w===2&&h===2?(lv===3?8:(lv===2?7:6)):lv===3?6:5; 
      ctx.fillRect(px+4,py+yo-ch+1,2,ch); 
      if (w===2) ctx.fillRect(px+26,py+yo-ch+1,2,ch);
      // Chimney top cap
      ctx.fillStyle='#854d0e'; 
      ctx.fillRect(px+3,py+yo-ch+1,4,1); 
      if (w===2) ctx.fillRect(px+25,py+yo-ch+1,4,1);
      // Smoke from chimney
      ctx.fillStyle='#9ca3af'; 
      ctx.fillRect(px+4,py+yo-ch,1,1); 
      ctx.fillRect(px+5,py+yo-ch-1,1,1); 
      if (w===2) { 
        ctx.fillRect(px+26,py+yo-ch,1,1); 
        ctx.fillRect(px+27,py+yo-ch-1,1,1); 
      }
      // Windows
      ctx.fillStyle='#fde047'; 
      if (w===2 && h===2) {
        // More windows for higher level 2x2 buildings
        const rows=lv===3?3:(lv===2?2:2);
        for (let r=0; r<rows; r++) {
          const wy = py+yo+Math.floor(bh*0.35)+(r*5);
          ctx.fillRect(px+5,wy,2,2); 
          ctx.fillRect(px+9,wy,2,2); 
          ctx.fillRect(px+21,wy,2,2); 
          ctx.fillRect(px+25,wy,2,2);
        }
      } else {
        // Single row of windows for smaller buildings
        ctx.fillRect(px+5,py+yo+Math.floor(bh*0.55),2,2); 
        ctx.fillRect(px+9,py+yo+Math.floor(bh*0.55),2,2); 
        if (w===2) { 
          ctx.fillRect(px+21,py+yo+Math.floor(bh*0.55),2,2); 
          ctx.fillRect(px+25,py+yo+Math.floor(bh*0.55),2,2); 
        }
      }
      // Entrance/door
      ctx.fillStyle='#713f12'; 
      ctx.fillRect(px+6,py+ht-3,4,3); 
      if (w===2) ctx.fillRect(px+22,py+ht-3,4,3);
    }
  } else if (tp.startsWith('park')) {
    const bc=tp==='park'?'#1d6b2e':(tp==='park2'?'#2a5a3a':(tp==='park3'?'#1a5a2a':'#2d6b1e'));
    ctx.fillStyle=bc; ctx.fillRect(px,py,wd,ht);
    if (tp==='park') { 
      ctx.fillStyle='#2a8f3f'; 
      ctx.fillRect(px+4,py+3,3,3); 
      ctx.fillRect(px+9,py+8,3,3); 
      if (w===2||h===2) { 
        ctx.fillRect(px+20,py+5,3,3); 
        ctx.fillRect(px+15,py+20,3,3); 
      } 
      ctx.fillStyle='#165a24'; 
      ctx.fillRect(px+2,py+9,2,2); 
      ctx.fillRect(px+11,py+4,2,2); 
      ctx.fillStyle='#6b4423'; 
      ctx.fillRect(px+7,py+6,2,4); 
      if (w===2||h===2) ctx.fillRect(px+23,py+10,2,4); 
    }
    else if (tp==='park2') { 
      ctx.fillStyle='#ff69b4'; 
      ctx.fillRect(px+4,py+4,2,2); 
      ctx.fillRect(px+9,py+7,2,2); 
      ctx.fillRect(px+6,py+10,2,2); 
      if (w===2||h===2) { 
        ctx.fillRect(px+20,py+6,2,2); 
        ctx.fillRect(px+25,py+9,2,2); 
        ctx.fillRect(px+17,py+20,2,2); 
      } 
      ctx.fillStyle='#ffc0cb'; 
      ctx.fillRect(px+11,py+5,1,1); 
      ctx.fillRect(px+3,py+8,1,1); 
    }
    else if (tp==='park3') { 
      ctx.fillStyle='#2d5016'; 
      ctx.fillRect(px+5,py+2,3,4); 
      ctx.fillRect(px+10,py+8,3,4); 
      if (w===2||h===2) { 
        ctx.fillRect(px+21,py+4,3,4); 
        ctx.fillRect(px+16,py+20,3,4); 
      } 
      ctx.fillStyle='#1a4010'; 
      ctx.fillRect(px+3,py+10,2,3); 
      ctx.fillRect(px+12,py+5,2,3); 
    }
    else { 
      ctx.fillStyle='#ffd700'; 
      ctx.fillRect(px+5,py+5,3,3); 
      ctx.fillRect(px+10,py+9,3,3); 
      if (w===2||h===2) { 
        ctx.fillRect(px+21,py+7,3,3); 
        ctx.fillRect(px+16,py+20,3,3); 
      } 
      ctx.fillStyle='#8b4513'; 
      ctx.fillRect(px+6,py+8,1,3); 
      ctx.fillRect(px+11,py+12,1,3); 
    }
  } else if (tp==='police') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#000080'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#0000a0'; ctx.fillRect(px+2,py+4,12,4); 
    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); 
    ctx.fillStyle='#ff0000'; ctx.fillRect(px+6,py+5,4,1); 
    ctx.fillStyle='#0000ff'; ctx.fillRect(px+6,py+6,4,1); 
    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); 
  }
  else if (tp==='fire') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#8b0000'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#a00000'; ctx.fillRect(px+2,py+4,12,4); 
    ctx.fillStyle='#444444'; ctx.fillRect(px+4,py+7,3,3); ctx.fillRect(px+9,py+7,3,3); 
    ctx.fillStyle='#ff4500'; ctx.fillRect(px+6,py+5,4,2); 
    ctx.fillStyle='#ffd700'; ctx.fillRect(px+7,py+6,2,1); 
    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); 
  }
  else if (tp==='school') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#daa520'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#b8860b'; ctx.fillRect(px+2,py+4,12,4); 
    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+9,py+10,3,3); 
    ctx.fillStyle='#8b4513'; ctx.fillRect(px+4,py+11,3,3); 
  }
  else if (tp==='hospital') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#d1d5db'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#ff0000'; ctx.fillRect(px+7,py+5,2,5); ctx.fillRect(px+5,py+6,6,2); 
    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); 
  }
  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,wd,ht);
}

function drGr() {
  ctx.clearRect(0,0,cvs.width,cvs.height); const drn={};
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const k=`${x},${y}`; if (drn[k]) continue;
    const c=st.grid[y][x]; drTl(x,y,c.type,c.level||0,c.abandoned||false,c.w||1,c.h||1);
    for (let dy=0; dy<(c.h||1); dy++) for (let dx=0; dx<(c.w||1); dx++) drn[`${x+dx},${y+dy}`]=true;
  }
  if (showLandValueOverlay) drawLandValueOverlay();
  if (showCrimeOverlay) drawCrimeOverlay();
  
  // Draw highlighted building border
  if (highlightedBuilding) {
    ctx.save();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      highlightedBuilding.x * CL_SZ + 1,
      highlightedBuilding.y * CL_SZ + 1,
      highlightedBuilding.w * CL_SZ - 2,
      highlightedBuilding.h * CL_SZ - 2
    );
    ctx.restore();
  }
  
  st.fires.forEach(f => {
    if (f.age<20) {
      const fx = f.x * CL_SZ;
      const fy = f.y * CL_SZ;
      const anim = f.age % 6;
      
      ctx.save();
      // Draw multiple flame shapes for a more fire-like appearance
      // Base flame (orange/red)
      ctx.fillStyle = anim < 3 ? '#ff4500' : '#ff6600';
      ctx.beginPath();
      ctx.moveTo(fx + 4, fy + 14);
      ctx.lineTo(fx + 6, fy + 10);
      ctx.lineTo(fx + 5, fy + 8);
      ctx.lineTo(fx + 7, fy + 6);
      ctx.lineTo(fx + 6, fy + 4);
      ctx.lineTo(fx + 8, fy + 2);
      ctx.lineTo(fx + 10, fy + 4);
      ctx.lineTo(fx + 9, fy + 6);
      ctx.lineTo(fx + 11, fy + 8);
      ctx.lineTo(fx + 10, fy + 10);
      ctx.lineTo(fx + 12, fy + 14);
      ctx.closePath();
      ctx.fill();
      
      // Middle flame (yellow/orange)
      ctx.fillStyle = anim < 3 ? '#ff8800' : '#ffaa00';
      ctx.beginPath();
      ctx.moveTo(fx + 5, fy + 12);
      ctx.lineTo(fx + 6.5, fy + 9);
      ctx.lineTo(fx + 6, fy + 7);
      ctx.lineTo(fx + 7.5, fy + 5);
      ctx.lineTo(fx + 7, fy + 3);
      ctx.lineTo(fx + 9, fy + 3);
      ctx.lineTo(fx + 8.5, fy + 5);
      ctx.lineTo(fx + 10, fy + 7);
      ctx.lineTo(fx + 9.5, fy + 9);
      ctx.lineTo(fx + 11, fy + 12);
      ctx.closePath();
      ctx.fill();
      
      // Top flame (yellow/white)
      ctx.fillStyle = anim < 2 ? '#ffd700' : (anim < 4 ? '#ffff00' : '#ffaa00');
      ctx.beginPath();
      ctx.moveTo(fx + 7, fy + 10);
      ctx.lineTo(fx + 7.5, fy + 7);
      ctx.lineTo(fx + 7.2, fy + 5);
      ctx.lineTo(fx + 8, fy + 3);
      ctx.lineTo(fx + 8.8, fy + 5);
      ctx.lineTo(fx + 8.5, fy + 7);
      ctx.lineTo(fx + 9, fy + 10);
      ctx.closePath();
      ctx.fill();
      
      // Small sparks/flickers
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(fx + 6 + (anim % 3), fy + 4, 1, 1);
      ctx.fillRect(fx + 9 - (anim % 2), fy + 5, 1, 1);
      
      ctx.restore();
    }
  });
  st.crimeEvents.forEach(evt => {
    if (evt.age<20) {
      const cx = evt.x * CL_SZ;
      const cy = evt.y * CL_SZ;
      const anim = evt.age % 4;
      
      ctx.save();
      
      // Draw pulsing circle (siren effect)
      const pulseSize = anim < 2 ? 1 : 0.7;
      ctx.fillStyle = anim < 2 ? 'rgba(220, 20, 60, 0.6)' : 'rgba(255, 0, 0, 0.4)';
      ctx.beginPath();
      ctx.arc(cx + 8, cy + 8, 6 * pulseSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw siren light (alternating red/blue)
      ctx.fillStyle = anim < 2 ? '#dc143c' : '#0066ff';
      ctx.beginPath();
      ctx.arc(cx + 8, cy + 8, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw exclamation mark
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(cx + 7.5, cy + 6, 1, 3);
      ctx.fillRect(cx + 7.5, cy + 10, 1, 1);
      
      // Draw light rays
      if (anim < 2) {
        ctx.strokeStyle = 'rgba(220, 20, 60, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const angle = (i * Math.PI / 4) + (evt.age * 0.3);
          ctx.beginPath();
          ctx.moveTo(cx + 8, cy + 8);
          ctx.lineTo(cx + 8 + Math.cos(angle) * 8, cy + 8 + Math.sin(angle) * 8);
          ctx.stroke();
        }
      }
      
      ctx.restore();
    }
  });
  st.cars.forEach(c => {
    ctx.save();
    
    // Determine car direction for rotation
    let angle = 0; // Default: horizontal (0 degrees)
    if (c.path && c.path.length > 1 && c.pathIdx < c.path.length - 1) {
      const curNode = c.path[c.pathIdx];
      const nextNode = c.path[c.pathIdx + 1];
      const dx = nextNode.x - curNode.x;
      const dy = nextNode.y - curNode.y;
      
      // If moving vertically (more vertical than horizontal), rotate 90 degrees
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2; // 90 degrees
      }
    } else if (c.entering && c.entryTarget) {
      // Check direction to entry target
      const dx = c.entryTarget.x - c.x;
      const dy = c.entryTarget.y - c.y;
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2;
      }
    } else if (c.exiting && c.exitTarget) {
      // Check direction to exit target
      const dx = c.exitTarget.x - c.x;
      const dy = c.exitTarget.y - c.y;
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2;
      }
    } else if (c.path && c.path.length > 0 && c.pathIdx < c.path.length) {
      // Fallback: check movement direction from current position
      const nextTarget = getCarSegmentTarget(c);
      if (nextTarget) {
        const dx = nextTarget.tx - c.x;
        const dy = nextTarget.ty - c.y;
        if (Math.abs(dy) > Math.abs(dx)) {
          angle = Math.PI / 2;
        }
      }
    }
    
      // Translate to car center, rotate, then translate back
      let carWidth = 3, carHeight = 2;
      if (c.type === 'fire') {
        carWidth = 7; // Fire trucks are longer
        carHeight = 4;
      } else if (c.type === 'police') {
        carWidth = 5;
        carHeight = 4;
      }
      const halfWidth = carWidth / 2;
      const halfHeight = carHeight / 2;
      let drawX = c.x;
      let drawY = c.y;
      let carCenterX = drawX + halfWidth;
      let carCenterY = drawY + halfHeight;
      const isVertical = Math.abs(Math.abs(angle) - Math.PI / 2) < 0.001;
      if (isVertical) {
        const snappedCenterX = snapCenterToPixelGrid(carCenterX, halfHeight);
        const snappedCenterY = snapCenterToPixelGrid(carCenterY, halfWidth);
        drawX += snappedCenterX - carCenterX;
        drawY += snappedCenterY - carCenterY;
        carCenterX = snappedCenterX;
        carCenterY = snappedCenterY;
      }
      ctx.translate(carCenterX, carCenterY);
      ctx.rotate(angle);
      ctx.translate(-carCenterX, -carCenterY);
    
    // Draw emergency vehicles with special styling
    if (c.type === 'police') {
      // Police car: dark gray body with single red/blue siren
      ctx.fillStyle = '#1a1a1a'; // Very dark gray, almost black
        ctx.fillRect(drawX-1, drawY-1, 5, 4);
      // Single red/blue alternating siren on top center
      const time = Date.now() / 200; // Blinking effect
      const redOn = Math.floor(time) % 2 === 0;
      ctx.fillStyle = redOn ? '#ff0000' : '#0066ff'; // Red or blue
        ctx.fillRect(Math.floor(drawX)+1, drawY-1, 2, 1); // Top center siren (2px wide)
    } else if (c.type === 'fire') {
      // Fire truck: longer body with single side-mounted flashing siren
      ctx.fillStyle = '#8b0000';
        ctx.fillRect(drawX-2, drawY-1, 7, 4); // Longer: 7x4 instead of 5x4
      // Single side siren (left side) alternating bright red/yellow
      const time = Date.now() / 200; // Blinking effect
      const redOn = Math.floor(time) % 2 === 0;
      ctx.fillStyle = redOn ? '#ff3333' : '#ffff00';
        ctx.fillRect(drawX-2, drawY, 1, 2); // Vertical bar on left side
    } else {
      // Regular cars
      ctx.fillStyle=c.color;
        ctx.fillRect(drawX, drawY, 3, 2);
    }
    
    ctx.restore();
  });
}

function drawLandValueOverlay() {
  ctx.save();
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      ctx.fillStyle=getLandValueOverlayColor(st.landValue[y][x]);
      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
    }
  }
  ctx.restore();
}

function getLandValueOverlayColor(value) {
  const ratio=Math.max(0,Math.min(1,(value||0)/100));
  const r=Math.round(LAND_VALUE_LOW_COLOR.r+(LAND_VALUE_HIGH_COLOR.r-LAND_VALUE_LOW_COLOR.r)*ratio);
  const g=Math.round(LAND_VALUE_LOW_COLOR.g+(LAND_VALUE_HIGH_COLOR.g-LAND_VALUE_LOW_COLOR.g)*ratio);
  const b=Math.round(LAND_VALUE_LOW_COLOR.b+(LAND_VALUE_HIGH_COLOR.b-LAND_VALUE_LOW_COLOR.b)*ratio);
  return `rgba(${r},${g},${b},0.4)`;
}

function setLandValueOverlay(active) {
  const enable=!!active;
  if (enable) {
    showLandValueOverlay=true;
    updLV();
    drGr();
    // Update status text to indicate stats mode
    const sTx = document.getElementById('statusText');
    sTx.textContent = 'click buildings to view details';
    return;
  }
  if (showLandValueOverlay) {
    showLandValueOverlay=false;
    hideBuildingInfo();
    drGr();
    // Restore status text
    const sTx = document.getElementById('statusText');
    if (st.selectedTool) {
      const tl = st.selectedTool;
      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';
      else {
        const dn = tl.startsWith('park') ? 'park' : tl;
        sTx.textContent = `placing ${dn}`;
      }
    } else {
      sTx.textContent = 'select a tool to start building';
    }
  }
}

function drawCrimeOverlay() {
  ctx.save();
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      ctx.fillStyle=getCrimeOverlayColor(st.crime[y][x]||30);
      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
    }
  }
  ctx.restore();
}

function getCrimeOverlayColor(value) {
  const crimeLevel=Math.max(0,Math.min(100,value||30));
  let r, g, b;
  if (crimeLevel>=70) {
    // High crime: red (255,0,0) to dark red (200,0,0)
    const ratio=(crimeLevel-70)/30;
    r=Math.round(200+55*ratio);
    g=0;
    b=0;
  } else if (crimeLevel>=30) {
    // Medium crime: yellow (255,255,0) to red (255,0,0)
    const ratio=(crimeLevel-30)/40;
    r=255;
    g=Math.round(255*(1-ratio));
    b=0;
  } else {
    // Low crime: green (0,255,0) to yellow (255,255,0)
    const ratio=crimeLevel/30;
    r=Math.round(255*ratio);
    g=255;
    b=0;
  }
  return `rgba(${r},${g},${b},0.5)`;
}

function setCrimeOverlay(active) {
  const enable=!!active;
  if (enable) {
    showCrimeOverlay=true;
    updCrime();
    drGr();
    // Update status text to indicate stats mode
    const sTx = document.getElementById('statusText');
    sTx.textContent = 'click buildings to view details';
    return;
  }
  if (showCrimeOverlay) {
    showCrimeOverlay=false;
    hideBuildingInfo();
    drGr();
    // Restore status text
    const sTx = document.getElementById('statusText');
    if (st.selectedTool) {
      const tl = st.selectedTool;
      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';
      else {
        const dn = tl.startsWith('park') ? 'park' : tl;
        sTx.textContent = `placing ${dn}`;
      }
    } else {
      sTx.textContent = 'select a tool to start building';
    }
  }
}

function findPath(sx,sy,ex,ey, maxLength=50) {
  const q=[{x:sx,y:sy,path:[{x:sx,y:sy}]}], vis=new Set();
  while(q.length>0) {
    const cur=q.shift(), k=`${cur.x},${cur.y}`;
    if (vis.has(k)) continue;
    vis.add(k);
    if (cur.x===ex && cur.y===ey) return cur.path;
    if (cur.path.length>maxLength) continue;
    const dirs=[[0,-1],[1,0],[0,1],[-1,0]];
    for (const [dx,dy] of dirs) {
      const nx=cur.x+dx, ny=cur.y+dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && !vis.has(`${nx},${ny}`)) {
        if (st.grid[ny][nx].type==='road') {
          q.push({x:nx,y:ny,path:[...cur.path,{x:nx,y:ny}]});
        }
      }
    }
  }
  return null;
}

function ensureStationDispatchMap() {
  if (!st.stationDispatches) st.stationDispatches={};
}

function getStationKeyFromCoords(x,y) {
  return `${x},${y}`;
}

function getStationDispatchCount(key) {
  ensureStationDispatchMap();
  return st.stationDispatches[key]||0;
}

function incrementStationDispatchCount(key) {
  ensureStationDispatchMap();
  st.stationDispatches[key]=(st.stationDispatches[key]||0)+1;
}

function releaseStationSlot(car) {
  if (!car || !car.stationKey) return;
  ensureStationDispatchMap();
  if (st.stationDispatches[car.stationKey]) {
    st.stationDispatches[car.stationKey]--;
    if (st.stationDispatches[car.stationKey]<0) st.stationDispatches[car.stationKey]=0;
  }
  car.stationKey=null;
}

function getCurrentRoadNode(car) {
  if (car && car.path && car.path[car.pathIdx]) return car.path[car.pathIdx];
  if (car && car.sceneRoad) return car.sceneRoad;
  if (car && car.stationRoad) return car.stationRoad;
  return null;
}

function findNearestStation(targetX, targetY, stationType) {
  // Find nearest road to target location
  const targetRoads = [];
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      const nx = targetX + dx, ny = targetY + dy;
      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {
        if (st.grid[ny][nx].type === 'road') {
          targetRoads.push({x: nx, y: ny});
        }
      }
    }
  }
  if (targetRoads.length === 0) return null;
  
  // Find all stations of the requested type
  const stations = [];
  for (let y = 0; y < GR_SZ; y++) {
    for (let x = 0; x < GR_SZ; x++) {
      const c = st.grid[y][x];
      if (c.type === stationType && hasRdAcc(x, y)) {
        // Find nearest road to this station
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {
              if (st.grid[ny][nx].type === 'road') {
                stations.push({stationX: x, stationY: y, roadX: nx, roadY: ny});
                break;
              }
            }
          }
        }
      }
    }
  }
  if (stations.length === 0) return null;
  
  // Find nearest station by pathfinding distance
  let nearestStation = null;
  let minDistance = Infinity;
  
  // Use a more efficient search - limit pathfinding to reasonable distances for emergency dispatch
  for (const station of stations) {
    // Quick distance check first (Manhattan distance) to skip obviously too far stations
    const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);
    if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) continue;
    for (const targetRoad of targetRoads) {
      const manhattanDist = Math.abs(station.roadX - targetRoad.x) + Math.abs(station.roadY - targetRoad.y);
      if (manhattanDist > 100) continue; // Skip stations that are clearly too far
      
      const path = findPath(station.roadX, station.roadY, targetRoad.x, targetRoad.y, 100);
      if (path && path.length < minDistance) {
        minDistance = path.length;
        nearestStation = {
          stationX: station.stationX,
          stationY: station.stationY,
          roadX: station.roadX,
          roadY: station.roadY,
          targetRoadX: targetRoad.x,
          targetRoadY: targetRoad.y,
          path: path
        };
        // Early exit if we find a very close station (within 10 tiles)
        if (path.length <= 10) break;
      }
    }
    if (nearestStation && nearestStation.path && nearestStation.path.length <= 10) break;
  }
  
  return nearestStation;
}

function dispatchEmergencyVehicle(stationType, targetX, targetY, missionType) {
  const station = findNearestStation(targetX, targetY, stationType);
  if (!station || !station.path || station.path.length < 2) return false;
  const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);
  if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) return false;
  
  const start = {x: station.roadX, y: station.roadY};
  const end = {x: station.targetRoadX, y: station.targetRoadY};
  const path = station.path;
  
  // Determine lane offset
  let laneOffset = 0;
  const startCenterX = path[0].x * CL_SZ + 7;
  const startCenterY = path[0].y * CL_SZ + 7;
  let startX = startCenterX;
  let startY = startCenterY;
  
  if (path.length >= 2) {
    const dx = path[1].x - path[0].x;
    const dy = path[1].y - path[0].y;
    if (Math.abs(dx) > Math.abs(dy)) {
      laneOffset = dx > 0 ? 5 : -5;
      startY += laneOffset;
    } else {
      laneOffset = dy > 0 ? -5 : 5;
      startX += laneOffset;
    }
  }
  
  const stationBuilding = {x: station.stationX, y: station.stationY};
  const entryDir = getEdgeDirection(stationBuilding, start);
  let entryTarget = null;
  let entering = false;
  let spawnX = startX;
  let spawnY = startY;
  
  if (entryDir.x !== 0 || entryDir.y !== 0) {
    entering = true;
    entryTarget = {x: startX, y: startY};
    if (Math.abs(entryDir.x) >= Math.abs(entryDir.y) && entryDir.x !== 0) {
      spawnX = startCenterX + entryDir.x * CAR_EDGE_OFFSET;
      spawnY = startY;
    } else if (entryDir.y !== 0) {
      spawnY = startCenterY + entryDir.y * CAR_EDGE_OFFSET;
      spawnX = startX;
    }
  }
  
  // Fire trucks: red (will be styled with lights), Police cars: very dark gray (will be styled with lights)
  const color = stationType === 'fire' ? '#ff0000' : '#1a1a1a';
  const vehicleType = stationType === 'fire' ? 'fire' : 'police';
  
  st.cars.push({
    x: spawnX,
    y: spawnY,
    path: path,
    pathIdx: 0,
    color: color,
    type: vehicleType,
    laneOffset: laneOffset,
    reverse: false,
    entering: entering,
    entryTarget: entryTarget,
    exiting: false,
    exitLaneTarget: null,
    exitTarget: null,
    positioningForExit: false,
    stationRoad: { x: start.x, y: start.y },
    sceneRoad: { x: end.x, y: end.y },
    missionPhase: 'enroute',
    stationKey: stationKey,
    stationCoords: { x: station.stationX, y: station.stationY },
    mission: {
      type: missionType,
      targetX: targetX,
      targetY: targetY,
      arrived: false,
      returning: false
    }
  });
  incrementStationDispatchCount(stationKey);
  
  return true;
}

function getRoadCenterCoords(node) {
  if (!node) return { x: 0, y: 0 };
  return { x: node.x * CL_SZ + 7, y: node.y * CL_SZ + 7 };
}

function prepareEmergencyVehicleReturn(car, opts={}) {
  if (!car || !car.mission || car.mission.returning) return;
  
  const startRoad = getCurrentRoadNode(car);
  const stationRoad = car.stationRoad;
  if (!startRoad || !stationRoad) {
    car.removeOnNextTick = true;
    releaseStationSlot(car);
    return;
  }
  
  if (!opts.skipSceneDecrement && car.mission.arrived) {
    if (car.mission.type === 'fire') {
      const fire = st.fires.find(f => f.x === car.mission.targetX && f.y === car.mission.targetY);
      if (fire && fire.fireTrucksAtScene>0) fire.fireTrucksAtScene--;
    } else if (car.mission.type === 'crime') {
      const crime = st.crimeEvents.find(evt => evt.x === car.mission.targetX && evt.y === car.mission.targetY);
      if (crime && crime.policeCarsAtScene>0) crime.policeCarsAtScene--;
    }
  }
  
  const returnPath = findPath(startRoad.x, startRoad.y, stationRoad.x, stationRoad.y, 100);
  if (!returnPath || returnPath.length<2) {
    car.removeOnNextTick = true;
    releaseStationSlot(car);
    return;
  }
  
  car.path = returnPath;
  car.pathIdx = 0;
  car.mission.returning = true;
  car.mission.arrived = false;
  car.missionPhase = 'returning';
  car.entering = true;
  car.exiting = false;
  car.exitTarget = null;
  car.reverse = false;
  car.holdPosition = null;
  
  const startCenter = getRoadCenterCoords(returnPath[0]);
  car.x = startCenter.x;
  car.y = startCenter.y;
  let entryX = startCenter.x;
  let entryY = startCenter.y;
  car.laneOffset = 0;
  if (returnPath.length>=2) {
    const dx = returnPath[1].x - returnPath[0].x;
    const dy = returnPath[1].y - returnPath[0].y;
    if (Math.abs(dx)>Math.abs(dy)) {
      car.laneOffset = dx>0 ? 5 : -5;
      entryY += car.laneOffset;
    } else {
      car.laneOffset = dy>0 ? -5 : 5;
      entryX += car.laneOffset;
    }
  }
  car.entryTarget = { x: entryX, y: entryY };

  const stationBuilding = car.stationCoords || { x: car.stationRoad.x, y: car.stationRoad.y };
  const endIdx = returnPath.length - 1;
  const endNode = returnPath[endIdx];
  const endCenterX = endNode.x * CL_SZ + 7;
  const endCenterY = endNode.y * CL_SZ + 7;
  let exitLaneX = endCenterX;
  let exitLaneY = endCenterY;
  if (returnPath.length >= 2) {
    const dxLast = returnPath[endIdx].x - returnPath[endIdx - 1].x;
    const dyLast = returnPath[endIdx].y - returnPath[endIdx - 1].y;
    if (Math.abs(dxLast) > Math.abs(dyLast)) {
      exitLaneY += dxLast > 0 ? 5 : -5;
    } else {
      exitLaneX += dyLast > 0 ? -5 : 5;
    }
  }
  const exitDir = getEdgeDirection(stationBuilding, stationRoad);
  let exitTarget = null;
  if (exitDir.x !== 0 || exitDir.y !== 0) {
    exitTarget = { x: exitLaneX, y: exitLaneY };
    if (Math.abs(exitDir.x) >= Math.abs(exitDir.y) && exitDir.x !== 0) {
      exitTarget.x = endCenterX + exitDir.x * CAR_EDGE_OFFSET;
    } else if (exitDir.y !== 0) {
      exitTarget.y = endCenterY + exitDir.y * CAR_EDGE_OFFSET;
    }
  } else {
    // If no direction detected, use a default offset toward the station
    exitTarget = { x: exitLaneX, y: exitLaneY };
    // Try to find direction from road to station building
    const dx = stationBuilding.x - stationRoad.x;
    const dy = stationBuilding.y - stationRoad.y;
    if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) {
      exitTarget.x = endCenterX + (dx > 0 ? CAR_EDGE_OFFSET : -CAR_EDGE_OFFSET);
    } else if (dy !== 0) {
      exitTarget.y = endCenterY + (dy > 0 ? CAR_EDGE_OFFSET : -CAR_EDGE_OFFSET);
    } else {
      // Station is on the road tile, just offset slightly
      exitTarget.x = endCenterX + CAR_EDGE_OFFSET;
    }
  }
  car.exitLaneTarget = { x: exitLaneX, y: exitLaneY };
  car.exitTarget = exitTarget;
  car.positioningForExit = false;
}

function sendEmergencyVehiclesHome(missionType, targetX, targetY) {
  st.cars.forEach(car => {
    if (!car.mission || car.mission.returning) return;
    if (car.mission.type===missionType && car.mission.targetX===targetX && car.mission.targetY===targetY) {
      prepareEmergencyVehicleReturn(car);
    }
  });
}
  
function attemptMissionArrival(car) {
  if (!car || !car.mission || car.mission.returning) return false;
  const buildingTarget = {
    x: car.mission.targetX * CL_SZ + CL_SZ / 2,
    y: car.mission.targetY * CL_SZ + CL_SZ / 2
  };
  const roadTarget = car.sceneRoad ? getRoadCenterCoords(car.sceneRoad) : null;
  // Fire and police cars should always stop at the road tile center, no offsets
  const targetToUse = roadTarget || buildingTarget;
  if (!targetToUse) return false;
  const dx = targetToUse.x - car.x;
  const dy = targetToUse.y - car.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const threshold = CL_SZ * 2.5;
  if (dist < threshold) {
    if (!car.mission.arrived) {
      car.mission.arrived = true;
      car.missionPhase = 'onscene';
        // Police and fire vehicles stop exactly at road tile center, no lane offsets
        const holdTarget = roadTarget || buildingTarget;
        if (holdTarget) {
          car.holdPosition = { x: holdTarget.x, y: holdTarget.y };
          car.x = car.holdPosition.x;
          car.y = car.holdPosition.y;
          // Clear any lane offsets for emergency vehicles
          if (car.type === 'police' || car.type === 'fire') {
            car.laneOffset = 0;
          }
        } else {
          car.holdPosition = { x: car.x, y: car.y };
        }
      if (!car.arrivalLogged) {
        if (car.mission.type === 'fire') {
          const fire = st.fires.find(f => f.x === car.mission.targetX && f.y === car.mission.targetY);
          if (fire) fire.fireTrucksAtScene = (fire.fireTrucksAtScene || 0) + 1;
        } else if (car.mission.type === 'crime') {
          const crime = st.crimeEvents.find(evt => evt.x === car.mission.targetX && evt.y === car.mission.targetY);
          if (crime) crime.policeCarsAtScene = (crime.policeCarsAtScene || 0) + 1;
        }
        car.arrivalLogged = true;
      }
    } else if (!car.holdPosition) {
      car.holdPosition = { x: car.x, y: car.y };
    }
    return true;
  }
  return false;
}
 
function countActiveResponders(missionType, targetX, targetY) {
  if (!st.cars) return 0;
  return st.cars.reduce((sum, car) => {
    if (car.mission && !car.mission.returning && car.mission.type===missionType && car.mission.targetX===targetX && car.mission.targetY===targetY) {
      return sum+1;
    }
    return sum;
  },0);
}

function ensureEmergencyCoverage() {
  if (st.fires) {
    st.fires.forEach(fire => {
      if (countActiveResponders('fire', fire.x, fire.y)===0) {
        dispatchEmergencyVehicle('fire', fire.x, fire.y, 'fire');
      }
    });
  }
  if (st.crimeEvents) {
    st.crimeEvents.forEach(evt => {
      if (countActiveResponders('crime', evt.x, evt.y)===0) {
        dispatchEmergencyVehicle('police', evt.x, evt.y, 'crime');
      }
    });
  }
}
 
function getEdgeDirection(structCell,roadCell) {
  if (!structCell || !roadCell) return {x:0,y:0};
  const dx=structCell.x-roadCell.x;
  const dy=structCell.y-roadCell.y;
  if (dx===0 && dy===0) return {x:0,y:0};
  if (Math.abs(dx)>Math.abs(dy)) return {x:dx>0?1:-1,y:0};
  if (Math.abs(dy)>Math.abs(dx)) return {x:0,y:dy>0?1:-1};
  if (dx!==0) return {x:dx>0?1:-1,y:0};
  return {x:0,y:dy>0?1:-1};
}

function spawnCar() {
  const res=[], com=[], ind=[], pol=[], fir=[];
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential' && !c.abandoned && hasRdAcc(x,y)) res.push({x,y});
    else if (c.type==='commercial' && !c.abandoned && hasRdAcc(x,y)) com.push({x,y});
    else if (c.type==='industrial' && !c.abandoned && hasRdAcc(x,y)) ind.push({x,y});
    else if (c.type==='police' && hasRdAcc(x,y)) pol.push({x,y});
    else if (c.type==='fire' && hasRdAcc(x,y)) fir.push({x,y});
  }
  if (res.length===0) return;
  
  let tp='normal', src, dst, clr;
  // Emergency vehicles are now dispatched via dispatchEmergencyVehicle(), not spawned randomly
  // So we only spawn normal civilian cars here
  {
    src=res[Math.floor(Math.random()*res.length)];
    const dests=[...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);
    if (dests.length===0) return;
    dst=dests[Math.floor(Math.random()*dests.length)];
    const rnd=Math.random();
    if (rnd<0.7) clr='#808080';
    else if (rnd<0.85) clr='#a0a0a0';
    else if (rnd<0.95) clr='#606060';
    else clr=['#ffeb3b','#4caf50','#9c27b0'][Math.floor(Math.random()*3)];
  }
  
  const rdNear=[];
  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
    const nx=src.x+dx, ny=src.y+dy;
    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdNear.push({x:nx,y:ny});
  }
  if (rdNear.length===0) return;
  const start=rdNear[Math.floor(Math.random()*rdNear.length)];
  
  const rdEnd=[];
  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
    const nx=dst.x+dx, ny=dst.y+dy;
    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdEnd.push({x:nx,y:ny});
  }
  if (rdEnd.length===0) return;
  const end=rdEnd[Math.floor(Math.random()*rdEnd.length)];
  
  const path=findPath(start.x,start.y,end.x,end.y);
  if (!path || path.length<2) return;
  
    // Determine direction: randomly choose forward or reverse
    const reverse=Math.random()<0.5;
    const carPath=reverse ? [...path].reverse() : path;
    const spawnRoad=reverse ? end : start;
    const exitRoad=reverse ? start : end;
    const spawnBuilding=reverse ? dst : src;
    const exitBuilding=reverse ? src : dst;
    
    // Determine lane offset based on first segment direction
    // Cars going in opposite directions should be in opposite lanes
    let laneOffset=0;
    const startCenterX=carPath[0].x*CL_SZ+7;
    const startCenterY=carPath[0].y*CL_SZ+7;
    let startX=startCenterX;
    let startY=startCenterY;
    
    if (carPath.length>=2) {
      const dx=carPath[1].x-carPath[0].x;
      const dy=carPath[1].y-carPath[0].y;
      
      if (Math.abs(dx)>Math.abs(dy)) {
        // Horizontal movement: use y offset for lanes
        // Left-to-right (dx > 0): bottom lane (+5)
        // Right-to-left (dx < 0): top lane (-5)
        laneOffset=dx>0 ? 5 : -5;
        startY+=laneOffset;
      } else {
        // Vertical movement: use x offset for lanes
        // Ensure right-hand traffic: southbound (dy > 0) stays to the viewer's left (laneOffset = -5)
        laneOffset=dy>0 ? -5 : 5;
        startX+=laneOffset;
      }
    }
    
    const entryDir=getEdgeDirection(spawnBuilding,spawnRoad);
    let entryTarget=null;
    let entering=false;
    let spawnX=startX;
    let spawnY=startY;
    if (entryDir.x!==0 || entryDir.y!==0) {
      entering=true;
      entryTarget={x:startX,y:startY};
      if (Math.abs(entryDir.x)>=Math.abs(entryDir.y) && entryDir.x!==0) {
        spawnX=startCenterX+entryDir.x*CAR_EDGE_OFFSET;
        spawnY=startY;
      } else if (entryDir.y!==0) {
        spawnY=startCenterY+entryDir.y*CAR_EDGE_OFFSET;
        spawnX=startX;
      }
    }
    
    const endIdx=carPath.length-1;
    const endNode=carPath[endIdx];
    const endCenterX=endNode.x*CL_SZ+7;
    const endCenterY=endNode.y*CL_SZ+7;
    let exitLaneX=endCenterX;
    let exitLaneY=endCenterY;
    if (carPath.length>=2) {
      const dxLast=carPath[endIdx].x-carPath[endIdx-1].x;
      const dyLast=carPath[endIdx].y-carPath[endIdx-1].y;
      if (Math.abs(dxLast)>Math.abs(dyLast)) {
        exitLaneY+=dxLast>0 ? 5 : -5;
      } else {
        exitLaneX+=dyLast>0 ? -5 : 5;
      }
    }
    const exitDir=getEdgeDirection(exitBuilding,exitRoad);
    let exitLaneTarget={x:exitLaneX,y:exitLaneY};
    let exitTarget=null;
    if (exitDir.x!==0 || exitDir.y!==0) {
      exitTarget={x:exitLaneX,y:exitLaneY};
      if (Math.abs(exitDir.x)>=Math.abs(exitDir.y) && exitDir.x!==0) {
        exitTarget.x=endCenterX+exitDir.x*CAR_EDGE_OFFSET;
      } else if (exitDir.y!==0) {
        exitTarget.y=endCenterY+exitDir.y*CAR_EDGE_OFFSET;
      }
    }
    
    st.cars.push({
      x:spawnX,
      y:spawnY,
      path:carPath,
      pathIdx:0,
      color:clr,
      type:tp,
      laneOffset:laneOffset,
      reverse:reverse,
      entering:entering,
      entryTarget:entryTarget,
      exiting:false,
      exitLaneTarget:exitLaneTarget,
      exitTarget:exitTarget
    });
}
  
function updCars() {
  st.cars=st.cars.filter(c => {
      const finalizeRemoval = () => {
        if (c.mission && c.mission.returning) releaseStationSlot(c);
        return false;
      };
      if (c.removeOnNextTick) return finalizeRemoval();
    
    if (c.mission && !c.mission.returning) {
      const targetGridX = c.mission.targetX;
      const targetGridY = c.mission.targetY;
      let targetExists = false;
      if (c.mission.type === 'fire') {
        targetExists = st.fires.some(f => f.x === targetGridX && f.y === targetGridY);
      } else if (c.mission.type === 'crime') {
        targetExists = st.crimeEvents.some(evt => evt.x === targetGridX && evt.y === targetGridY);
      }
      
      if (!targetExists) {
        prepareEmergencyVehicleReturn(c);
        } else if (!c.mission.arrived) {
          if (attemptMissionArrival(c)) return true;
      } else {
        return true;
      }
    }
    
    if (c.mission && c.mission.arrived && !c.mission.returning) {
      if (c.holdPosition) {
        c.x = c.holdPosition.x;
        c.y = c.holdPosition.y;
        // Ensure emergency vehicles stay at exact road center, no offsets
        if ((c.type === 'police' || c.type === 'fire') && c.sceneRoad) {
          const exactCenter = getRoadCenterCoords(c.sceneRoad);
          c.x = exactCenter.x;
          c.y = exactCenter.y;
          c.holdPosition = exactCenter;
          c.laneOffset = 0;
        }
      } else if (c.sceneRoad) {
        const center = getRoadCenterCoords(c.sceneRoad);
        c.holdPosition = center;
        c.x = center.x;
        c.y = center.y;
        if (c.type === 'police' || c.type === 'fire') {
          c.laneOffset = 0;
        }
      } else {
        c.holdPosition = { x: c.x, y: c.y };
      }
      return true;
    }
    
    let remainingDist=getCarSpeedPerFrame(c);
    if (remainingDist<=0) return true;
    
    // Helper to check if car reached end of path
    const isAtPathEnd = () => c.pathIdx >= c.path.length - 1;
    
    // Helper to initiate exit sequence
    const startExitSequence = () => {
      if (c.exitLaneTarget) {
        c.positioningForExit = true;
      } else if (c.exitTarget) {
        c.exiting = true;
      } else {
        return false; // No exit sequence available
      }
      return true;
    };
    
    while (remainingDist>0) {
      // Determine target based on current car state
      let targetStage, tx, ty;
      
      if (c.entering && c.entryTarget) {
        targetStage = 'entry';
        tx = c.entryTarget.x;
        ty = c.entryTarget.y;
      } else if (c.exiting && c.exitTarget) {
        targetStage = 'exit';
        tx = c.exitTarget.x;
        ty = c.exitTarget.y;
      } else if (c.positioningForExit && c.exitLaneTarget) {
        targetStage = 'positioning';
        tx = c.exitLaneTarget.x;
        ty = c.exitLaneTarget.y;
      } else {
        // Handle path-following and end-of-path logic
        if (isAtPathEnd()) {
          // Mission vehicles that haven't arrived yet
          if (c.mission && !c.mission.returning) {
            if (attemptMissionArrival(c)) return true;
            c.holdPosition = c.holdPosition || { x: c.x, y: c.y };
            c.x = c.holdPosition.x;
            c.y = c.holdPosition.y;
            return true;
          }
          // Start exit sequence or despawn
          if (!startExitSequence()) {
            return finalizeRemoval();
          }
          continue;
        }
        
        // Normal path following
        targetStage = 'path';
        const nextTarget = getCarSegmentTarget(c);
        tx = nextTarget.tx;
        ty = nextTarget.ty;
      }
      
      // Move toward target
      const dx = tx - c.x;
      const dy = ty - c.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      // Snap to target when very close
      if (dist < CAR_SNAP_THRESHOLD) {
        c.x = tx;
        c.y = ty;
        
        // Handle state transitions
        if (targetStage === 'entry') {
          c.entering = false;
          c.entryTarget = null;
        } else if (targetStage === 'positioning') {
          c.positioningForExit = false;
          if (c.exitTarget) {
            c.exiting = true;
          } else {
            return finalizeRemoval();
          }
        } else if (targetStage === 'exit') {
          return finalizeRemoval();
        } else {
          // Advance path
          c.pathIdx++;
          if (isAtPathEnd()) {
            if (!startExitSequence()) {
              return finalizeRemoval();
            }
          } else {
            updateCarLaneOffset(c);
          }
        }
        continue;
      }
      
      // Move step toward target
      const step = Math.min(dist, remainingDist);
      c.x += dx / dist * step;
      c.y += dy / dist * step;
      remainingDist -= step;
      
      if (step < dist) break; // Not enough distance remaining
    }
    return true;
  });
  
  const maxCars=Math.min(60,Math.floor(st.population/18)+8);
  const populationFactor=Math.min(1,st.population/4000);
  const totalDemand=
    Math.max(0,(st.rDemand||0))+
    Math.max(0,(st.cDemand||0))+
    Math.max(0,(st.iDemand||0));
  const demandFactor=Math.min(1,totalDemand/400);
  const spawnChance=Math.min(0.25,0.02+0.1*populationFactor+0.08*demandFactor);
  if (st.speed>0 && st.population>10 && st.cars.length<maxCars && Math.random()<spawnChance) {
    spawnCar();
    if (st.cars.length<maxCars && Math.random()<0.15) spawnCar();
  }
}

function updInpWd() {
  const inp=document.getElementById('cityName'), tmp=document.createElement('span');
  tmp.style.font=window.getComputedStyle(inp).font; tmp.style.visibility='hidden'; tmp.style.position='absolute'; tmp.style.whiteSpace='pre';
  tmp.textContent=inp.value||inp.placeholder||'new city'; document.body.appendChild(tmp); inp.style.width=(tmp.offsetWidth+8)+'px'; document.body.removeChild(tmp);
}

function shwNxtNws() {
  if (nwsQ.length>0 && !trans) {
    const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=nwsQ.shift();
    if (ot===nt) return;
    trans=true; tk.classList.add('ticker-roll');
    setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';
      setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';
        setTimeout(() => { trans=false; if (nwsQ.length>0) setTimeout(shwNxtNws,100); },500);
      },10);
    },500);
    return;
  }
  if (st.newsEvents.length===0||trans) return;
  const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=st.newsEvents[nwsIdx];
  if (ot===nt) { nwsIdx=(nwsIdx+1)%st.newsEvents.length; return; }
  trans=true; tk.classList.add('ticker-roll');
  setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';
    setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';
      setTimeout(() => { trans=false; },500);
    },10);
  },500);
  nwsIdx=(nwsIdx+1)%st.newsEvents.length;
}

function updNwsTk() {
  if (tkrTmr) clearInterval(tkrTmr);
  if (st.newsEvents.length>0 && st.speed>0) {
    nwsIdx=st.newsEvents.length-1; const tk=document.getElementById('newsTicker');
    tk.textContent=st.newsEvents[nwsIdx]; tk.style.transform='translateY(0)'; tk.style.opacity='1';
    nwsIdx=(nwsIdx+1)%st.newsEvents.length; tkrTmr=setInterval(shwNxtNws,5000);
  } else {
    const tk=document.getElementById('newsTicker');
    if (st.speed===0) tk.textContent=st.newsEvents.length>0?st.newsEvents[st.newsEvents.length-1]:'';
    else if (st.newsEvents.length===0) tk.textContent='';
    tk.classList.remove('ticker-roll');
  }
}

const STAT_INFO_TYPES = ['rci','pop','money','happy'];
let currentInfoType = null;

function shwInfo(title,content,infoType) {
  plySnd('click');
  const pnl=document.getElementById('infoPanel');
  
  // If clicking the same stat, toggle it off
  if (currentInfoType === infoType && !pnl.classList.contains('hidden')) {
    pnl.classList.add('hidden');
    currentInfoType = null;
    setLandValueOverlay(false);
    setCrimeOverlay(false);
    return;
  }
  
  // Otherwise, show the new panel
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('aiPanel').classList.add('hidden');
  document.getElementById('infoTitle').textContent=title;
  document.getElementById('infoContent').innerHTML=content;
  pnl.classList.remove('hidden');
  currentInfoType = infoType;
  if (infoType === 'happy') {
    setLandValueOverlay(false);
    setCrimeOverlay(true);
  } else {
    setCrimeOverlay(false);
    setLandValueOverlay(STAT_INFO_TYPES.includes(infoType));
  }
}

function updUI() {
  const inp=document.getElementById('cityName'); if (!edtNm) { inp.value=st.cityName; updInpWd(); }
  document.getElementById('population').textContent=st.population.toLocaleString();
  document.getElementById('money').textContent=`${(st.money/1000).toFixed(0)}k`;
  document.getElementById('happiness').textContent=st.happiness;
  if (!edtNm) document.getElementById('yearDisplay').textContent=st.year;
  const mEl=document.getElementById('money');
  if (st.money<0) { mEl.classList.remove('text-white'); mEl.classList.add('text-red-400'); }
  else { mEl.classList.remove('text-red-400'); mEl.classList.add('text-white'); }
  const rB=document.getElementById('rDemand'), cB=document.getElementById('cDemand'), iB=document.getElementById('iDemand');
  rB.style.height=`${st.rDemand}%`; cB.style.height=`${st.cDemand}%`; iB.style.height=`${st.iDemand}%`;
  rB.parentElement.style.display='flex'; rB.parentElement.style.flexDirection='column'; rB.parentElement.style.justifyContent='flex-end';
  cB.parentElement.style.display='flex'; cB.parentElement.style.flexDirection='column'; cB.parentElement.style.justifyContent='flex-end';
  iB.parentElement.style.display='flex'; iB.parentElement.style.flexDirection='column'; iB.parentElement.style.justifyContent='flex-end';
  const sBtn=document.getElementById('speedToggle');
  if (st.speed===0) sBtn.textContent='‚è∏'; else if (st.speed===3000) sBtn.textContent='1x'; else if (st.speed===1500) sBtn.textContent='2x'; else if (st.speed===500) sBtn.textContent='3x';
}

function selTl(tl) {
  st.selectedTool=tl;
  updateToolSelection();
  const c=COSTS[tl]||0, cTx=document.getElementById('costText'), sTx=document.getElementById('statusText');
  if (tl==='bulldoze') { sTx.textContent='click to demolish buildings'; cTx.textContent=''; }
  else if (tl) { const dn=tl.startsWith('park')?'park':tl; sTx.textContent=`placing ${dn}`; cTx.textContent=c>0?`$${c.toLocaleString()}`:''; }
  else { sTx.textContent='select a tool to start building'; cTx.textContent=''; }
}

function canPlLg(x,y,w,h,zt) {
  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=GR_SZ||ny>=GR_SZ) return false;
    const c=st.grid[ny][nx]; 
    // Normalize empty cells to ensure they're 1x1
    if (c.type==='empty') normalizeEmptyCell(nx,ny);
    // Prevent merging through roads and other incompatible tiles
    if (c.type==='road') return false;
    if (c.type!=='empty' && c.type!==zt && !c.abandoned) return false;
    const tr=st.terrain[ny][nx]; if (tr==='water'||tr==='cliff') return false;
  }
  return true;
}

// Helper: given any cell in a building, find the building's top-left and size
function getBuildingBoundsFromCell(x,y) {
  const c=st.grid[y][x];
  if (!c) return {startX:x,startY:y,w:1,h:1};
  // If this cell has a buildingId, use it as the primary way to find bounds
  if (c.buildingId != null && c.type!=='empty') {
    const targetId = c.buildingId;
    const visited = new Set();
    const queue = [{x,y}];
    let minX = x, maxX = x, minY = y, maxY = y;

    while (queue.length>0) {
      const cur = queue.shift();
      const key = `${cur.x},${cur.y}`;
      if (visited.has(key)) continue;
      visited.add(key);
      if (cur.x<0 || cur.x>=GR_SZ || cur.y<0 || cur.y>=GR_SZ) continue;
      const cell = st.grid[cur.y][cur.x];
      if (!cell || cell.buildingId!==targetId) continue;

      if (cur.x<minX) minX=cur.x;
      if (cur.x>maxX) maxX=cur.x;
      if (cur.y<minY) minY=cur.y;
      if (cur.y>maxY) maxY=cur.y;

      queue.push({x:cur.x-1,y:cur.y});
      queue.push({x:cur.x+1,y:cur.y});
      queue.push({x:cur.x,y:cur.y-1});
      queue.push({x:cur.x,y:cur.y+1});
    }

    const w = maxX-minX+1;
    const h = maxY-minY+1;
    return {startX:minX,startY:minY,w,h};
  }

  // Fallback: legacy logic based on w/h only
  const baseW=c.w||1, baseH=c.h||1;

  // Single-tile structures (including empty zones) should never sweep across
  // adjacent tiles just because they share the same zone type. Treat them as
  // isolated cells so bulldozing/park placement only affects the clicked tile.
  if (baseW===1 && baseH===1) return {startX:x,startY:y,w:1,h:1};

  let startX = x;
  let startY = y;

  let stepsLeft = 0;
  while (startX > 0 && stepsLeft < baseW-1) {
    const left = st.grid[y][startX-1];
    if (left && left.type === c.type && (left.w||1) === baseW && (left.h||1) === baseH) {
      startX--;
      stepsLeft++;
    } else {
      break;
    }
  }

  let stepsUp = 0;
  while (startY > 0 && stepsUp < baseH-1) {
    const above = st.grid[startY-1][startX];
    if (above && above.type === c.type && (above.w||1) === baseW && (above.h||1) === baseH) {
      startY--;
      stepsUp++;
    } else {
      break;
    }
  }

  let consistent = true;
  for (let dy=0; dy<baseH && consistent; dy++) {
    for (let dx=0; dx<baseW; dx++) {
      const nx=startX+dx, ny=startY+dy;
      if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { consistent=false; break; }
      const cell=st.grid[ny][nx];
      if (!cell || cell.type!==c.type || (cell.w||1)!==baseW || (cell.h||1)!==baseH) {
        consistent=false;
        break;
      }
    }
  }
  if (!consistent) return {startX:x,startY:y,w:1,h:1};

  return {startX:startX, startY:startY, w:baseW, h:baseH};
}

function isTopLeftCell(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false;
  const cell=st.grid[y][x];
  if (!cell) return false;
  const w=cell.w||1, h=cell.h||1;
  if (w===1 && h===1) return true;
  if (x>0) {
    const left=st.grid[y][x-1];
    if (left && left.type===cell.type && (left.w||1)===w && (left.h||1)===h) return false;
  }
  if (y>0) {
    const above=st.grid[y-1][x];
    if (above && above.type===cell.type && (above.w||1)===w && (above.h||1)===h) return false;
  }
  return true;
}

// Recompute buildingId metadata for all non-empty cells based on rectangular buildings
function rebuildBuildingIdsFromGrid() {
  nextBuildingId = 1;

  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (!cell) continue;
      if (cell.type === 'empty') {
        cell.buildingId = null;
      } else {
        cell.buildingId = undefined;
      }
    }
  }

  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (!cell || cell.type === 'empty') continue;
      if (!isTopLeftCell(x,y)) continue;

      const w = cell.w || 1;
      const h = cell.h || 1;
      const buildingId = nextBuildingId++;

      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx = x+dx;
          const ny = y+dy;
          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) continue;
          const target = st.grid[ny][nx];
          if (!target || target.type==='empty') continue;
          target.buildingId = buildingId;
        }
      }
    }
  }
}

function plcTl(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return; if (!st.selectedTool) return;
  const c=st.grid[y][x], tr=st.terrain[y][x];
  if (tr==='water'||tr==='cliff') { plySnd('error'); return; }
  if (st.selectedTool==='bulldoze') {
    if (c.type!=='empty') {
      plySnd('bulldoze');

      // Roads: always bulldoze a single tile only
      if (c.type==='road') {
        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
        normalizeEmptyCell(x,y);
        drGr(); sv();
        return;
      }

      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);
      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
      const isEmptyZone=isZone && (c.level===0 || c.abandoned);
      const isSmallMulti=(w===2 && h===1) || (w===1 && h===2) || (w===2 && h===2);

      // For empty zones: always bulldoze only the clicked cell
      // For small multi-tile buildings (not empty zones): bulldoze the entire building
      if (isEmptyZone) {
        // Empty zones: bulldoze only the clicked cell
        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
        normalizeEmptyCell(x,y);
      } else if (isSmallMulti) {
        // Small multi-tile buildings: bulldoze the entire building
        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
          const nx=startX+dx, ny=startY+dy; if (nx<GR_SZ && ny<GR_SZ) {
            st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
            normalizeEmptyCell(nx,ny);
          }
        }
      } else {
        // All other buildings: only bulldoze the clicked cell
        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
        normalizeEmptyCell(x,y);
      }

      drGr(); sv();
    }
    return;
  }
  const isPk=st.selectedTool.startsWith('park');
  
  // For parks: allow placing on empty zones (level 0 or abandoned zones)
  if (isPk) {
    const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
    const isEmptyZone=isZone && (c.level===0 || c.abandoned);
    if (c.type!=='empty' && !isEmptyZone) return;
    
    const cs=COSTS[st.selectedTool]||0; 
    if (st.money<cs) { plySnd('error'); return; }
    
    plySnd('place'); 
    st.money-=cs;
    
    // If replacing an empty zone, replace the entire building
    if (isEmptyZone) {
      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);
      // Replace all cells of the zone building with park
      const parkBuildingId = nextBuildingId++;
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=startX+dx, ny=startY+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            st.grid[ny][nx]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};
          }
        }
      }
      // Try to merge parks after placement (from the top-left)
      tryMrgPark(startX,startY);
    } else {
      // Normal placement on empty terrain
      const parkBuildingId = nextBuildingId++;
      st.grid[y][x]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};
      // Try to merge with adjacent parks of the same type
      tryMrgPark(x,y);
    }
  } else {
    // For non-park tools: only allow empty or abandoned
    if (c.type!=='empty' && !c.abandoned) return;
    const cs=COSTS[st.selectedTool]||0; 
    if (st.money<cs) { plySnd('error'); return; }
    plySnd('place'); 
    st.money-=cs;
    const buildingId = nextBuildingId++;
    st.grid[y][x]={type:st.selectedTool,age:0,level:0,w:1,h:1,buildingId:buildingId};
  }
  drGr(); updUI(); sv();
}

let isDragging = false, dragStart = null, lastPlaced = null, isScrolling = false, touchStartPos = null, lastTouchPos = null;

function getCarSpeedMultiplier() {
  if (st.speed<=0) return 0;
  if (st.speed===500) return 3;
  if (st.speed===1500) return 2;
  return 1;
}

const CAR_BASE_SPEED = 1.0;
const CAR_EDGE_OFFSET = CL_SZ/2 - 1;
const CAR_SNAP_THRESHOLD = 0.5;
const EMERGENCY_SPEED_MULTIPLIER = 1.2;

function getCarSpeedPerFrame(car) {
  const baseSpeed = CAR_BASE_SPEED * getCarSpeedMultiplier();
  // Police and fire cars move faster than normal cars
  if (car && (car.type === 'police' || car.type === 'fire')) {
    return baseSpeed * EMERGENCY_SPEED_MULTIPLIER;
  }
  return baseSpeed;
}

function updateCarLaneOffset(car) {
  if (car.pathIdx>=car.path.length-1) return;
  const curNode=car.path[car.pathIdx];
  const nextNode=car.path[car.pathIdx+1];
  const dxSeg=nextNode.x-curNode.x;
  const dySeg=nextNode.y-curNode.y;
    if (Math.abs(dxSeg)>Math.abs(dySeg)) {
      car.laneOffset=dxSeg>0 ? 5 : -5;
    } else {
      car.laneOffset=dySeg>0 ? -5 : 5;
    }
}

function getCarSegmentTarget(car) {
  const curNode=car.path[car.pathIdx];
  const nextNode=car.path[car.pathIdx+1];
  let tx=nextNode.x*CL_SZ+7;
  let ty=nextNode.y*CL_SZ+7;
  const dxSeg=nextNode.x-curNode.x;
  const dySeg=nextNode.y-curNode.y;
    const horizontal=Math.abs(dxSeg)>Math.abs(dySeg);
    if (horizontal) ty+=car.laneOffset;
    else tx+=car.laneOffset;
    
    const hasNextTurn=car.pathIdx+2<car.path.length;
    if (hasNextTurn) {
      const afterNode=car.path[car.pathIdx+2];
      const dxNext=afterNode.x-nextNode.x;
      const dyNext=afterNode.y-nextNode.y;
      const nextHorizontal=Math.abs(dxNext)>Math.abs(dyNext);
      if (horizontal && !nextHorizontal) {
        const nextLaneOffset=dyNext>0 ? -5 : 5;
        tx+=nextLaneOffset;
      } else if (!horizontal && nextHorizontal) {
        const nextLaneOffset=dxNext>0 ? 5 : -5;
        ty+=nextLaneOffset;
      }
    }
  return {tx,ty};
}

function getCanvasPos(e) {
  const r = cvs.getBoundingClientRect();
  const sx = cvs.width / r.width, sy = cvs.height / r.height;
  let clientX, clientY;
  
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
    lastTouchPos = { x: clientX, y: clientY };
  } else if (e.changedTouches && e.changedTouches.length > 0) {
    // For touchend events
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else if (lastTouchPos) {
    // Fallback to last known touch position
    clientX = lastTouchPos.x;
    clientY = lastTouchPos.y;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  
  const x = Math.floor((clientX - r.left) * sx / CL_SZ);
  const y = Math.floor((clientY - r.top) * sy / CL_SZ);
  return { x, y };
}

function placeLine(x0, y0, x1, y1) {
  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy, x = x0, y = y0;
  const placed = new Set();
  
  while (true) {
    const key = `${x},${y}`;
    if (!placed.has(key)) {
      placed.add(key);
      plcTl(x, y);
    }
    if (x === x1 && y === y1) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x += sx; }
    if (e2 < dx) { err += dx; y += sy; }
  }
}

let lastZoneBounds = null;

function placeZone(x0, y0, x1, y1) {
  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
  const currentBounds = `${minX},${minY},${maxX},${maxY}`;
  
  // Only place if bounds changed to avoid redundant work
  if (currentBounds === lastZoneBounds) return;
  lastZoneBounds = currentBounds;
  
  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      plcTl(x, y);
    }
  }
}

function handleDragStart(e) {
  // On mobile (touch events), allow scrolling and only handle taps
  if (e.touches) {
    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    isDragging = false;
    isScrolling = false;
    // Don't prevent default - allow native scrolling
    return;
  }
  
  // Desktop mouse behavior
  // Don't start drag if stats view is active
  if (!st.selectedTool || showLandValueOverlay || showCrimeOverlay) return;
  
  const pos = getCanvasPos(e);
  dragStart = pos;
  lastPlaced = { x: pos.x, y: pos.y };
  lastZoneBounds = null; // Reset zone bounds tracking
  isDragging = true;
  isScrolling = false;
}

function handleDragMove(e) {
  // On mobile (touch events), allow native scrolling - don't place tiles while dragging
  if (e.touches) {
    if (touchStartPos) {
      const dx = Math.abs(e.touches[0].clientX - touchStartPos.x);
      const dy = Math.abs(e.touches[0].clientY - touchStartPos.y);
      // If moved significantly, mark as scrolling (not a tap)
      if (dx > 5 || dy > 5) {
        isScrolling = true;
      }
    }
    // Don't prevent default - allow native scrolling
    return;
  }
  
  // Desktop mouse behavior
  // Don't drag if stats view is active
  if (!st.selectedTool || !isDragging || !dragStart || showLandValueOverlay || showCrimeOverlay) return;
  
  const pos = getCanvasPos(e);
  
  // For roads: place as line
  if (st.selectedTool === 'road') {
    placeLine(dragStart.x, dragStart.y, pos.x, pos.y);
    dragStart = pos; // Update start for continuous line
  }
  // For RCI zones: place as zone
  else if (st.selectedTool === 'residential' || st.selectedTool === 'commercial' || st.selectedTool === 'industrial') {
    placeZone(dragStart.x, dragStart.y, pos.x, pos.y);
  }
  // For other tools: place individual tiles
  else {
    const key = `${pos.x},${pos.y}`;
    const lastKey = `${lastPlaced.x},${lastPlaced.y}`;
    if (key !== lastKey) {
      plcTl(pos.x, pos.y);
      lastPlaced = pos;
    }
  }
}

function handleDragEnd(e) {
  // Handle mobile tap (touch without scrolling)
  if (e.changedTouches && touchStartPos && !isScrolling) {
    const pos = getCanvasPos(e);
    
    // If stat view is active, show building info instead of placing tool
    if (showLandValueOverlay || showCrimeOverlay) {
      showBuildingInfo(pos.x, pos.y);
    } else if (st.selectedTool) {
      // This was a tap, not a scroll - place a tile
      plcTl(pos.x, pos.y);
    }
  }
  // Handle desktop mouse drag end
  else if (isDragging && !isScrolling && dragStart && !e.touches) {
    const pos = getCanvasPos(e);
    // If we didn't move much (or at all), treat as click
    const moved = Math.abs(pos.x - dragStart.x) > 0 || Math.abs(pos.y - dragStart.y) > 0;
    if (!moved) {
      // If stat view is active, show building info instead of placing tool
      if (showLandValueOverlay || showCrimeOverlay) {
        showBuildingInfo(pos.x, pos.y);
      } else if (st.selectedTool) {
        plcTl(pos.x, pos.y);
      }
    }
  }
  
  isDragging = false;
  isScrolling = false;
  dragStart = null;
  lastPlaced = null;
  touchStartPos = null;
  lastTouchPos = null;
  lastZoneBounds = null;
}

// Mouse events
cvs.addEventListener('mousedown', handleDragStart);
cvs.addEventListener('mousemove', handleDragMove);
cvs.addEventListener('mouseup', handleDragEnd);
cvs.addEventListener('mouseleave', handleDragEnd);

// Touch events - passive for smooth scrolling on mobile
cvs.addEventListener('touchstart', handleDragStart, { passive: true });
cvs.addEventListener('touchmove', handleDragMove, { passive: true });
cvs.addEventListener('touchend', handleDragEnd, { passive: true });
cvs.addEventListener('touchcancel', handleDragEnd, { passive: true });

// Click handler for mouse only (touch events are handled separately)
cvs.addEventListener('click', e => {
  // Only handle mouse clicks, not touch-generated clicks
  if (e.detail === 0) return; // Touch events have detail = 0
  if (!isDragging && !isScrolling) {
    const r = cvs.getBoundingClientRect(), sx = cvs.width / r.width, sy = cvs.height / r.height;
    const x = Math.floor((e.clientX - r.left) * sx / CL_SZ), y = Math.floor((e.clientY - r.top) * sy / CL_SZ);
    
    // If stat view is active, show building info instead of placing tool
    if (showLandValueOverlay || showCrimeOverlay) {
      showBuildingInfo(x, y);
    } else if (st.selectedTool) {
      plcTl(x, y);
    }
  }
});

let activeSubmenu = null;

const submenuItems = {
  park: [
    { tool: 'park', icon: 'üå≥', tooltip: 'park', shortcut: '1' },
    { tool: 'park2', icon: 'üå∏', tooltip: 'park', shortcut: '2' },
    { tool: 'park3', icon: 'üå≤', tooltip: 'park', shortcut: '3' },
    { tool: 'park4', icon: 'üåª', tooltip: 'park', shortcut: '4' }
  ],
  disaster: [
    { disaster: 'fire', icon: 'üî•', tooltip: 'fire', shortcut: '1' },
    { disaster: 'crime', icon: 'üö®', tooltip: 'crime', shortcut: '2' },
    { disaster: 'earthquake', icon: 'üåç', tooltip: 'earthquake', shortcut: '3' }
  ]
};

function openSubmenu(button, submenuKey) {
  // Close any existing submenu
  closeSubmenu();
  
  // Store reference to the button
  activeSubmenu = { button, submenuKey };
  
  // Change button to X
  const originalContent = button.innerHTML;
  button.dataset.originalContent = originalContent;
  button.innerHTML = '‚úï';
  button.classList.add('submenu-active');
  
  // Get sub-toolbar
  const subToolbar = document.getElementById('subToolbar');
  
  // Populate sub-toolbar with items (but keep hidden for now)
  subToolbar.innerHTML = '';
  const items = submenuItems[submenuKey];
  items.forEach(item => {
    const subBtn = document.createElement('button');
    subBtn.className = 'tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center';
    if (item.tool) {
      subBtn.dataset.tool = item.tool;
    }
    if (item.disaster) {
      subBtn.dataset.disaster = item.disaster;
    }
    if (item.tooltip) {
      subBtn.dataset.tooltip = item.tooltip;
      if (item.shortcut) {
        subBtn.dataset.shortcut = item.shortcut;
      }
      subBtn.addEventListener('mouseenter', () => {
        showTooltip(subBtn, item.tooltip);
      });
      subBtn.addEventListener('mouseleave', () => {
        hideTooltip();
      });
    }
    subBtn.textContent = item.icon;
    subBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      plySnd('click');
      if (item.tool) {
        selTl(item.tool);
        // Don't close submenu - keep it open so user can switch tools
      } else if (item.disaster) {
        // Trigger disaster and close submenu
        if (item.disaster === 'fire') {
          startFire();
        } else if (item.disaster === 'crime') {
          startCrimeEvent();
        } else if (item.disaster === 'earthquake') {
          startQuake();
        }
        closeSubmenu();
      }
    });
    subToolbar.appendChild(subBtn);
  });
  
  // Auto-select the first tool in the submenu (only for tools, not disasters)
  if (items.length > 0 && items[0].tool) {
    selTl(items[0].tool);
  }
  
  // Make submenu invisible but rendered to measure it
  subToolbar.style.visibility = 'hidden';
  subToolbar.classList.remove('hidden');
  
  // Position submenu vertically centered on the toggle button
  requestAnimationFrame(() => {
    const parentContainer = button.closest('.flex.flex-shrink-0.relative');
    const parentRect = parentContainer.getBoundingClientRect();
    const buttonRect = button.getBoundingClientRect();
    const subToolbarRect = subToolbar.getBoundingClientRect();
    
    // Calculate positions relative to parent container
    const buttonTopRelative = buttonRect.top - parentRect.top;
    const buttonCenterY = buttonTopRelative + buttonRect.height / 2;
    const submenuHeight = subToolbarRect.height;
    const submenuCenterY = submenuHeight / 2;
    
    // Calculate top position to center submenu on button
    const topPosition = buttonCenterY - submenuCenterY;
    subToolbar.style.top = `${topPosition}px`;
    
    // Now make it visible
    subToolbar.style.visibility = '';
    
    updateToolSelection();
  });
}

function closeSubmenu() {
  if (activeSubmenu) {
    // Restore original button content
    if (activeSubmenu.button.dataset.originalContent) {
      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;
      activeSubmenu.button.classList.remove('submenu-active');
    }
    activeSubmenu = null;
  }
  
  // Hide sub-toolbar and reset position
  const subToolbar = document.getElementById('subToolbar');
  subToolbar.classList.add('hidden');
  subToolbar.style.top = '';
  subToolbar.style.visibility = '';
}

function updateToolSelection() {
  // Update all tool buttons including sub-toolbar buttons
  document.querySelectorAll('.tool-btn').forEach(b => {
    const bt = b.dataset.tool;
    b.style.borderColor = '';
    b.style.opacity = '';
    if (bt === st.selectedTool) {
      b.style.borderColor = '#666';
      b.style.opacity = '1';
    } else {
      // All other unselected buttons get reduced opacity (including submenu toggle showing X and disaster buttons)
      b.style.opacity = '0.5';
    }
  });
}

// Create tooltip element
let tooltipEl = null;
function createTooltip() {
  if (!tooltipEl) {
    tooltipEl = document.createElement('div');
    tooltipEl.className = 'tooltip';
    document.body.appendChild(tooltipEl);
  }
  return tooltipEl;
}

function showTooltip(button, text) {
  // Only show on devices that support hover
  if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {
    const tooltip = createTooltip();
    const shortcut = button.dataset.shortcut;
    if (shortcut) {
      tooltip.innerHTML = `${text}<span class="tooltip-shortcut">${shortcut}</span>`;
    } else {
      tooltip.textContent = text;
    }
    tooltip.classList.add('show');
    
    const rect = button.getBoundingClientRect();
    tooltip.style.left = `${rect.left - tooltip.offsetWidth - 8}px`;
    tooltip.style.top = `${rect.top + rect.height / 2}px`;
    tooltip.style.transform = 'translateY(-50%)';
    
    // Recalculate position after tooltip is rendered
    setTimeout(() => {
      const tooltipRect = tooltip.getBoundingClientRect();
      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;
    }, 0);
  }
}

function hideTooltip() {
  if (tooltipEl) {
    tooltipEl.classList.remove('show');
  }
}

// Keyboard shortcut mapping
const keyToTool = {
  'r': 'road',
  'R': 'road',
  'h': 'residential',
  'H': 'residential',
  'c': 'commercial',
  'C': 'commercial',
  'i': 'industrial',
  'I': 'industrial',
  'p': 'park',
  'P': 'park',
  'o': 'police',
  'O': 'police',
  'f': 'fire',
  'F': 'fire',
  's': 'school',
  'S': 'school',
  't': 'hospital',
  'T': 'hospital',
  'd': 'bulldoze',
  'D': 'bulldoze',
  'w': 'disaster',
  'W': 'disaster'
};

function triggerToolByKey(key) {
  const tool = keyToTool[key];
  if (!tool) return false;
  
  // Find the button for this tool
  if (tool === 'disaster') {
    const disasterBtn = document.querySelector('[data-submenu="disaster"]');
    if (disasterBtn && st.disastersEnabled) {
      if (activeSubmenu && activeSubmenu.button === disasterBtn) {
        closeSubmenu();
      } else {
        openSubmenu(disasterBtn, 'disaster');
      }
      return true;
    }
  } else if (tool === 'park') {
    const parkBtn = document.querySelector('[data-submenu="park"]');
    if (parkBtn) {
      if (activeSubmenu && activeSubmenu.button === parkBtn) {
        closeSubmenu();
      } else {
        openSubmenu(parkBtn, 'park');
      }
      return true;
    }
  } else {
    const toolBtn = document.querySelector(`[data-tool="${tool}"]`);
    if (toolBtn) {
      toolBtn.click();
      return true;
    }
  }
  return false;
}

// Handle submenu shortcuts when submenu is open
function handleSubmenuShortcut(key) {
  if (!activeSubmenu) return false;
  
  if (activeSubmenu.submenuKey === 'disaster') {
    const shortcuts = { '1': 'fire', '2': 'crime', '3': 'earthquake' };
    const disaster = shortcuts[key];
    if (disaster) {
      const subBtn = document.querySelector(`[data-disaster="${disaster}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  } else if (activeSubmenu.submenuKey === 'park') {
    const shortcuts = { '1': 'park', '2': 'park2', '3': 'park3', '4': 'park4' };
    const parkTool = shortcuts[key];
    if (parkTool) {
      const subBtn = document.querySelector(`[data-tool="${parkTool}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  }
  return false;
}

function setSpeedByNumber(num) {
  plySnd('click');
  if (num === 0) {
    st.speed = 0;
  } else if (num === 1) {
    st.speed = 3000;
  } else if (num === 2) {
    st.speed = 1500;
  } else if (num === 3) {
    st.speed = 500;
  }
  sv();
  if (tkTmr) clearInterval(tkTmr);
  if (st.speed > 0) {
    TK_INT = st.speed;
    tkTmr = setInterval(simTk, TK_INT);
    updNwsTk();
  } else {
    updNwsTk();
  }
  updUI();
}

document.addEventListener('keydown', (e) => {
  // Don't trigger if user is typing in an input field
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
    return;
  }
  
  // Handle speed controls (0-3) only if no submenu is open
  if (!activeSubmenu && (e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3')) {
    const num = parseInt(e.key);
    setSpeedByNumber(num);
    e.preventDefault();
    return;
  }
  
  // Handle submenu shortcuts when submenu is open
  if (handleSubmenuShortcut(e.key)) {
    e.preventDefault();
    return;
  }
  
  // Handle main tool shortcuts
  if (triggerToolByKey(e.key)) {
    e.preventDefault();
  }
});

document.querySelectorAll('.tool-btn').forEach(b => {
  const tooltipText = b.dataset.tooltip;
  if (tooltipText) {
    b.addEventListener('mouseenter', () => {
      showTooltip(b, tooltipText);
    });
    b.addEventListener('mouseleave', () => {
      hideTooltip();
    });
  }
  
  b.addEventListener('click', (e) => {
    plySnd('click');
    hideTooltip();
    
    // Check if this button has a submenu
    if (b.dataset.submenu) {
      // If submenu is already open, close it
      if (activeSubmenu && activeSubmenu.button === b) {
        closeSubmenu();
      } else {
        // Open submenu
        openSubmenu(b, b.dataset.submenu);
      }
    } else if (b.dataset.tool) {
      // Regular tool selection
      selTl(b.dataset.tool);
      closeSubmenu();
    }
  });
});

function updateDisasterButtonsVisibility() {
  const disasterButtons = document.querySelectorAll('.disaster-btn');
  disasterButtons.forEach(btn => {
    btn.style.display = st.disastersEnabled ? 'flex' : 'none';
  });
}

function centerCanvas() {
  const gridContainer = document.getElementById('grid');
  if (!gridContainer) return;
  
  // Wait for next frame to ensure layout is calculated
  requestAnimationFrame(() => {
    const zoom = st.zoom || 1;
    const canvasWidth = cvs.width * zoom;
    const canvasHeight = cvs.height * zoom;
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // If canvas is smaller than container, center it with CSS
    if (canvasWidth <= containerWidth && canvasHeight <= containerHeight) {
      // Center using flexbox or margin auto
      gridContainer.style.display = 'flex';
      gridContainer.style.justifyContent = 'center';
      gridContainer.style.alignItems = 'center';
      gridContainer.scrollLeft = 0;
      gridContainer.scrollTop = 0;
    } else {
      // Canvas is larger, use scroll positioning
      gridContainer.style.display = 'block';
      gridContainer.style.justifyContent = '';
      gridContainer.style.alignItems = '';
      
      // Calculate scroll position to center the canvas
      const scrollLeft = Math.max(0, (canvasWidth - containerWidth) / 2);
      const scrollTop = Math.max(0, (canvasHeight - containerHeight) / 2);
      
      gridContainer.scrollLeft = scrollLeft;
      gridContainer.scrollTop = scrollTop;
    }
  });
}

function applyZoom() {
  if (!st.zoom) st.zoom = 1;
  cvs.style.transform = `scale(${st.zoom})`;
  cvs.style.transformOrigin = 'top left';
  document.getElementById('zoomLevel').textContent = Math.round(st.zoom * 100) + '%';
  sv();
  centerCanvas();
}

function zoomIn() {
  if (!st.zoom) st.zoom = 1;
  st.zoom = Math.min(3, st.zoom + 0.25);
  applyZoom();
}

function zoomOut() {
  if (!st.zoom) st.zoom = 1;
  st.zoom = Math.max(0.25, st.zoom - 0.25);
  applyZoom();
}

function zoomReset() {
  st.zoom = 1;
  applyZoom();
}

document.getElementById('zoomInBtn').addEventListener('click', () => { plySnd('click'); zoomIn(); });
document.getElementById('zoomOutBtn').addEventListener('click', () => { plySnd('click'); zoomOut(); });

const inpNm=document.getElementById('cityName');
inpNm.addEventListener('focus', () => edtNm=true);
inpNm.addEventListener('blur', () => { edtNm=false; st.cityName=inpNm.value||'new city'; sv(); updUI(); });
inpNm.addEventListener('input', () => updInpWd());
inpNm.addEventListener('change', e => { st.cityName=e.target.value||'new city'; sv(); });
inpNm.addEventListener('click', e => e.target.select());

document.getElementById('menuBtn').addEventListener('click', () => {
  plySnd('click'); const m=document.getElementById('menu'); m.classList.toggle('hidden');
  document.getElementById('newGamePanel').classList.add('hidden'); 
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
});

document.getElementById('speedToggle').addEventListener('click', () => {
  plySnd('click');
  if (st.speed===0) st.speed=3000; else if (st.speed===3000) st.speed=1500; else if (st.speed===1500) st.speed=500; else st.speed=0;
  sv(); if (tkTmr) clearInterval(tkTmr);
  if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); updNwsTk(); }
  else updNwsTk();
  updUI();
});

document.getElementById('newCityBtn').addEventListener('click', () => { 
  plySnd('click'); 
  document.getElementById('newCityName').value = '';
  document.getElementById('menu').classList.add('hidden'); 
  document.getElementById('newGamePanel').classList.remove('hidden'); 
});

document.getElementById('startGameBtn').addEventListener('click', () => {
  plySnd('click');
  const nm=document.getElementById('newCityName').value||'new city', tr=document.getElementById('terrainType').value, df=document.getElementById('difficulty').value;
  let mn=50000; if (df==='easy') mn=100000; else if (df==='hard') mn=20000;
  aiReq=false; initGr(tr); st.money=mn; st.population=0; st.happiness=70; st.tickCount=0; st.cityName=nm; st.rDemand=50; st.cDemand=50; st.iDemand=50; st.year=1990; st.newsEvents=['Welcome to '+nm+'!']; st.ticksSinceNews=0; st.employment=0;
  if (!st.zoom) st.zoom=1;
  drGr(); updUI(); updNwsTk(); sv();
  document.getElementById('newGamePanel').classList.add('hidden');
  document.getElementById('aiPanel').classList.add('hidden');
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
  setTimeout(centerCanvas, 100);
});

document.getElementById('aiSuggestBtn').addEventListener('click', async () => {
  plySnd('click'); document.getElementById('menu').classList.add('hidden'); document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
  const pnl=document.getElementById('aiPanel'), msg=document.getElementById('aiMessage');
  pnl.classList.remove('hidden'); msg.innerHTML='<span class="text-neutral-500">thinking...</span>';
  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);
  const prm=`You are an AI mayor advisor for a SimCity-like game. Analyze the current city state and give 2-3 SHORT, actionable suggestions (1-2 sentences total).\n\nCurrent city stats:\n- Money: $${st.money.toLocaleString()}\n- Population: ${st.population}\n- Happiness: ${st.happiness}/100\n- Buildings: ${JSON.stringify(cnts)}\n- RCI Demand: R=${st.rDemand}% C=${st.cDemand}% I=${st.iDemand}%\n\nAvailable building types: road, residential, commercial, industrial, park, police, fire, school, hospital\n\nGive practical advice based on what's missing or unbalanced. Keep it brief and conversational.`;
  try {
    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});
    if (!r.ok) throw new Error('AI request failed');
    const d=await r.json(), rp=d.reply||'everything looks good!';
    msg.textContent=''; let i=0;
    const tw=setInterval(() => { if (i<rp.length) { msg.textContent+=rp.charAt(i); i++; } else clearInterval(tw); },20);
  } catch(e) { console.error('AI error:',e); msg.textContent='could not reach AI mayor. try building more infrastructure!'; }
});

document.getElementById('closeAiBtn').addEventListener('click', () => { plySnd('click'); document.getElementById('aiPanel').classList.add('hidden'); });
document.getElementById('closeInfoBtn').addEventListener('click', () => {
  plySnd('click');
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
});

function statItem(label, value, colorClass = '') {
  return `<div class="flex flex-col flex-shrink-0"><div class="text-xs text-neutral-400">${label}</div><div class="${colorClass}">${value}</div></div>`;
}

function getStatsContent(infoType) {
  const cnts = {};
  st.grid.flat().forEach(c => cnts[c.type] = (cnts[c.type] || 0) + 1);
  const getCount = type => cnts[type] || 0;
  
  let content = '';
  let title = '';
  
  if (infoType === 'rci') {
    title = 'RCI Demand';
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('residential', `${st.rDemand}%`, 'text-green-500')}${statItem('commercial', `${st.cDemand}%`, 'text-blue-500')}${statItem('industrial', `${st.iDemand}%`, 'text-yellow-500')}</div><div class="mt-3 text-xs text-neutral-400">Higher demand means more zones needed</div>`;
  } else if (infoType === 'pop') {
    title = 'Population Stats';
    const bPR=10; let popL1=0, popL2=0, popL3=0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x];
      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
        const sM=(c.w||1)*(c.h||1);
        if (c.level===3) popL3+=Math.floor(bPR*sM*1.5);
        else if (c.level===2) popL2+=Math.floor(bPR*sM*1.2);
        else if (c.level>=1) popL1+=Math.floor(bPR*sM*1);
      }
    }
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('total', st.population.toLocaleString())}${statItem('zones', cnts.residential||0)}${statItem('employment', `${st.employment}%`)}${statItem('L1', popL1.toLocaleString())}${statItem('L2', popL2.toLocaleString())}${statItem('L3', popL3.toLocaleString())}</div><div class="mt-3 text-xs text-neutral-400">Build more residential zones to grow, levels upgrade with parks, services, and education</div>`;
  } else if (infoType === 'money') {
    title = 'Budget';
    const inc = Math.floor(st.population * 2);
    const mnt = Math.floor(
      getCount('road') * 1 +
      getCount('residential') * 2 +
      getCount('commercial') * 3 +
      getCount('industrial') * 5 +
      getCount('park') * 2 +
      getCount('police') * 10 +
      getCount('fire') * 10 +
      getCount('school') * 15 +
      getCount('hospital') * 20
    );
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('balance', `$${st.money.toLocaleString()}`)}${statItem('income', `+$${inc}`, 'text-green-500')}${statItem('expenses', `-$${mnt}`, 'text-red-400')}</div><div class="mt-3 text-xs text-neutral-400">Income from population taxes</div>`;
  } else if (infoType === 'happy') {
    title = 'Happiness';
    let avgCrime = 0;
    for (let y = 0; y < GR_SZ; y++) {
      for (let x = 0; x < GR_SZ; x++) {
        avgCrime += st.crime[y][x] || 30;
      }
    }
    avgCrime = Math.floor(avgCrime / (GR_SZ * GR_SZ));
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('level', `${st.happiness}/100`)}${statItem('parks', cnts.park||0)}${statItem('services', (cnts.police||0)+(cnts.fire||0)+(cnts.school||0)+(cnts.hospital||0))}${statItem('crime', `${avgCrime}%`)}${statItem('crimes', st.crimeEvents.length)}</div><div class="mt-3 text-xs text-neutral-400">Build parks, services, and police to increase</div>`;
  }
  
  return { title, content };
}

document.getElementById('rciBtn').addEventListener('click', () => {
  const { title, content } = getStatsContent('rci');
  shwInfo(title, content, 'rci');
});

document.getElementById('popBtn').addEventListener('click', () => {
  const { title, content } = getStatsContent('pop');
  shwInfo(title, content, 'pop');
});

document.getElementById('moneyBtn').addEventListener('click', () => {
  const { title, content } = getStatsContent('money');
  shwInfo(title, content, 'money');
});

document.getElementById('happyBtn').addEventListener('click', () => {
  const { title, content } = getStatsContent('happy');
  shwInfo(title, content, 'happy');
});

function updateStatsPanel() {
  if (!currentInfoType) return;
  const pnl = document.getElementById('infoPanel');
  if (!pnl || pnl.classList.contains('hidden')) return;
  
  const { title, content } = getStatsContent(currentInfoType);
  
  if (title && content) {
    document.getElementById('infoTitle').textContent = title;
    document.getElementById('infoContent').innerHTML = content;
  }
}

function hasRdAcc(x,y) {
  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;
  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
    const cx=x+dx, cy=y+dy;
    for (let ndy=-1; ndy<=1; ndy++) for (let ndx=-1; ndx<=1; ndx++) {
      if (ndx===0 && ndy===0) continue;
      const nx=cx+ndx, ny=cy+ndy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='road') return true;
    }
  }
  return false;
}

function hasSchoolCoverage(x,y) {
  // Check if building at (x,y) is within a school's bounds (8-tile radius)
  const w=st.grid[y][x].w||1, h=st.grid[y][x].h||1;
  // Check each cell of the building
  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
    const cx=x+dx, cy=y+dy;
    // Check for schools within 8-tile radius
    for (let sdy=-8; sdy<=8; sdy++) for (let sdx=-8; sdx<=8; sdx++) {
      const nx=cx+sdx, ny=cy+sdy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
        const d=Math.abs(sdx)+Math.abs(sdy);
        if (d<=8 && st.grid[ny][nx].type==='school') {
          return true;
        }
      }
    }
  }
  return false;
}

function calcLV(x,y) {
  let v=50; const tr=st.terrain[y][x];
  if (tr==='water') for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) { const d=Math.abs(dx)+Math.abs(dy); if (d<=2) v+=(3-d)*5; }
  }
  let pk=0, pl=0, sv=0;
  for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
      const d=Math.abs(dx)+Math.abs(dy), c=st.grid[ny][nx];
      if (c.type.startsWith('park')) { const m=(c.w||1)*(c.h||1); const sizeBoost=m>1?1.5:1; pk+=(7-d)*2*m*sizeBoost; }
      else if (c.type==='industrial') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*2*m; }
      else if (c.type==='police'||c.type==='fire'||c.type==='school'||c.type==='hospital') sv+=(7-d);
    }
  }
  v+=Math.min(pk,30); v-=Math.min(pl,40); v+=Math.min(sv,20);
  if (!hasRdAcc(x,y)) v-=30;
  return Math.max(0,Math.min(100,v));
}

function calcCrime(x,y) {
  let c=30; const tr=st.terrain[y][x];
  if (tr==='water'||tr==='cliff') return 0;
  
  // Reduce crime near police stations (8-tile radius)
  let policeCoverage=0;
  for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
      const d=Math.abs(dx)+Math.abs(dy), cell=st.grid[ny][nx];
      if (cell.type==='police' && d<=8) {
        policeCoverage+=(9-d)*3;
      }
    }
  }
  c-=Math.min(policeCoverage,50);
  
  // Increase crime in high-population areas without police coverage
  const cell=st.grid[y][x];
  if ((cell.type==='residential'||cell.type==='commercial') && !cell.abandoned) {
    const popDensity=(cell.w||1)*(cell.h||1)*(cell.level||0);
    if (policeCoverage<10) c+=popDensity*5;
  }
  
  // Factor in happiness (low happiness = more crime)
  if (st.happiness<50) c+=20;
  else if (st.happiness<70) c+=10;
  
  // Increase crime if no road access
  if (!hasRdAcc(x,y)) c+=15;
  
  // Check for active crime events nearby
  for (const evt of st.crimeEvents) {
    const dx=Math.abs(x-evt.x), dy=Math.abs(y-evt.y), d=dx+dy;
    if (d<=3) c+=Math.max(0,(4-d)*10);
  }
  
  return Math.max(0,Math.min(100,c));
}

function updLV() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.landValue[y][x]=calcLV(x,y); }
function updCrime() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.crime[y][x]=calcCrime(x,y); }

function calcDmd(rC,cC,iC,p) {
  let rD=50, cD=50, iD=50; const tZ=rC+cC+iC;
  if (tZ===0) { rD=80; cD=40; iD=40; }
  else {
    const iR={r:0.5,c:0.25,i:0.25}, aR={r:rC/tZ,c:cC/tZ,i:iC/tZ};
    rD=Math.max(0,Math.min(100,50+(iR.r-aR.r)*200)); cD=Math.max(0,Math.min(100,50+(iR.c-aR.c)*200)); iD=Math.max(0,Math.min(100,50+(iR.i-aR.i)*200));
    if (p>0) { const jA=cC*5+iC*8, jN=p*0.6; if (jA<jN) { cD=Math.min(100,cD+20); iD=Math.min(100,iD+20); } }
    if (st.happiness<50) rD=Math.max(0,rD-20); else if (st.happiness>80) rD=Math.min(100,rD+10);
  }
  return {rDemand:rD,cDemand:cD,iDemand:iD};
}

async function genNws() {
  if (aiReq) return; aiReq=true;
  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);
  const ctx=`${st.cityName}, ${st.year}, pop ${st.population}, $${(st.money/1000).toFixed(0)}k, happiness ${st.happiness}, ${cnts.residential||0}R ${cnts.commercial||0}C ${cnts.industrial||0}I`;
  const prm=`Generate ONE dramatic news headline (8 words max) for SimCity game. Context: ${ctx}. Topics: politics, pop culture, tech, disasters, economy, society. Include brief stat at end like (+200 pop) or (-$2k) or (+5 joy). Be punchy and dramatic. Return ONLY headline.`;
  try {
    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});
    if (!r.ok) throw new Error('AI request failed');
    const d=await r.json(); let ev=d.reply||'City continues to grow';
    ev=ev.replace(/^["']|["']$/g,'').trim();
    const m=ev.match(/\(([^)]+)\)/);
    if (m) {
      const ch=m[1];
      if (ch.includes('pop')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0); st.population=Math.max(0,st.population+vl); }
      else if (ch.includes('$')||ch.includes('k')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0), mt=ch.includes('k')?1000:1; st.money+=vl*mt; }
      else if (ch.includes('joy')||ch.includes('happiness')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0); st.happiness=Math.max(0,Math.min(100,st.happiness+vl)); }
    }
    st.newsEvents.push(ev); if (st.newsEvents.length>10) st.newsEvents.shift();
    nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();
  } catch(e) { console.error('News generation error:',e); } finally { aiReq=false; }
}

function tryMrgPark(x,y) {
  const c=st.grid[y][x]; if (!c||!c.type.startsWith('park')) return false;
  if (!isTopLeftCell(x,y)) return false;
  
  // Try to merge 2x1 tiles into 2x2
  if (c.w===2&&c.h===1) {
    // Check if there's a 2x1 tile directly above or below
    const checkAbove=y>0 && x+1<GR_SZ;
    const checkBelow=y+1<GR_SZ && x+1<GR_SZ;
    
    if (checkAbove) {
      const above=st.grid[y-1][x];
      if (above.type===c.type&&above.w===2&&above.h===1 && y-1>=0 && x+1<GR_SZ && st.grid[y-1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y-1>=0 && y<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y-1+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
    
    if (checkBelow) {
      const below=st.grid[y+1][x];
      if (below.type===c.type&&below.w===2&&below.h===1 && y+1<GR_SZ && x+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
  }
  
  // Try to merge 1x2 tiles into 2x2
  if (c.w===1&&c.h===2) {
    // Check if there's a 1x2 tile directly left or right
    const checkLeft=x>0 && y+1<GR_SZ;
    const checkRight=x+1<GR_SZ && y+1<GR_SZ;
    
    if (checkLeft) {
      const left=st.grid[y][x-1];
      if (left.type===c.type&&left.w===1&&left.h===2 && x-1>=0 && y+1<GR_SZ && st.grid[y+1][x-1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x-1>=0 && x<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x-1+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
    
    if (checkRight) {
      const right=st.grid[y][x+1];
      if (right.type===c.type&&right.w===1&&right.h===2 && x+1<GR_SZ && y+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
  }
  
  // Original logic: merge 1x1 tiles
  if (c.w!==1||c.h!==1) return false;
  
  // Try to merge with adjacent parks of the same type
  const dirs=[{dx:0,dy:0,w:2,h:2},{dx:-1,dy:0,w:2,h:1},{dx:0,dy:-1,w:1,h:2},{dx:-1,dy:-1,w:2,h:2},{dx:0,dy:0,w:2,h:1},{dx:0,dy:0,w:1,h:2}];
  for (const d of dirs) {
    const sx=x+d.dx, sy=y+d.dy;
    if (sx<0||sy<0||sx+d.w>GR_SZ||sy+d.h>GR_SZ) continue;
    
    // Check if all cells in the area are the same park type and 1x1
    let canMerge=true;
    for (let dy=0; dy<d.h; dy++) for (let dx=0; dx<d.w; dx++) {
      const nx=sx+dx, ny=sy+dy, nb=st.grid[ny][nx];
      if (nb.type!==c.type||nb.w!==1||nb.h!==1) { canMerge=false; break; }
    }
    
    if (canMerge) {
      // Merge the parks - ensure all cells are within bounds
      const buildingId = nextBuildingId++;
      for (let dy=0; dy<d.h; dy++) {
        for (let dx=0; dx<d.w; dx++) {
          const nx=sx+dx, ny=sy+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:d.w,h:d.h,buildingId:buildingId};
          }
        }
      }
      return true;
    }
  }
  return false;
}

// First step: merge 1x1 buildings to 2x1 or 1x2
function tryMrgTo2x1(x,y) {
  const c=st.grid[y][x]; if (!c) return false;
  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;
  
  // Only merge mature 1x1 buildings
  const w=c.w||1, h=c.h||1;
  if (w!==1 || h!==1) return false;
  if (c.level<=0 || c.abandoned) return false;
  
  const targets=[
    {dx:1, dy:0, w:2, h:1}, // Merge to the right (2x1)
    {dx:0, dy:1, w:1, h:2}  // Merge downward (1x2)
  ];
  
  for (const target of targets) {
    const adjX=x+target.dx, adjY=y+target.dy;
    if (adjX<0||adjX>=GR_SZ||adjY<0||adjY>=GR_SZ) continue;
    const adj=st.grid[adjY][adjX];
    if (!adj) continue;
    if (adj.type!==c.type) continue;
    if ((adj.w||1)!==1 || (adj.h||1)!==1) continue;
    
    const adjLevel=adj.level||0;
    if (adjLevel<=0 && !adj.abandoned) continue; // keep level-0 zones 1x1
    
    const topLeftX=Math.min(x,adjX);
    const topLeftY=Math.min(y,adjY);
    const bestAge=Math.max(c.age||0,adj.age||0);
    const bestLevel=Math.max(1,Math.min(c.level||1,adj.level||c.level||1));
    const isAbandoned=c.abandoned && adj.abandoned;
    
    const buildingId = nextBuildingId++;
    for (let dy=0; dy<target.h; dy++) {
      for (let dx=0; dx<target.w; dx++) {
        const nx=topLeftX+dx, ny=topLeftY+dy;
        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
          st.grid[ny][nx]={type:c.type,age:bestAge,level:bestLevel,w:target.w,h:target.h,abandoned:isAbandoned,buildingId:buildingId};
        }
      }
    }
    return true;
  }
  
  return false;
}

function tryMrg(x,y) {
  const c=st.grid[y][x]; if (!c) return false;
  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;
  
  // Only merge buildings that are 1x2 or 2x1 (not 1x1 - those merge first)
  const w=c.w||1, h=c.h||1;
  if (!((w===1&&h===2) || (w===2&&h===1))) return false;
  if (!isTopLeftCell(x,y)) return false;
  if (c.level<=0 || c.abandoned) return false;
  
  const baseLevel=Math.max(1,c.level||1);
  const baseAge=c.age||0;
  const expansions=[];
  
  if (w===2 && h===1) {
    if (y>0) expansions.push({topLeftX:x, topLeftY:y-1, fillCells:[{x:x,y:y-1},{x:x+1,y:y-1}]});
    if (y+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x,y:y+1},{x:x+1,y:y+1}]});
  } else if (w===1 && h===2) {
    if (x>0) expansions.push({topLeftX:x-1, topLeftY:y, fillCells:[{x:x-1,y:y},{x:x-1,y:y+1}]});
    if (x+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x+1,y:y},{x:x+1,y:y+1}]});
  }
  
  for (const option of expansions) {
    const {topLeftX, topLeftY, fillCells}=option;
    if (topLeftX<0 || topLeftY<0 || topLeftX+1>=GR_SZ || topLeftY+1>=GR_SZ) continue;
    
    let canExpand=true;
    let mergedAge=baseAge;
    for (const pos of fillCells) {
      if (pos.x<0 || pos.x>=GR_SZ || pos.y<0 || pos.y>=GR_SZ) { canExpand=false; break; }
      const target=st.grid[pos.y][pos.x];
      if (!target) { canExpand=false; break; }
      if (target.type!==c.type) { canExpand=false; break; }
      if ((target.w||1)!==1 || (target.h||1)!==1) { canExpand=false; break; }
      const targetLevel=target.level||0;
      if (targetLevel>0 && !target.abandoned) { canExpand=false; break; }
      mergedAge=Math.max(mergedAge,target.age||0);
    }
    
    if (!canExpand) continue;
    
    const buildingId = nextBuildingId++;
    for (let dy=0; dy<2; dy++) {
      for (let dx=0; dx<2; dx++) {
        const nx=topLeftX+dx, ny=topLeftY+dy;
        st.grid[ny][nx]={type:c.type,age:mergedAge,level:baseLevel,w:2,h:2,abandoned:false,buildingId:buildingId};
      }
    }
    return true;
  }
  
  return false;
}

function updFires() {
  st.fires=st.fires.filter(f => {
    f.age++;
    
    // Count fire trucks at scene (from vehicles that have arrived)
    const trucksAtScene = st.cars.filter(c => 
      c.mission && 
      c.mission.type === 'fire' && 
      c.mission.arrived && 
      c.mission.targetX === f.x && 
      c.mission.targetY === f.y
    ).length;
    
    // Fires REQUIRE fire trucks to be extinguished - they won't go out on their own
    // With trucks: extinguish faster (10 ticks per truck, min 5 ticks)
    // Without trucks: fire continues indefinitely (but building will eventually be destroyed)
    if (trucksAtScene === 0) {
      // No fire trucks - fire continues burning
      // After 60 ticks without trucks, building is destroyed anyway
      if (f.age > 60) {
        sendEmergencyVehiclesHome('fire', f.x, f.y);
        
        const cell=st.grid[f.y][f.x];
        if (cell && cell.type!=='empty') {
          const bounds=getBuildingBoundsFromCell(f.x,f.y);
          const w=bounds.w||1, h=bounds.h||1;
          for (let dy=0; dy<h; dy++) {
            for (let dx=0; dx<w; dx++) {
              const nx=bounds.startX+dx, ny=bounds.startY+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
                normalizeEmptyCell(nx,ny);
              }
            }
          }
        }
        return false; // Remove fire after building destroyed
      }
      return true; // Keep fire burning
    }
    
    // Fire trucks are at scene - extinguish fire
    // Extinguish faster with more trucks: 10 ticks per truck (min 5 ticks)
    const maxAge = Math.max(5, 30 - trucksAtScene * 10);
    
    if (f.age>maxAge) { 
      sendEmergencyVehiclesHome('fire', f.x, f.y);
      
      const cell=st.grid[f.y][f.x];
      if (cell && cell.type!=='empty') {
        const bounds=getBuildingBoundsFromCell(f.x,f.y);
        const w=bounds.w||1, h=bounds.h||1;
        for (let dy=0; dy<h; dy++) {
          for (let dx=0; dx<w; dx++) {
            const nx=bounds.startX+dx, ny=bounds.startY+dy;
            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
              normalizeEmptyCell(nx,ny); // Ensure it's 1x1
            }
          }
        }
      }
      return false; 
    }
    const c=st.grid[f.y][f.x]; if (c.type==='empty') return false;
    let hasFr=false; for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {
      const nx=f.x+dx, ny=f.y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='fire') hasFr=true;
    }
    // With fire trucks, fires can be extinguished earlier
    const minAgeForSpread = trucksAtScene > 0 ? 5 : 10;
    if (hasFr && f.age>minAgeForSpread) return false; return true;
  });
}

function startFire() {
  const blds=[]; for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x]; if ((c.type==='residential'||c.type==='commercial'||c.type==='industrial') && !c.abandoned) blds.push({x,y});
  }
  if (blds.length>0) {
    const b=blds[Math.floor(Math.random()*blds.length)]; 
    st.fires.push({x:b.x,y:b.y,age:0,fireTrucksAtScene:0});
    
    // Dispatch fire truck from nearest fire station
    const dispatched = dispatchEmergencyVehicle('fire', b.x, b.y, 'fire');
    if (dispatched) {
      st.newsEvents.push(`üî• Fire breaks out in ${st.cityName}! Fire truck dispatched. (-$5k)`);
    } else {
      st.newsEvents.push(`üî• Fire breaks out in ${st.cityName}! No fire station nearby! (-$5k)`);
    }
    st.money-=5000;
    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
  }
}

function startQuake() {
  const gr=document.getElementById('grid'); gr.classList.add('earthquake');
  setTimeout(() => gr.classList.remove('earthquake'),500);
  const blds=[]; 
  const processedBuildings=new Set(); // Track buildings we've already added
  
  // Collect buildings, but only add the top-left cell of each building
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x]; 
      if (c.type==='empty' || c.type==='road') continue;
      
      // Skip level 0 RCI zones (empty zones), but allow abandoned buildings
      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
      if (isZone && (c.level||0)===0 && !c.abandoned) continue;
      
      const w=c.w||1, h=c.h||1;
      // Only add the top-left cell of each building to avoid duplicates
      // Check if this is the top-left cell
      let isTopLeft=true;
      if (w>1 || h>1) {
        // Check if there's a cell to the left or above with the same building
        if (x>0) {
          const leftCell=st.grid[y][x-1];
          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {
            isTopLeft=false;
          }
        }
        if (y>0) {
          const aboveCell=st.grid[y-1][x];
          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {
            isTopLeft=false;
          }
        }
      }
      
      if (isTopLeft) {
        // Ensure this building's footprint does not include any roads (which can happen
        // with older saves or after complex merges next to roads)
        let hasRoadInFootprint=false;
        for (let dy=0; dy<h && !hasRoadInFootprint; dy++) {
          for (let dx=0; dx<w; dx++) {
            const nx=x+dx, ny=y+dy;
            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
              if (st.grid[ny][nx].type==='road') {
                hasRoadInFootprint=true;
                break;
              }
            }
          }
        }
        if (hasRoadInFootprint) continue;

        const buildingKey=`${x},${y},${c.type},${w},${h}`;
        if (!processedBuildings.has(buildingKey)) {
          processedBuildings.add(buildingKey);
          blds.push({x,y,w,h});
        }
      }
    }
  }
  
  const dmg=Math.min(5,Math.floor(blds.length*0.1));
  for (let i=0; i<dmg; i++) {
    if (blds.length>0) {
      const b=blds.splice(Math.floor(Math.random()*blds.length),1)[0];
      // Destroy all cells that are part of this building using robust bounds
      const bounds=getBuildingBoundsFromCell(b.x,b.y);
      const w=bounds.w||1, h=bounds.h||1;
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=bounds.startX+dx, ny=bounds.startY+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            // Only destroy if it's not a road
            if (st.grid[ny][nx].type!=='road') {
              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
              normalizeEmptyCell(nx,ny); // Ensure it's 1x1
            }
          }
        }
      }
    }
  }
  st.newsEvents.push(`üåé Earthquake hits ${st.cityName}! ${dmg} buildings damaged (-$10k)`); st.money-=10000;
  nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
}

function updCrimeEvents() {
  st.crimeEvents=st.crimeEvents.filter(evt => {
    evt.age++;
    
    // Count police cars at scene (from vehicles that have arrived)
    const policeAtScene = st.cars.filter(c => 
      c.mission && 
      c.mission.type === 'crime' && 
      c.mission.arrived && 
      c.mission.targetX === evt.x && 
      c.mission.targetY === evt.y
    ).length;
    
    // Crimes REQUIRE police cars to resolve - they won't resolve on their own
    // Without police cars: crime continues indefinitely (causing ongoing costs)
    if (policeAtScene === 0) {
      // No police cars - crime continues
      // After 100 ticks without police, crime eventually stops (but damage is done)
      if (evt.age > 100) {
        // Crime resolved after long time without police (but should have been handled)
        return false;
      }
      // Continue costing money while crime is active
      if (evt.age % 10 === 0) {
        st.money -= 500; // Ongoing cost every 10 ticks
      }
      return true; // Keep crime active
    }
    
    // Police cars are at scene - resolve crime quickly
    // Resolve faster with more cars: 5 ticks per car (min 2 ticks)
    const maxAge = Math.max(2, 20 - policeAtScene * 5);
    
    if (evt.age>maxAge) {
      sendEmergencyVehiclesHome('crime', evt.x, evt.y);
      return false;
    }
    return true;
  });
}

function startCrimeEvent() {
  const blds=[];
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    // Higher crime areas are more likely to have crime events
    const crimeLevel=st.crime[y][x]||30;
    if ((c.type==='residential'||c.type==='commercial') && !c.abandoned && crimeLevel>40) {
      // Weight by crime level - higher crime = more likely
      for (let i=0; i<Math.floor(crimeLevel/20); i++) blds.push({x,y,crimeLevel});
    }
  }
  if (blds.length>0) {
    const b=blds[Math.floor(Math.random()*blds.length)];
    const crimeTypes=['robbery','break-in','vandalism'];
    const crimeType=crimeTypes[Math.floor(Math.random()*crimeTypes.length)];
    st.crimeEvents.push({x:b.x,y:b.y,type:crimeType,age:0,policeCarsAtScene:0});
    
    // Dispatch police car from nearest police station
    const dispatched = dispatchEmergencyVehicle('police', b.x, b.y, 'crime');
    const cost=Math.floor(Math.random()*3000)+2000;
    st.money-=cost;
    const dispatchedMsg = dispatched ? ' Police car dispatched.' : ' No police station nearby!';
    const msg=crimeType==='robbery'?`üö® Robbery reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`:
           crimeType==='break-in'?`üö® Break-in reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`:
           `üö® Vandalism reported in ${st.cityName}!${dispatchedMsg} (-$${(cost/1000).toFixed(0)}k)`;
    st.newsEvents.push(msg);
    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
  }
}

function simTk() {
  st.tickCount++; st.ticksSinceNews++;
  if (st.tickCount%8===0) st.year++;
  let rC=0, cC=0, iC=0, pC=0, poC=0, fC=0, sC=0, hC=0, rdC=0; const cntd={};
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const k=`${x},${y}`; if (cntd[k]) continue;
    const c=st.grid[y][x]; 
    // Normalize empty cells to ensure they're always 1x1
    if (c.type==='empty') normalizeEmptyCell(x,y);
    if (c.type!=='empty') {
      const w=c.w||1, h=c.h||1;
      // Only increment age once per building (only for the top-left cell being processed)
      c.age++;
      // For multi-tile buildings, sync age to all cells
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx<GR_SZ && ny<GR_SZ) {
            st.grid[ny][nx].age = c.age; // Sync age across all cells
          }
          cntd[`${nx},${ny}`]=true;
        }
      }
    }
    if (c.type==='residential') rC++; else if (c.type==='commercial') cC++; else if (c.type==='industrial') iC++;
    else if (c.type.startsWith('park')) pC++; else if (c.type==='police') poC++; else if (c.type==='fire') fC++;
    else if (c.type==='school') sC++; else if (c.type==='hospital') hC++; else if (c.type==='road') rdC++;
  }
  updLV();
  updCrime();
  // Track processed buildings to avoid duplicate updates for merged buildings
  const processedBuildings = new Set();
  const processedCells = new Set(); // Track individual cells that have been processed
  
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential'||c.type==='commercial'||c.type==='industrial') {
      // Skip if this cell has already been processed (e.g., as part of a merged building)
      const cellKey = `${x},${y}`;
      if (processedCells.has(cellKey)) continue;
      
      const w=c.w||1, h=c.h||1;
      // Only process the top-left cell of each building
      let isTopLeft=true;
      if (w>1 || h>1) {
        // Check if there's a cell to the left or above with the same building
        if (x>0) {
          const leftCell=st.grid[y][x-1];
          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {
            isTopLeft=false;
          }
        }
        if (y>0) {
          const aboveCell=st.grid[y-1][x];
          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {
            isTopLeft=false;
          }
        }
      }
      
      if (!isTopLeft) continue;
      
      // Skip if this building has already been processed
      const buildingKey = `${x},${y},${c.type},${w},${h}`;
      if (processedBuildings.has(buildingKey)) continue;
      processedBuildings.add(buildingKey);
      
      // Mark all cells of this building as processed
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            processedCells.add(`${nx},${ny}`);
          }
        }
      }
      
      const lv=st.landValue[y][x], hr=hasRdAcc(x,y), mv=c.type==='industrial'?10:20;
      
      // Track ticks without road access
      if (!hr) {
        c.ticksNoRoad = (c.ticksNoRoad || 0) + 1;
      } else {
        c.ticksNoRoad = 0;
      }
      
      // Immediate abandonment if land value too low
      if (lv<mv) { 
        c.abandoned=true;
        // Keep level but mark as abandoned - don't set to 0
        // Update all cells of merged building
        const w=c.w||1, h=c.h||1;
        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
          if (x+dx<GR_SZ && y+dy<GR_SZ) {
            st.grid[y+dy][x+dx].abandoned=true;
          }
        }
      }
      // Gradual decline without road access
      else if (!hr) {
        // Downgrade every 3 ticks without road
        if (c.ticksNoRoad > 3 && c.level > 1) {
          c.level--;
          c.ticksNoRoad = 0; // Reset counter after downgrade
          // Update all cells of merged building
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;
          }
        }
        // Become abandoned after being at level 1 for 5 ticks without road
        else if (c.ticksNoRoad > 5 && c.level >= 1) {
          c.abandoned = true;
          // Keep the level, just mark as abandoned
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) {
              st.grid[y+dy][x+dx].abandoned=true;
            }
          }
        }
        // Immediately abandon if no road for 10+ ticks
        else if (c.ticksNoRoad > 10) {
          c.abandoned = true;
          // Keep the level, just mark as abandoned
          const w=c.w||1, h=c.h||1;
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) {
              st.grid[y+dy][x+dx].abandoned=true;
            }
          }
        }
      }
      else {
        c.abandoned=false;
        // Update all cells of merged building to un-abandon
        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
          if (x+dx<GR_SZ && y+dy<GR_SZ) {
            st.grid[y+dy][x+dx].abandoned=false;
          }
        }
        
        // Check for downgrades first (more important)
        let downgraded = false;
        if (lv<30 && c.level>1) { 
          const newLevel = Math.max(1,c.level-1);
          c.level = newLevel;
          downgraded = true;
          // Update all cells of merged building
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;
          }
        }
        // Level 3 downgrades: need land value >= 40 AND school coverage (same criteria as upgrade)
        else if (c.level===3 && (lv<40 || !hasSchoolCoverage(x,y))) { 
          c.level=2; 
          downgraded = true;
          // Update all cells of merged building
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=2;
          }
        }
        
          // Upgrade logic - only if not downgraded, gradual one level at a time
          // Slowed down upgrades: require more age and better conditions
          if (!downgraded) {
            let upgraded = false;
            // Level 0 -> 1: needs age > 10 ticks (was 5)
            if (c.level===0 && c.age>10) {
              c.level=1;
              upgraded = true;
            }
            // Level 1 -> 2: needs age > 30 AND land value > 55 (was 15 and 50)
            else if (c.level===1 && c.age>30 && lv>55) {
              c.level=2;
              upgraded = true;
            }
            // Level 2 -> 3: needs age > 50 AND land value >= 40 AND school coverage
            else if (c.level===2 && c.age>50 && lv>=40 && hasSchoolCoverage(x,y)) {
              c.level=3;
              upgraded = true;
            }
          
          // Update all cells of merged building if upgraded
          if (upgraded) {
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;
            }
          }
        }
        
        // Two-step merging process:
        // Step 1: Try to merge 1x1 buildings to 2x1 or 1x2 first
        if (c.age>8 && w===1 && h===1 && c.level>0) {
          const merged=tryMrgTo2x1(x,y);
          if (merged) {
            // Mark all cells of the newly merged building as processed
            // The merged building is now 2x1 or 1x2, so we need to update processedCells
            // But we don't know which direction it merged, so we'll let the next iteration handle it
            // For now, just mark the current cell as processed
            processedCells.add(`${x},${y}`);
            if (x+1<GR_SZ) processedCells.add(`${x+1},${y}`); // If merged right (2x1)
            if (y+1<GR_SZ) processedCells.add(`${x},${y+1}`); // If merged down (1x2)
          }
        }
        // Step 2: Try to merge 2x1 or 1x2 buildings to 2x2 (only if at least one is 2x1/1x2)
        if (c.age>12 && ((w===1&&h===2) || (w===2&&h===1)) && c.level>0) {
          // Only try merge if this is the top-left cell of the building
          // For 1x2: always top-left (spans down)
          // For 2x1: always top-left (spans right)
          const merged=tryMrg(x,y);
          if (merged) {
            // Mark all cells of the newly merged 2x2 building as processed
            // After merge, the grid has been updated with a 2x2 building
            // Check the current cell and nearby cells to find the 2x2 building's top-left
            let found2x2=false;
            for (let checkY=Math.max(0,y-1); checkY<=Math.min(GR_SZ-2,y+1) && !found2x2; checkY++) {
              for (let checkX=Math.max(0,x-1); checkX<=Math.min(GR_SZ-2,x+1) && !found2x2; checkX++) {
                const checkCell=st.grid[checkY][checkX];
                if (checkCell.type===c.type && (checkCell.w||1)===2 && (checkCell.h||1)===2) {
                  // This is the top-left of the merged 2x2 building
                  // Mark all 4 cells as processed
                  for (let dy=0; dy<2; dy++) {
                    for (let dx=0; dx<2; dx++) {
                      const nx=checkX+dx, ny=checkY+dy;
                      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                        processedCells.add(`${nx},${ny}`);
                      }
                    }
                  }
                  found2x2=true;
                }
              }
            }
          }
        }
      }
    } else if (c.type.startsWith('park')) {
      // Try to merge parks of the same type
      tryMrgPark(x,y);
    }
  }
  const bPR=10; let nP=0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
      const sM=(c.w||1)*(c.h||1), lM=c.level===3?1.5:(c.level===2?1.2:1);
      nP+=Math.floor(bPR*sM*lM);
    }
  }
  st.population=nP;
  const jA=cC*5+iC*8, jN=nP*0.6;
  if (jA<=0 || jN<=0) st.employment=0;
  else st.employment=Math.min(100,Math.floor((Math.min(jA,jN)/jN)*100));
  const inc=Math.floor(st.population*2), mnt=Math.floor(rdC*1+rC*2+cC*3+iC*5+pC*2+poC*10+fC*10+sC*15+hC*20);
  st.money+=inc-mnt;
  let hp=70;
  if (st.population>0) {
    const pR=pC/(rC+1); hp+=Math.min(pR*50,15);
    const sR=(poC+fC+sC+hC)/(st.population/100+1); hp+=Math.min(sR*20,10);
    const jR=(cC+iC)/(rC+1); if (jR<0.5) hp-=10; else if (jR>2) hp-=5;
    if (st.money<0) hp-=15;
    // Factor in crime - calculate average city crime
    let avgCrime=0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      avgCrime+=st.crime[y][x]||30;
    }
    avgCrime=avgCrime/(GR_SZ*GR_SZ);
    // High crime reduces happiness (up to -15 points)
    if (avgCrime>60) hp-=Math.min(15,Math.floor((avgCrime-60)/2));
    else if (avgCrime>40) hp-=Math.min(8,Math.floor((avgCrime-40)/3));
    // Police coverage improves happiness
    if (poC>0 && st.population>0) {
      const policeRatio=poC/(st.population/500+1);
      hp+=Math.min(5,policeRatio*2);
    }
  }
  st.happiness=Math.max(0,Math.min(100,Math.floor(hp)));
  const dmd=calcDmd(rC,cC,iC,st.population); st.rDemand=Math.floor(dmd.rDemand); st.cDemand=Math.floor(dmd.cDemand); st.iDemand=Math.floor(dmd.iDemand);
  const tB=rC+cC+iC+pC+poC+fC+sC+hC;
  if (st.ticksSinceNews>=20 && tB>5 && !aiReq) { st.ticksSinceNews=0; genNws(); }
    if (Math.random()<0.02 && tB>10) startFire();
    if (Math.random()<0.01 && tB>20) startQuake();
    if (Math.random()<0.02 && st.population>50) startCrimeEvent();
    ensureEmergencyCoverage();
    updFires(); updCrimeEvents(); drGr(); updUI(); updateStatsPanel(); sv();
}

const aC=new (window.AudioContext||window.webkitAudioContext)();
function plySnd(t) {
  const n=aC.currentTime;
  if (t==='place') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); }
  else if (t==='bulldoze') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sawtooth'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(200,n); g.gain.setValueAtTime(0.15,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); }
  else if (t==='click') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(600,n); g.gain.setValueAtTime(0.08,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.05); o.start(n); o.stop(n+0.05); }
  else if (t==='error') { const o=aC.createOscillator(), g=aC.createGain(); o.type='square'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(300,n); o.frequency.setValueAtTime(200,n+0.1); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); }
}

if (!ld()) { initGr('balanced'); st.newsEvents=['Welcome to '+st.cityName+'!']; }
if (!st.zoom) st.zoom=1;
if (st.disastersEnabled === undefined) st.disastersEnabled = true;
const disastersToggleEl = document.getElementById('disastersToggle');
if (disastersToggleEl) {
  disastersToggleEl.checked = st.disastersEnabled;
  disastersToggleEl.addEventListener('change', (e) => {
    st.disastersEnabled = e.target.checked;
    updateDisasterButtonsVisibility();
    sv();
  });
}
updateDisasterButtonsVisibility();
applyZoom();
drGr(); updUI(); updNwsTk(); selTl('road');
if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); }

// Center canvas after page is fully loaded
window.addEventListener('load', () => {
  setTimeout(centerCanvas, 100);
});

// Re-center canvas when window is resized
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(centerCanvas, 100);
});

setInterval(() => { if (st.speed>0) { updCars(); drGr(); } },50);

// Building info panel for stat view
function showBuildingInfo(x, y) {
  const c = st.grid[y][x];
  if (!c || c.type === 'empty') return;
  
  const panel = document.getElementById('buildingInfoPanel');
  const title = document.getElementById('buildingInfoTitle');
  const content = document.getElementById('buildingInfoContent');
  
  // Get building icon
  const icon = {
    'residential': 'üè†',
    'commercial': 'üè¢',
    'industrial': 'üè≠',
    'road': 'üõ£Ô∏è',
    'park': 'üå≥',
    'park2': 'üå∏',
    'park3': 'üå≤',
    'park4': 'üåª',
    'police': 'üëÆ',
    'fire': 'üöí',
    'school': 'üè´',
    'hospital': 'üè•'
  }[c.type] || 'üèóÔ∏è';
  
  // Format building name
  const name = c.type.charAt(0).toUpperCase() + c.type.slice(1).replace(/\d+$/, '');
  title.textContent = `${icon} ${name}`;
  
  // Build content
  let statItems = [];
  
  // Size info for multi-tile buildings
  if (c.w > 1 || c.h > 1) {
    statItems.push(statItem('size', `${c.w}√ó${c.h}`));
  }
  
  // Level info for zones
  if (c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') {
    if (c.abandoned) {
      statItems.push(statItem('status', 'Abandoned', 'text-red-400'));
    } else {
      statItems.push(statItem('level', c.level));
    }
  }
  
  // Age info
  if (c.age !== undefined) {
    const years = Math.floor(c.age / 12);
    statItems.push(statItem('age', `${years} year${years !== 1 ? 's' : ''}`));
  }
  
  // Land value and crime for this tile
  const landValue = st.landValue[y] && st.landValue[y][x] !== undefined ? st.landValue[y][x] : 50;
  const crime = st.crime[y] && st.crime[y][x] !== undefined ? st.crime[y][x] : 30;
  
  if (showLandValueOverlay) {
    const lvColor = landValue >= 80 ? 'text-green-400' : landValue >= 50 ? 'text-yellow-400' : 'text-orange-400';
    statItems.push(statItem('land value', landValue.toFixed(0), lvColor));
  }
  
  if (showCrimeOverlay) {
    const crimeColor = crime >= 70 ? 'text-red-400' : crime >= 30 ? 'text-yellow-400' : 'text-green-400';
    const crimeLevel = crime >= 70 ? 'High' : crime >= 30 ? 'Medium' : 'Low';
    statItems.push(statItem('crime', `${crimeLevel} (${crime.toFixed(0)})`, crimeColor));
  }
  
  if (statItems.length > 0) {
    content.innerHTML = `<div class="flex flex-wrap gap-6 py-2">${statItems.join('')}</div>`;
  } else {
    content.innerHTML = '';
  }
  panel.classList.remove('hidden');
  
  // Set highlighted building (get full building bounds from top-left corner)
  const bounds = getBuildingBoundsFromCell(x, y);
  highlightedBuilding = {
    x: bounds.startX,
    y: bounds.startY,
    w: bounds.w,
    h: bounds.h
  };
  drGr(); // Redraw to show highlight
}

function hideBuildingInfo() {
  const panel = document.getElementById('buildingInfoPanel');
  panel.classList.add('hidden');
  highlightedBuilding = null;
  drGr(); // Redraw to remove highlight
}
</script>
</body>
</html>
