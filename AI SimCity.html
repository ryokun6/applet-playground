<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <link rel="stylesheet" href="https://os.ryo.lu/fonts/fonts.css">
    <!-- ts=1763051833299 --> 
    
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "sans-serif"],
              mono: ["Monaco", "ArkPixel", "SerenityOS-Emoji", "ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", "monospace"],
              serif: ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "SerenityOS-Emoji", "serif"],
              emoji: ["SerenityOS-Emoji", "AppleColorEmoji", "AppleColorEmojiFallback"],
              'geneva': ["Geneva-12", "ArkPixel", "SerenityOS-Emoji", "system-ui", "-apple-system", "sans-serif"],
              'mondwest': ["Mondwest", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "Yu Mincho", "Hiragino Mincho Pro", "serif"],
              'neuebit': ["NeueBit", "ArkPixel", "SerenityOS-Emoji", "Helvetica", "Arial", "Hiragino Sans", "sans-serif"],
              'monaco': ["Monaco", "ArkPixel", "SerenityOS-Emoji", "monospace"],
              'jacquard': ["Jacquard", "Yu Mincho", "Hiragino Mincho Pro", "Georgia", "Palatino", "serif"]
            }
          }
        }
      }
    </script>
  <style>
    * {
      box-sizing: border-box;
      
    }
    html, body {
      margin: 0;
      overflow-x: auto; /* Allow horizontal scroll if content overflows */
      width: 100%;
      height: 100%;
      max-width: 100%; /* Prevent body from exceeding viewport width */
      
    }
    
    /* Ensure pre doesn't break layout */
    pre {
      white-space: pre-wrap; /* Allow wrapping */
      word-break: break-all; /* Break long words */
    }
  </style>
  
  <script>
    (function() {
      function handleLinkClick(event) {
        const targetElement = event.target.closest('a');
        if (targetElement && targetElement.href && !targetElement.closest('[data-drag-controls]') && !targetElement.hasAttribute('download')) {
          event.preventDefault();
          event.stopPropagation();
          try {
            const absoluteUrl = new URL(targetElement.getAttribute('href'), document.baseURI || window.location.href).href;
            window.parent.postMessage({ type: 'aiHtmlNavigation', url: absoluteUrl }, '*');
          } catch (e) { console.error("Error resolving/posting URL:", e); }
        }
      }
      document.addEventListener('click', handleLinkClick, true);
      document.addEventListener('DOMContentLoaded', () => document.addEventListener('click', handleLinkClick, true));
    })();
  </script>
 
</head>
<body>
  <div class="w-full h-screen bg-neutral-900 text-neutral-100 font-geneva flex flex-col overflow-hidden">
  <div class="border-b border-neutral-700 bg-neutral-800 px-3 py-2 flex items-center justify-between flex-shrink-0">
    <div class="flex items-center gap-3">
      <button id="menuBtn" class="text-sm text-neutral-300 hover:text-neutral-100 transition-colors">‚ò∞</button>
      <div class="flex items-center gap-1">
        <div class="text-sm text-neutral-400">
          <input id="cityName" type="text" value="new city" class="bg-transparent border-none outline-none text-white cursor-pointer hover:bg-neutral-700 px-1 rounded transition-colors">
        </div>
        <button id="speedToggle" class="text-xs text-neutral-300 hover:text-neutral-100 transition-colors">‚è∏</button>
      </div>
    </div>
    
    <div class="flex items-center gap-3">
      <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="rciBtn">
        <div id="powerShortageIndicator" class="flex items-center gap-0.5 text-xs mr-1" style="display: none;">
          <span class="text-red-400">‚ö°</span>
          <span id="powerShortageValue" class="text-red-400 tabular-nums"></span>
        </div>
        <div id="waterShortageIndicator" class="flex items-center gap-0.5 text-xs mr-1" style="display: none;">
          <span class="text-red-400">üíß</span>
          <span id="waterShortageValue" class="text-red-400 tabular-nums"></span>
        </div>
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="rDemand" class="w-full bg-green-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="cDemand" class="w-full bg-blue-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
        <div class="w-1 h-4 bg-neutral-700 rounded-full overflow-hidden">
          <div id="iDemand" class="w-full bg-yellow-500 transition-all duration-300" style="height: 50%; margin-top: auto;"></div>
        </div>
      </div>
      
      <div class="flex items-center gap-1.5 text-xs">
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="popBtn">
          <span class="text-neutral-500">‚òª</span>
          <span id="population" class="text-white tabular-nums">0</span>
        </div>
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="moneyBtn">
          <span class="text-neutral-500">$</span>
          <span id="money" class="text-white tabular-nums">50k</span>
        </div>
        <div class="flex items-center gap-1 cursor-pointer hover:opacity-80 transition-opacity" id="happyBtn">
          <span class="text-neutral-500">‚ô•</span>
          <span id="happiness" class="text-white tabular-nums">70</span>
        </div>
      </div>
    </div>
  </div>

  <div class="border-b border-neutral-700 bg-neutral-800 px-3 py-1.5 flex items-center gap-3 text-xs flex-shrink-0">
    <div id="yearDisplay" class="text-neutral-400 font-mono tabular-nums">1990</div>
    <div class="flex-1 overflow-hidden relative" style="height: 1.25rem; line-height: 1.25rem;">
      <div id="newsTicker" class="text-neutral-300 whitespace-nowrap absolute left-0 transition-all duration-500" style="line-height: 1.25rem;"></div>
    </div>
  </div>

  <div id="menu" class="hidden border-b border-neutral-700 bg-neutral-800 p-3 flex-shrink-0">
    <div class="max-w-md mx-auto space-y-3">
      <div class="flex items-start gap-3">
        <div class="space-y-2 flex-1">
          <div class="text-xs text-neutral-500 tracking-wider px-1">zoom</div>
          <div class="flex items-center gap-1 w-full justify-between">
            <button id="zoomOutBtn" class="w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center">‚àí</button>
            <div id="zoomLevel" class="text-xs text-neutral-300 tabular-nums px-2">100%</div>
            <button id="zoomInBtn" class="w-8 h-8 aspect-square border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors flex items-center justify-center">+</button>
          </div>
        </div>
        <div class="space-y-2 flex-1">
          <div class="text-xs text-neutral-500 tracking-wider px-1">settings</div>
          <label class="flex items-center gap-2 px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors cursor-pointer">
            <input id="disastersToggle" type="checkbox" checked class="w-4 h-4 accent-green-600">
            <span>disasters</span>
          </label>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="exportBtn" class="flex-1 text-center px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors">
          export
        </button>
        <button id="importBtn" class="flex-1 text-center px-3 py-2 border border-neutral-600 text-neutral-300 rounded text-sm hover:bg-neutral-700 transition-colors">
          import
        </button>
        <input type="file" id="importFileInput" accept=".json" class="hidden">
      </div>
      <div class="flex items-center gap-2">
        <button id="aiSuggestBtn" class="flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors flex items-center justify-center gap-2">
          <span>ask AI mayor</span>
        </button>
        <button id="newCityBtn" class="flex-1 text-center px-3 py-2 border border-yellow-600 text-yellow-500 rounded text-sm hover:bg-yellow-900/20 transition-colors">
          new city
        </button>
      </div>
    </div>
  </div>

  <div id="newGamePanel" class="hidden border-b border-neutral-700 bg-neutral-800 p-4 flex-shrink-0">
    <div class="max-w-md mx-auto space-y-3">
      <div>
        <label class="text-xs text-neutral-400 block mb-1">city name</label>
        <input id="newCityName" type="text" value="" placeholder="new city" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none focus:border-neutral-500">
      </div>
      <div>
        <label class="text-xs text-neutral-400 block mb-1">terrain type</label>
        <select id="terrainType" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none">
          <option value="balanced">balanced</option>
          <option value="island">island</option>
          <option value="valley">valley</option>
          <option value="plains">plains</option>
        </select>
      </div>
      <div>
        <label class="text-xs text-neutral-400 block mb-1">difficulty</label>
        <select id="difficulty" class="w-full bg-neutral-700 border border-neutral-600 text-neutral-200 px-3 py-2 rounded text-sm outline-none">
          <option value="easy">easy ($100k)</option>
          <option value="normal" selected>normal ($50k)</option>
          <option value="hard">hard ($20k)</option>
        </select>
      </div>
      <button id="startGameBtn" class="w-full bg-green-700 hover:bg-green-600 text-white px-4 py-2 rounded text-sm transition-colors">
        start game
      </button>
    </div>
  </div>

  <div class="flex-1 overflow-hidden flex">
    <div id="grid" class="flex-1 overflow-auto p-4 relative">
      <canvas id="canvas" class="rounded" style="image-rendering: pixelated;"></canvas>
    </div>

    <div class="flex flex-shrink-0 relative" style="overflow: visible;">
      <div id="subToolbar" class="hidden absolute right-[calc(100%+1px)] w-14 border-r border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto rounded-lg z-10" style="overflow-x: visible;"></div>
      <div class="w-14 border-l border-neutral-800 bg-neutral-900 p-1 flex flex-col gap-1 overflow-y-auto flex-shrink-0" id="mainToolbar" style="overflow-x: visible;">
        <button data-tool="road" data-tooltip="road" data-shortcut="R" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üõ£Ô∏è</button>
        <button data-tool="residential" data-tooltip="residential" data-shortcut="H" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè†</button>
        <button data-tool="commercial" data-tooltip="commercial" data-shortcut="C" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè¢</button>
        <button data-tool="industrial" data-tooltip="industrial" data-shortcut="I" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üè≠</button>
        <div class="w-full flex flex-col">
          <div class="h-1"></div>
          <div class="h-px w-full bg-neutral-700"></div>
          <div class="h-1"></div>
        </div>
        <button data-submenu="power" data-tooltip="energy" data-shortcut="E" class="tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center">‚ö°</button>
        <button data-submenu="water" data-tooltip="water" data-shortcut="Q" class="tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center">üíß</button>
        <button data-submenu="services" data-tooltip="services" data-shortcut="S" class="tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center">üèõÔ∏è</button>
        <button data-submenu="park" data-tooltip="park" data-shortcut="P" class="tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center">üå≥</button>
        <div class="w-full flex flex-col">
          <div class="h-1"></div>
          <div class="h-px w-full bg-neutral-700"></div>
          <div class="h-1"></div>
        </div>
        <button data-submenu="disaster" data-tooltip="disasters" data-shortcut="W" class="disaster-btn tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center" style="display: none;">‚ö†Ô∏è</button>
        <button data-tool="bulldoze" data-tooltip="demolish" data-shortcut="D" class="tool-btn w-full aspect-square text-2xl rounded transition-colors border border-transparent flex items-center justify-center">üí•</button>
      </div>
    </div>
  </div>

  <div id="aiPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0">
    <div class="max-w-md mx-auto">
      <div class="flex items-start gap-2 mb-2">
        <div class="flex-1">
          <div class="text-xs text-yellow-500 mb-1">AI Mayor</div>
          <div id="aiMessage" class="text-sm text-neutral-300 leading-relaxed"></div>
        </div>
        <button id="closeAiBtn" class="text-xs text-neutral-500 hover:text-neutral-300">‚úï</button>
      </div>
    </div>
  </div>
  <!-- Building info panel for stat view -->
  <div id="buildingInfoPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 flex-shrink-0">
    <div class="max-w-md mx-auto">
      <div class="flex items-start gap-2">
        <div class="flex-1">
          <div id="buildingInfoTitle" class="text-sm font-bold text-white mb-2"></div>
          <div id="buildingInfoContent" class="text-xs text-neutral-300 space-y-1"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="infoPanel" class="hidden border-t border-neutral-700 bg-neutral-800 p-3 max-h-48 overflow-y-auto flex-shrink-0">
    <div>
      <div class="flex items-start gap-2 mb-2">
        <div class="flex-1">
          <div class="text-xs text-blue-400 mb-1" id="infoTitle">Info</div>
          <div id="infoContent" class="text-sm text-neutral-300 leading-relaxed space-y-1"></div>
        </div>
        <button id="closeInfoBtn" class="text-xs text-neutral-500 hover:text-neutral-300">‚úï</button>
      </div>
    </div>
  </div>



  <div class="border-t border-neutral-700 bg-neutral-800 px-3 py-2 text-xs text-neutral-400 flex items-center justify-between flex-shrink-0">
    <div id="statusText">select a tool to start building</div>
    <div id="costText" class="text-neutral-500"></div>
  </div>
</div>

<style>
@keyframes tickerRollUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-100%); opacity: 0; }
}
@keyframes shake {
  0%, 100% { transform: translate(0, 0); }
  5% { transform: translate(-8px, 6px); }
  10% { transform: translate(7px, -5px); }
  15% { transform: translate(-9px, 4px); }
  20% { transform: translate(8px, -7px); }
  25% { transform: translate(-10px, 8px); }
  30% { transform: translate(9px, -6px); }
  35% { transform: translate(-7px, 5px); }
  40% { transform: translate(8px, -8px); }
  45% { transform: translate(-9px, 7px); }
  50% { transform: translate(10px, -5px); }
  55% { transform: translate(-8px, 6px); }
  60% { transform: translate(7px, -7px); }
  65% { transform: translate(-6px, 5px); }
  70% { transform: translate(5px, -6px); }
  75% { transform: translate(-4px, 4px); }
  80% { transform: translate(4px, -4px); }
  85% { transform: translate(-3px, 3px); }
  90% { transform: translate(2px, -2px); }
  95% { transform: translate(-1px, 1px); }
}
.ticker-roll { animation: tickerRollUp 0.5s ease-out forwards; }
.earthquake { animation: shake 1.5s ease-in-out; }
.tool-btn {
  transition: opacity 0.2s ease, background-color 0.2s ease;
  position: relative;
}
.tooltip {
  position: fixed;
  background-color: rgb(30, 30, 30);
  color: rgb(229, 229, 229);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10000;
  border: 1px solid rgb(64, 64, 64);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.tooltip.show {
  opacity: 1;
}
.tooltip-shortcut {
  color: rgb(163, 163, 163);
  margin-left: 6px;
}
@media (hover: hover) and (pointer: fine) {
  .tool-btn:hover { background-color: rgb(64, 64, 64); opacity: 1 !important; }
  .tool-btn[data-tool="bulldoze"]:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }
  .tool-btn.submenu-active:hover { background-color: rgb(127, 29, 29); opacity: 1 !important; }
}
</style>

<script>
// Constants
const GR_SZ = 32, CL_SZ = 16;
const COSTS = {road:100,residential:500,commercial:800,industrial:1000,park:300,park2:300,park3:300,park4:300,police:2000,fire:2000,school:3000,hospital:4000,coal:5000,nuclear:10000,wind:3000,pipe:50,waterplant:4000,watertower:2000};
const POWER_GENERATION = {coal:600,nuclear:1200,wind:240};
const WATER_GENERATION = {waterplant:1600,watertower:800};
// Approximate monthly maintenance cost per tile for each power plant type
const POWER_PLANT_MAINTENANCE = {coal:40,nuclear:70,wind:20};
// Approximate monthly maintenance cost per tile for each water plant type
const WATER_PLANT_MAINTENANCE = {waterplant:30,watertower:15};
const LAND_VALUE_LOW_COLOR = {r:250,g:204,b:21};
const LAND_VALUE_HIGH_COLOR = {r:34,g:197,b:94};
const STATION_MAX_ACTIVE = 2;
const STAT_INFO_TYPES = ['rci','pop','money','happy'];
const CAR_BASE_SPEED = 1.0;
const CAR_EDGE_OFFSET = CL_SZ/2 - 1;
const CAR_SNAP_THRESHOLD = 0.5;
const EMERGENCY_SPEED_MULTIPLIER = 1.2;

// State variables
let TK_INT = 2000, tkTmr = null, aiReq = false, edtNm = false, nwsIdx = 0, tkrTmr = null, trans = false, nwsQ = [];
let st = {cityName:'new city',money:50000,population:0,happiness:70,grid:[],terrain:[],landValue:[],crime:[],crimeEvents:[],selectedTool:null,tickCount:0,speed:3000,rDemand:50,cDemand:50,iDemand:50,year:1950,newsEvents:[],ticksSinceNews:0,fires:[],employment:0,cars:[],zoom:1.5,disastersEnabled:true,stationDispatches:{},taxRate:10,powerGrid:[],powerShortageBuildings:{},waterGrid:[],waterShortageBuildings:{}};
let nextBuildingId = 1;
let showLandValueOverlay = false;
let showCrimeOverlay = false;
let showWaterOverlay = false;
let highlightedBuilding = null;
let currentInfoType = null;
let activeSubmenu = null;
let isDragging = false, dragStart = null, lastPlaced = null, isScrolling = false, touchStartPos = null, lastTouchPos = null;
let hoverPos = null;
let lastZoneBounds = null;
let resizeTimeout;

// ===== Power System =====
function getPowerConsumption(buildingType, level) {
  if (buildingType === 'residential') {
    if (level === 2) return 5;
    if (level === 3) return 10;
    return 0; // L1 residential doesn't need power
  } else if (buildingType === 'commercial') {
    if (level === 1) return 10;
    if (level === 2) return 20;
    if (level === 3) return 30;
    return 0;
  } else if (buildingType === 'industrial') {
    if (level === 1) return 15;
    if (level === 2) return 30;
    if (level === 3) return 45;
    return 0;
  }
  return 0;
}

function getBuildingPowerKey(x, y) {
  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;
  const cell = st.grid[y][x];
  if (!cell || !cell.type || cell.type === 'empty') return null;
  if (cell.buildingId != null) return `b:${cell.buildingId}`;
  const bounds = getBuildingBoundsFromCell(x,y);
  const w = bounds.w || 1;
  const h = bounds.h || 1;
  return `b:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;
}

function getPowerPlantKey(x, y) {
  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;
  const cell = st.grid[y][x];
  if (!cell || !cell.type) return null;
  if (cell.buildingId != null) return `p:${cell.buildingId}`;
  const bounds = getBuildingBoundsFromCell(x,y);
  const w = bounds.w || 1;
  const h = bounds.h || 1;
  return `p:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;
}

function getPowerSystemSnapshot() {
  const processedPowerPlants = new Set();
  const processedBuildings = new Set();
  const consumers = [];
  let totalPowerGeneration = 0;
  let totalPowerConsumption = 0;
  let coalGen = 0, nuclearGen = 0, windGen = 0;
  let coalCount = 0, nuclearCount = 0, windCount = 0;
  let residentialConsumption = 0, commercialConsumption = 0, industrialConsumption = 0;
  
  for (let y = 0; y < GR_SZ; y++) {
    for (let x = 0; x < GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (!cell) continue;
      
      if (cell.type === 'coal' || cell.type === 'nuclear' || cell.type === 'wind') {
        const plantKey = getPowerPlantKey(x,y);
        if (plantKey && !processedPowerPlants.has(plantKey)) {
          processedPowerPlants.add(plantKey);
          const gen = POWER_GENERATION[cell.type] || 0;
          totalPowerGeneration += gen;
          if (cell.type === 'coal') { coalGen += gen; coalCount++; }
          else if (cell.type === 'nuclear') { nuclearGen += gen; nuclearCount++; }
          else if (cell.type === 'wind') { windGen += gen; windCount++; }
        }
      }
      
      if (cell.type === 'residential' || cell.type === 'commercial' || cell.type === 'industrial') {
        if (cell.abandoned) continue;
        const buildingKey = getBuildingPowerKey(x,y);
        if (!buildingKey || processedBuildings.has(buildingKey)) continue;
        processedBuildings.add(buildingKey);
        
        const level = cell.level || 0;
        const perTileConsumption = getPowerConsumption(cell.type, level);
        if (perTileConsumption <= 0) continue;
        const bounds = getBuildingBoundsFromCell(x,y);
        const area = Math.max(1,(bounds.w||1)*(bounds.h||1));
        const consumption = perTileConsumption * area;
        totalPowerConsumption += consumption;
        if (cell.type === 'residential') residentialConsumption += consumption;
        else if (cell.type === 'commercial') commercialConsumption += consumption;
        else industrialConsumption += consumption;
        
        const hasConnection = hasPowerAccess(x,y);
        consumers.push({
          key: buildingKey,
          type: cell.type,
          level,
          consumption,
          hasConnection,
          x: bounds.startX,
          y: bounds.startY
        });
      }
    }
  }
  
  return {
    totalPowerGeneration,
    totalPowerConsumption,
    coalGen,
    nuclearGen,
    windGen,
    coalCount,
    nuclearCount,
    windCount,
    residentialConsumption,
    commercialConsumption,
    industrialConsumption,
    consumers
  };
}

function allocatePowerToBuildings() {
  if (!st.powerShortageBuildings || typeof st.powerShortageBuildings !== 'object') {
    st.powerShortageBuildings = {};
  }
  const snapshot = getPowerSystemSnapshot();
  const shortageMap = {};
  const connectedBuildings = [];
  
  for (const consumer of snapshot.consumers) {
    if (!consumer.hasConnection) {
      shortageMap[consumer.key] = true;
    } else if (consumer.consumption > 0) {
      connectedBuildings.push(consumer);
    }
  }
  
  const typePriority = {residential:0, commercial:1, industrial:2};
  connectedBuildings.sort((a,b) => {
    const typeDiff = (typePriority[a.type] ?? 99) - (typePriority[b.type] ?? 99);
    if (typeDiff !== 0) return typeDiff;
    if (b.level !== a.level) return b.level - a.level;
    if (a.consumption !== b.consumption) return a.consumption - b.consumption;
    return a.key.localeCompare(b.key);
  });
  
  let remainingPower = snapshot.totalPowerGeneration;
  for (const building of connectedBuildings) {
    if (remainingPower >= building.consumption) {
      remainingPower -= building.consumption;
    } else {
      shortageMap[building.key] = true;
    }
  }
  
  st.powerShortageBuildings = shortageMap;
}

// Calculate power generation and consumption statistics
function calculatePowerStats(includeDetails = false) {
  const snapshot = getPowerSystemSnapshot();
  const result = {
    totalPowerGeneration: snapshot.totalPowerGeneration,
    totalPowerConsumption: snapshot.totalPowerConsumption,
    powerSurplus: snapshot.totalPowerGeneration - snapshot.totalPowerConsumption
  };
  
  if (includeDetails) {
    result.coalGen = snapshot.coalGen;
    result.nuclearGen = snapshot.nuclearGen;
    result.windGen = snapshot.windGen;
    result.coalCount = snapshot.coalCount;
    result.nuclearCount = snapshot.nuclearCount;
    result.windCount = snapshot.windCount;
    result.residentialConsumption = snapshot.residentialConsumption;
    result.commercialConsumption = snapshot.commercialConsumption;
    result.industrialConsumption = snapshot.industrialConsumption;
  }
  
  return result;
}

const cvs = document.getElementById('canvas'), ctx = cvs.getContext('2d');
cvs.width = GR_SZ * CL_SZ; cvs.height = GR_SZ * CL_SZ;

// ===== Terrain & Grid =====
function genTerr(t) {
  const tr = [];
  for (let y=0; y<GR_SZ; y++) { const r=[]; for (let x=0; x<GR_SZ; x++) r.push('grass'); tr.push(r); }
  if (t==='island') {
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const dx=x-GR_SZ/2, dy=y-GR_SZ/2, d=Math.sqrt(dx*dx+dy*dy), n=(Math.sin(x*0.3)+Math.cos(y*0.3))*2;
      if (d+n>GR_SZ/2.3) tr[y][x]='water';
    }
    for (let i=0; i<3; i++) {
      const cx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), cy=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-cx, dy=y-cy, d=Math.sqrt(dx*dx+dy*dy);
        if (d<3 && tr[y][x]==='grass') tr[y][x]='cliff';
      }
    }
  } else if (t==='valley') {
    for (let y=0; y<GR_SZ; y++) {
      const cd=Math.abs(y-GR_SZ/2), th=GR_SZ/4+Math.sin(y*0.2)*2;
      if (cd>th) for (let x=0; x<GR_SZ; x++) tr[y][x]='cliff';
    }
    const ry=Math.floor(GR_SZ/2);
    for (let x=0; x<GR_SZ; x++) {
      const of=Math.floor(Math.sin(x*0.3)*3), r=ry+of;
      if (r>=0 && r<GR_SZ) { tr[r][x]='water'; if (r-1>=0 && Math.random()<0.5) tr[r-1][x]='water'; if (r+1<GR_SZ && Math.random()<0.5) tr[r+1][x]='water'; }
    }
  } else if (t==='plains') {
    for (let i=0; i<2; i++) {
      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;
        if (d+n<4) tr[y][x]='water';
      }
    }
  } else {
    for (let i=0; i<2; i++) {
      const lx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), ly=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-lx, dy=y-ly, d=Math.sqrt(dx*dx+dy*dy), n=Math.sin(x*0.5+y*0.5)*1.5;
        if (d+n<3.5) tr[y][x]='water';
      }
    }
    for (let i=0; i<2; i++) {
      const mx=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2), my=Math.floor(GR_SZ/4+Math.random()*GR_SZ/2);
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        const dx=x-mx, dy=y-my, d=Math.sqrt(dx*dx+dy*dy);
        if (d<2.5 && tr[y][x]==='grass') tr[y][x]='cliff';
      }
    }
  }
  return tr;
}

// Helper function to ensure empty cells are always 1x1
function normalizeEmptyCell(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return;
  const c=st.grid[y][x];
  if (c.type==='empty' && ((c.w||1)!==1 || (c.h||1)!==1)) {
    st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
  }
}
  
  function snapCenterToPixelGrid(value, halfSize) {
    const fractional = halfSize - Math.floor(halfSize);
    if (Math.abs(fractional) < 1e-6) return Math.round(value);
    return Math.round(value - fractional) + fractional;
  }

function initGr(tt='balanced') {
  st.grid=[]; st.terrain=genTerr(tt); st.landValue=[]; st.crime=[]; st.fires=[]; st.cars=[]; st.crimeEvents=[]; st.stationDispatches={};
  st.powerShortageBuildings={};
  st.waterShortageBuildings={};
  for (let y=0; y<GR_SZ; y++) {
    const r=[], vr=[], cr=[];
    for (let x=0; x<GR_SZ; x++) { r.push({type:'empty',age:0,level:0,w:1,h:1,buildingId:null}); vr.push(50); cr.push(30); }
    st.grid.push(r); st.landValue.push(vr); st.crime.push(cr);
  }
  initPowerGrid();
  initWaterGrid();
}

// ===== Save/Load =====
function sv() { try { localStorage.setItem('simcity_state',JSON.stringify(st)); } catch(e) {} }
function ld() {
  try {
    const s=localStorage.getItem('simcity_state');
    if (s) {
      const p=JSON.parse(s);
        if (p.grid && p.grid.length===GR_SZ) {
        st=p;
        if (!st.rDemand) st.rDemand=50; if (!st.cDemand) st.cDemand=50; if (!st.iDemand) st.iDemand=50;
        if (!st.year) st.year=1950; if (!st.newsEvents) st.newsEvents=[]; if (!st.ticksSinceNews) st.ticksSinceNews=0;
        if (st.taxRate===undefined) st.taxRate=10; // Default 10% tax rate
        if (!st.terrain) st.terrain=genTerr('balanced'); if (!st.landValue) { st.landValue=[]; for (let y=0; y<GR_SZ; y++) { const vr=[]; for (let x=0; x<GR_SZ; x++) vr.push(50); st.landValue.push(vr); } }
        if (!st.crime) { st.crime=[]; for (let y=0; y<GR_SZ; y++) { const cr=[]; for (let x=0; x<GR_SZ; x++) cr.push(30); st.crime.push(cr); } }
          if (!st.fires) st.fires=[]; if (!st.employment) st.employment=0; if (!st.cars) st.cars=[]; if (!st.crimeEvents) st.crimeEvents=[];
          st.stationDispatches={};
          if (st.cars && st.cars.length>0) {
            st.cars.forEach(car => {
              if (car.stationKey) incrementStationDispatchCount(car.stationKey);
            });
          }
        if (!st.zoom) st.zoom=1;
        if (st.disastersEnabled === undefined) st.disastersEnabled = true;
        if (!st.powerGrid) initPowerGrid();
        if (!st.waterGrid) initWaterGrid();
        if (!st.powerShortageBuildings || typeof st.powerShortageBuildings !== 'object') {
          st.powerShortageBuildings = {};
        }
        if (!st.waterShortageBuildings || typeof st.waterShortageBuildings !== 'object') {
          st.waterShortageBuildings = {};
        }
        for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) { 
          if (!st.grid[y][x].level) st.grid[y][x].level=0; 
          if (!st.grid[y][x].w) st.grid[y][x].w=1; 
          if (!st.grid[y][x].h) st.grid[y][x].h=1; 
          // Normalize empty cells to ensure they're always 1x1
          if (st.grid[y][x].type==='empty') normalizeEmptyCell(x,y);
        }

        // Rebuild buildingId metadata after loading to ensure consistent grouping
        rebuildBuildingIdsFromGrid();
        // Recalculate power grid after loading
        calculatePowerGrid();
  calculateWaterGrid();
        return true;
      }
    }
  } catch(e) {}
  return false;
}

// ===== Rendering =====
function isRd(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].type==='road'; }
function getRdNb(x,y) { return {top:isRd(x,y-1),right:isRd(x+1,y),bottom:isRd(x,y+1),left:isRd(x-1,y)}; }
function isPipe(x,y) { if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false; return st.grid[y][x].pipe === true; }
function getPipeNb(x,y) { return {top:isPipe(x,y-1),right:isPipe(x+1,y),bottom:isPipe(x,y+1),left:isPipe(x-1,y)}; }

function drRd(px,py,nb) {
  ctx.fillStyle='#3a3a3a'; ctx.fillRect(px,py,CL_SZ,CL_SZ);
  const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);
  ctx.fillStyle='#4a4a4a';
  if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }
  else if (rc===3) {
    if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }
    else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }
    else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }
    else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
  } else if (rc===2) {
    if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
    else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }
    else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
    else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
    else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }
    else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }
  } else if (rc===1) {
    if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
    else { ctx.fillRect(px,py+6,CL_SZ,4); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+4,py+7,2,2); ctx.fillRect(px+CL_SZ-6,py+7,2,2); }
  } else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillStyle='#5a5a5a'; ctx.fillRect(px+7,py+4,2,2); ctx.fillRect(px+7,py+CL_SZ-6,2,2); }
}

function drTl(x,y,tp,lv,ab,w,h) {
  const px=x*CL_SZ, py=y*CL_SZ, wd=w*CL_SZ, ht=h*CL_SZ, tr=st.terrain[y][x];
  const c = st.grid[y][x];
  
  // Check if building needs power but doesn't have it
  let needsPowerButNoPower = false;
  let needsWaterButNoWater = false;
  if (!ab && (tp === 'residential' || tp === 'commercial' || tp === 'industrial')) {
    const level = lv || 0;
    let needsPower = false;
    if (tp === 'residential' && (level === 2 || level === 3)) {
      needsPower = true;
    } else if (tp === 'commercial' || tp === 'industrial') {
      needsPower = true;
    }
    if (needsPower) {
        const hasPower = buildingHasPower(x, y);
      if (!hasPower) {
        needsPowerButNoPower = true;
      }
    }
    // Check water - all buildings with level >= 1 need water
    if (level >= 1) {
      const hasWater = buildingHasWater(x, y);
      if (!hasWater) {
        needsWaterButNoWater = true;
      }
    }
  }
  if (tp==='empty') {
    if (tr==='water') ctx.fillStyle='#1e40af'; 
    else if (tr==='cliff') ctx.fillStyle='#3e2723'; 
    else ctx.fillStyle='#2d5016';
    ctx.fillRect(px,py,CL_SZ,CL_SZ);
  } else if (tp==='road') { 
    const nb=getRdNb(x,y); drRd(px,py,nb); 
  }
  
  // Draw pipes on top of existing tiles (overlay) - but only for single tiles
  // For multi-tile buildings, pipes will be drawn in a separate pass after all buildings
  const shouldDrawPipeOverlay = c.pipe && showWaterOverlay && (w === 1 && h === 1);
  if (shouldDrawPipeOverlay) {
    const nb=getPipeNb(x,y);
    const ht=nb.top,hr=nb.right,hb=nb.bottom,hl=nb.left, rc=(ht?1:0)+(hr?1:0)+(hb?1:0)+(hl?1:0);
    ctx.fillStyle='rgba(96,165,250,0.4)'; // Brighter blue with higher opacity
    ctx.fillRect(px,py,CL_SZ,CL_SZ);
    ctx.fillStyle='rgba(59,130,246,0.7)'; // Brighter blue for pipe connections
    
    // Draw pipe connections similar to roads
    if (rc===4) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,CL_SZ,4); }
    else if (rc===3) {
      if (!ht) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,CL_SZ,4); }
      else if (!hr) { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px,py+6,10,4); }
      else if (!hb) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,CL_SZ,4); }
      else { ctx.fillRect(px+6,py,4,CL_SZ); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
    } else if (rc===2) {
      if ((ht&&hb)||(!hl&&!hr)) { ctx.fillRect(px+6,py,4,CL_SZ); }
      else if ((hl&&hr)||(!ht&&!hb)) { ctx.fillRect(px,py+6,CL_SZ,4); }
      else if (ht&&hr) { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
      else if (hr&&hb) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px+6,py+6,CL_SZ-6,4); }
      else if (hb&&hl) { ctx.fillRect(px+6,py+6,4,CL_SZ-6); ctx.fillRect(px,py+6,10,4); }
      else { ctx.fillRect(px+6,py,4,10); ctx.fillRect(px,py+6,10,4); }
    } else if (rc===1) {
      if (ht||hb) { ctx.fillRect(px+6,py,4,CL_SZ); }
      else { ctx.fillRect(px,py+6,CL_SZ,4); }
    } else { ctx.fillRect(px+6,py,4,CL_SZ); }
  }
  else if (tp==='residential') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(74,124,89,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-6, bh=ht-6; 
      ctx.fillRect(px+3,py+5,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+3,py+5,bw,Math.floor(bh*0.25)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+5,py+Math.floor(5+bh*0.35),2,2); 
      ctx.fillRect(px+9,py+Math.floor(5+bh*0.35),2,2); 
      if (w===2) ctx.fillRect(px+20,py+Math.floor(5+bh*0.35),2,2); 
    }
    else {
      // For 2x2 buildings, make them grow taller with level
      const sz=w===2&&h===2?(lv===3?wd-3:(lv===2?wd-3.5:wd-4)):w===2?wd-4:(lv===1?8:(lv===3?10:10));
      const of=w===2&&h===2?(lv===3?1.5:(lv===2?1.75:2)):w===2?2:(lv===1?4:(lv===3?3:3));
      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-7)):w===2?ht-7:(lv===1?8:(lv===3?12:(lv===2?14:11)));
      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:6)):w===1&&h===1?(lv===3?2:(lv===2?1:7)):6;
      ctx.fillStyle=w===2&&h===2?(lv===3?'#22c55e':(lv===2?'#16a34a':'#15803d')):w===2?'#16a34a':(lv===3?'#1a9e4a':(lv===2?'#16a34a':'#15803d')); 
      ctx.fillRect(px+of,py+yo,sz,bh);
      ctx.fillStyle=w===2&&h===2?(lv===3?'#16a34a':(lv===2?'#15803d':'#166534')):w===2?'#15803d':(lv===3?'#15803d':'#15803d'); 
      const roofHeight=w===2&&h===2&&lv===1?0.18:0.25;
      ctx.fillRect(px+of,py+yo,sz,Math.floor(bh*roofHeight));
      if (lv>=2 || w===2) {
        ctx.fillStyle='#4ade80';
        const wh=2, ww=2, gap=1;
        const floors=w===2&&h===2?(lv===3?4:(lv===2?3:2)):w===2&&h===1?1:(lv===3?2:(lv===2?2:1));
        const winStart=w===2&&h===2?0.35:0.4;
        for (let f=0; f<floors; f++) {
          const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));
          ctx.fillRect(px+5,wy,ww,wh); 
          ctx.fillRect(px+9,wy,ww,wh);
          if (w===2) { 
            ctx.fillRect(px+20,wy,ww,wh); 
            ctx.fillRect(px+24,wy,ww,wh); 
          }
        }
      } else if (lv===1) {
        ctx.fillStyle='#4ade80';
        const winStart=w===2&&h===2?0.35:0.4;
        const wy = py+Math.floor(yo+bh*winStart);
        ctx.fillRect(px+5,wy,2,2); 
        ctx.fillRect(px+9,wy,2,2);
      }
      ctx.fillStyle='#166534'; 
      if (w===1&&h===1&&lv===1) {
        ctx.fillRect(px+7,py+ht-3,2,3);
      } else if (w===1&&h===2) {
        // For 1x2 buildings, position door at bottom of building, centered
        ctx.fillRect(px+7,py+yo+bh-3,2,3);
      } else {
        ctx.fillRect(px+6,py+ht-3,3,3); 
      }
      if (w===2) ctx.fillRect(px+21,py+ht-3,3,3);
      // Add yard decorations for 1x2 tiles
      if (w===1&&h===2&&!ab) {
        ctx.fillStyle='#15803d';
        ctx.fillRect(px+3,py+ht-6,2,2); // Small bush left
        ctx.fillRect(px+11,py+ht-6,2,2); // Small bush right
        // Add more for higher levels
        if (lv>=2) {
          ctx.fillStyle='#16a34a';
          ctx.fillRect(px+1,py+ht-8,2,2); // Extra bush left
          ctx.fillRect(px+13,py+ht-8,2,2); // Extra bush right
        }
        if (lv>=3) {
          ctx.fillStyle='#4ade80';
          ctx.fillRect(px+7,py+ht-7,2,1); // Accent center
        }
      }
    }
  } else if (tp==='commercial') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(74,107,138,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-4, bh=ht-4; 
      ctx.fillRect(px+2,py+4,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+2,py+4,bw,Math.floor(bh*0.25)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+4,py+Math.floor(4+bh*0.4),3,3); 
      ctx.fillRect(px+9,py+Math.floor(4+bh*0.4),3,3); 
      if (w===2) ctx.fillRect(px+20,py+Math.floor(4+bh*0.4),3,3); 
    }
    else {
      // For 2x2 buildings, make them grow taller with level
      const bh=w===2&&h===2?(lv===3?ht-4:(lv===2?ht-5:ht-9)):w===2||h===2?ht-3:(lv===1?9:(lv===2?11:13));
      const yo=w===2&&h===2?(lv===3?3:(lv===2?4:8)):w===2||h===2?2:(lv===1?6:(lv===2?4:1));
      ctx.fillStyle=w===2&&h===2?(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')):w===2||h===2?'#2563eb':(lv===3?'#3b82f6':(lv===2?'#2563eb':'#1e40af')); 
      ctx.fillRect(px+2,py+yo,wd-4,bh);
      ctx.fillStyle=w===2&&h===2?(lv===3?'#2563eb':(lv===2?'#1e40af':'#1d4ed8')):w===2||h===2?'#1e40af':(lv===3?'#2563eb':'#1e40af'); 
      ctx.fillRect(px+2,py+yo,wd-4,Math.floor(bh*0.25));
      ctx.fillStyle='#87ceeb';
      const wh=3, ww=3, gap=1;
      const floors=w===2&&h===2?(lv===3?3:(lv===2?3:1)):w===2&&h===1?1:(w===2||h===2?2:1);
      const winStart=w===2&&h===2?0.35:0.4;
      for (let f=0; f<floors; f++) {
        const wy = py+Math.floor(yo+bh*winStart)+(f*(wh+gap+1));
        ctx.fillRect(px+4,wy,ww,wh); 
        ctx.fillRect(px+9,wy,ww,wh);
        if (w===2) { 
          ctx.fillRect(px+20,wy,ww,wh); 
          ctx.fillRect(px+25,wy,ww,wh); 
        }
      }
      ctx.fillStyle='#1e3a8a'; 
      ctx.fillRect(px+6,py+ht-4,4,4); 
      if (w===2) ctx.fillRect(px+22,py+ht-4,4,4);
    }
  } else if (tp==='industrial') {
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    if (lv===0) { 
      ctx.fillStyle='rgba(138,124,74,0.5)';
      const squareSize = Math.min(wd, ht) - 4;
      const squareX = px + (wd - squareSize) / 2;
      const squareY = py + (ht - squareSize) / 2;
      ctx.fillRect(squareX, squareY, squareSize, squareSize); 
    }
    else if (ab) { 
      ctx.fillStyle='#4a4a4a'; 
      const bw=wd-4, bh=ht-6; 
      ctx.fillRect(px+2,py+6,bw,bh); 
      ctx.fillStyle='#3a3a3a'; 
      ctx.fillRect(px+2,py+6,bw,Math.floor(bh*0.4)); 
      ctx.fillStyle='#2a2a2a'; 
      ctx.fillRect(px+5,py+11,2,2); 
      ctx.fillRect(px+9,py+11,2,2); 
      if (w===2) ctx.fillRect(px+21,py+11,2,2); 
    }
    else {
      // For 2x2 buildings, grow taller with level
      const bh=w===2&&h===2?(lv===3?ht-2:(lv===2?ht-3:ht-4)):w===2?ht-4:(lv===1?8:(lv===2?10:11));
      const yo=w===2&&h===2?(lv===3?2:(lv===2?2.5:3)):w===2?3:(lv===1?5:(lv===2?4:3));
      // Main building body
      ctx.fillStyle=w===2&&h===2?(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')):w===2?'#ca8a04':(lv===3?'#eab308':(lv===2?'#ca8a04':'#a16207')); 
      ctx.fillRect(px+2,py+yo+1,wd-4,bh);
      // Slanted roof (darker top section)
      ctx.fillStyle=w===2&&h===2?(lv===3?'#ca8a04':(lv===2?'#a16207':'#854d0e')):w===2?'#a16207':(lv===3?'#ca8a04':'#854d0e'); 
      ctx.fillRect(px+2,py+yo+1,wd-4,Math.floor(bh*0.25));
      // Chimney structure
      ctx.fillStyle='#6b4423'; 
      const ch=w===2&&h===2?(lv===3?8:(lv===2?7:6)):lv===3?6:5; 
      ctx.fillRect(px+4,py+yo-ch+1,2,ch); 
      if (w===2) ctx.fillRect(px+26,py+yo-ch+1,2,ch);
      // Chimney top cap
      ctx.fillStyle='#854d0e'; 
      ctx.fillRect(px+3,py+yo-ch+1,4,1); 
      if (w===2) ctx.fillRect(px+25,py+yo-ch+1,4,1);
      // Smoke from chimney
      ctx.fillStyle='#9ca3af'; 
      ctx.fillRect(px+4,py+yo-ch,1,1); 
      ctx.fillRect(px+5,py+yo-ch-1,1,1); 
      if (w===2) { 
        ctx.fillRect(px+26,py+yo-ch,1,1); 
        ctx.fillRect(px+27,py+yo-ch-1,1,1); 
      }
      // Windows
      ctx.fillStyle='#fde047'; 
      if (w===2 && h===2) {
        // More windows for higher level 2x2 buildings
        const rows=lv===3?3:(lv===2?2:2);
        for (let r=0; r<rows; r++) {
          const wy = py+yo+Math.floor(bh*0.35)+(r*5);
          ctx.fillRect(px+5,wy,2,2); 
          ctx.fillRect(px+9,wy,2,2); 
          ctx.fillRect(px+21,wy,2,2); 
          ctx.fillRect(px+25,wy,2,2);
        }
      } else {
        // Single row of windows for smaller buildings
        ctx.fillRect(px+5,py+yo+Math.floor(bh*0.55),2,2); 
        ctx.fillRect(px+9,py+yo+Math.floor(bh*0.55),2,2); 
        if (w===2) { 
          ctx.fillRect(px+21,py+yo+Math.floor(bh*0.55),2,2); 
          ctx.fillRect(px+25,py+yo+Math.floor(bh*0.55),2,2); 
        }
      }
      // Entrance/door
      ctx.fillStyle='#713f12'; 
      ctx.fillRect(px+6,py+ht-3,4,3); 
      if (w===2) ctx.fillRect(px+22,py+ht-3,4,3);
    }
  } else if (tp.startsWith('park')) {
    const bc=tp==='park'?'#1d6b2e':(tp==='park2'?'#2a5a3a':(tp==='park3'?'#1a5a2a':'#2d6b1e'));
    ctx.fillStyle=bc; ctx.fillRect(px,py,wd,ht);
    if (tp==='park') { 
      ctx.fillStyle='#2a8f3f'; 
      ctx.fillRect(px+4,py+3,3,3); 
      ctx.fillRect(px+9,py+8,3,3); 
      if (w===2||h===2) { 
        ctx.fillRect(px+20,py+5,3,3); 
        ctx.fillRect(px+15,py+20,3,3); 
      } 
      ctx.fillStyle='#165a24'; 
      ctx.fillRect(px+2,py+9,2,2); 
      ctx.fillRect(px+11,py+4,2,2); 
      ctx.fillStyle='#6b4423'; 
      ctx.fillRect(px+7,py+6,2,4); 
      if (w===2||h===2) ctx.fillRect(px+23,py+10,2,4); 
    }
    else if (tp==='park2') { 
      ctx.fillStyle='#ff69b4'; 
      ctx.fillRect(px+4,py+4,2,2); 
      ctx.fillRect(px+9,py+7,2,2); 
      ctx.fillRect(px+6,py+10,2,2); 
      if (w===2||h===2) { 
        ctx.fillRect(px+20,py+6,2,2); 
        ctx.fillRect(px+25,py+9,2,2); 
        ctx.fillRect(px+17,py+20,2,2); 
      } 
      ctx.fillStyle='#ffc0cb'; 
      ctx.fillRect(px+11,py+5,1,1); 
      ctx.fillRect(px+3,py+8,1,1); 
    }
    else if (tp==='park3') { 
      ctx.fillStyle='#2d5016'; 
      ctx.fillRect(px+5,py+2,3,4); 
      ctx.fillRect(px+10,py+8,3,4); 
      if (w===2||h===2) { 
        ctx.fillRect(px+21,py+4,3,4); 
        ctx.fillRect(px+16,py+20,3,4); 
      } 
      ctx.fillStyle='#1a4010'; 
      ctx.fillRect(px+3,py+10,2,3); 
      ctx.fillRect(px+12,py+5,2,3); 
    }
    else { 
      ctx.fillStyle='#ffd700'; 
      ctx.fillRect(px+5,py+5,3,3); 
      ctx.fillRect(px+10,py+9,3,3); 
      if (w===2||h===2) { 
        ctx.fillRect(px+21,py+7,3,3); 
        ctx.fillRect(px+16,py+20,3,3); 
      } 
      ctx.fillStyle='#8b4513'; 
      ctx.fillRect(px+6,py+8,1,3); 
      ctx.fillRect(px+11,py+12,1,3); 
    }
  } else if (tp==='police') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#000080'; ctx.fillRect(px+2,py+6,12,10); 
    ctx.fillStyle='#0000a0'; ctx.fillRect(px+2,py+6,12,4); 
    ctx.fillStyle='#ff0000'; ctx.fillRect(px+6,py+7,4,1); 
    ctx.fillStyle='#0000ff'; ctx.fillRect(px+6,py+8,4,1); 
    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+13,4,3); 
  }
  else if (tp==='fire') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#8b0000'; ctx.fillRect(px+2,py+6,12,10); 
    ctx.fillStyle='#a00000'; ctx.fillRect(px+2,py+6,12,4); 
    ctx.fillStyle='#5a2a2a'; ctx.fillRect(px+6,py+13,4,3);
    
    // Animated flame on top
    const flameAnim = (Date.now() / 150) % 6;
    const flameFrame = Math.floor(flameAnim);
    
    // Base flame (orange/red) - flickers
    const baseHeight = flameFrame < 3 ? 3 : 2;
    ctx.fillStyle = flameFrame % 2 === 0 ? '#ff4500' : '#ff6600';
    ctx.beginPath();
    ctx.moveTo(px+6, py+8);
    ctx.lineTo(px+7, py+8-baseHeight);
    ctx.lineTo(px+8, py+8-baseHeight+1);
    ctx.lineTo(px+9, py+8-baseHeight);
    ctx.lineTo(px+10, py+8);
    ctx.lineTo(px+8, py+9);
    ctx.closePath();
    ctx.fill();
    
    // Inner flame (yellow) - smaller flicker
    const innerHeight = flameFrame < 2 ? 2 : 1;
    ctx.fillStyle = flameFrame < 4 ? '#ffd700' : '#ffaa00';
    ctx.beginPath();
    ctx.moveTo(px+7, py+8);
    ctx.lineTo(px+8, py+8-innerHeight);
    ctx.lineTo(px+9, py+8);
    ctx.lineTo(px+8, py+9);
    ctx.closePath();
    ctx.fill();
    
    // Hot core (white/yellow)
    if (flameFrame < 3) {
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(px+8, py+7, 1, 1);
    }
  }
  else if (tp==='school') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#daa520'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#b8860b'; ctx.fillRect(px+2,py+4,12,4); 
    ctx.fillStyle='#87ceeb'; ctx.fillRect(px+9,py+10,3,3); 
    ctx.fillStyle='#8b4513'; ctx.fillRect(px+4,py+11,3,3); 
  }
  else if (tp==='hospital') { 
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ); 
    ctx.fillStyle='#d1d5db'; ctx.fillRect(px+2,py+4,12,10); 
    ctx.fillStyle='#ff0000'; ctx.fillRect(px+7,py+5,2,5); ctx.fillRect(px+5,py+6,6,2); 
    ctx.fillStyle='#4a4a4a'; ctx.fillRect(px+6,py+11,4,3); 
  }
  else if (tp==='coal') {
    // Background - industrial ground
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-4,wd-2,3);
    
    // Main building - dark brown brick structure (2x2)
    ctx.fillStyle='#5a3a2a'; ctx.fillRect(px+3,py+12,wd-6,ht-13);
    
    // Darker roof
    ctx.fillStyle='#3a2a1a'; ctx.fillRect(px+3,py+12,wd-6,4);
    
    // Two smaller brick smoke stacks
    ctx.fillStyle='#5a3a2a'; 
    ctx.fillRect(px+8,py+6,2,7);
    ctx.fillRect(px+22,py+6,2,7);
    
    // Stack tops/caps
    ctx.fillStyle='#6a6a6a';
    ctx.fillRect(px+7,py+6,4,1);
    ctx.fillRect(px+21,py+6,4,1);
    
    // Animated smoke from stacks
    const smokeAnim = (Date.now() / 300) % 4; // Animate every 300ms
    const smokeOffset1 = Math.floor(smokeAnim);
    const smokeOffset2 = Math.floor((smokeAnim + 2) % 4);
    
    // Smoke from left stack
    ctx.fillStyle='rgba(80,80,80,0.6)'; 
    ctx.fillRect(px+8,py+4-smokeOffset1,2,2);
    ctx.fillStyle='rgba(100,100,100,0.4)';
    ctx.fillRect(px+7,py+2-smokeOffset1,3,2);
    ctx.fillStyle='rgba(120,120,120,0.2)';
    ctx.fillRect(px+6,py+1-smokeOffset1,4,1);
    
    // Smoke from right stack
    ctx.fillStyle='rgba(80,80,80,0.6)'; 
    ctx.fillRect(px+22,py+4-smokeOffset2,2,2);
    ctx.fillStyle='rgba(100,100,100,0.4)';
    ctx.fillRect(px+21,py+2-smokeOffset2,3,2);
    ctx.fillStyle='rgba(120,120,120,0.2)';
    ctx.fillRect(px+20,py+1-smokeOffset2,4,1);
    
    // Windows (dark) - moved down
    ctx.fillStyle='#2a2a2a'; 
    ctx.fillRect(px+6,py+18,2,2);
    ctx.fillRect(px+12,py+18,2,2);
    ctx.fillRect(px+18,py+18,2,2);
    ctx.fillRect(px+24,py+18,2,2);
    ctx.fillRect(px+6,py+24,2,2);
    ctx.fillRect(px+12,py+24,2,2);
    ctx.fillRect(px+18,py+24,2,2);
    ctx.fillRect(px+24,py+24,2,2);
    
    // Door at bottom center
    ctx.fillStyle='#1a1a1a';
    ctx.fillRect(px+14,py+ht-4,4,3);
  }
  else if (tp==='nuclear') {
    // Background - concrete pad
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    ctx.fillStyle='#6a6a6a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);
    
    // Animated steam from cooling tower (draw FIRST, behind dome)
    const steamAnim = (Date.now() / 400) % 5;
    const steamOffset = Math.floor(steamAnim);
    
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fillRect(px+14,py+6-steamOffset,6,3);
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.fillRect(px+13,py+3-steamOffset,8,3);
    ctx.fillStyle='rgba(255,255,255,0.3)';
    ctx.fillRect(px+12,py+1-steamOffset,10,2);
    
    // Large cooling tower dome (2x2) - gray (draw AFTER steam)
    ctx.fillStyle='#8a8a8a'; 
    ctx.beginPath(); 
    ctx.arc(px+wd/2,py+14,9,0,Math.PI*2); 
    ctx.fill();
    // Shading on dome
    ctx.fillStyle='#6a6a6a';
    ctx.beginPath();
    ctx.arc(px+wd/2,py+14,9,Math.PI*0.3,Math.PI*0.7);
    ctx.fill();
    
    // Cooling tower base
    ctx.fillStyle='#7a7a7a'; 
    ctx.fillRect(px+7,py+21,wd-14,7);
    
    // Reactor containment building (left) - gray
    ctx.fillStyle='#7a7a7a'; 
    ctx.fillRect(px+2,py+18,12,10);
    ctx.fillStyle='#6a6a6a';
    ctx.fillRect(px+2,py+18,12,4);
    
    // Control building (right) - gray
    ctx.fillStyle='#8a8a8a';
    ctx.fillRect(px+wd-13,py+20,11,8);
    ctx.fillStyle='#7a7a7a';
    ctx.fillRect(px+wd-13,py+20,11,3);
    
    // White line accents on buildings
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=1;
    // Vertical lines on reactor
    ctx.beginPath();
    ctx.moveTo(px+6,py+18);
    ctx.lineTo(px+6,py+28);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px+10,py+18);
    ctx.lineTo(px+10,py+28);
    ctx.stroke();
    // Horizontal line on control building
    ctx.beginPath();
    ctx.moveTo(px+wd-13,py+23);
    ctx.lineTo(px+wd-2,py+23);
    ctx.stroke();
    
    // Dark windows
    ctx.fillStyle='#2a2a2a';
    ctx.fillRect(px+4,py+22,2,2);
    ctx.fillRect(px+8,py+22,2,2);
    ctx.fillRect(px+wd-10,py+23,2,2);
    ctx.fillRect(px+wd-6,py+23,2,2);
  }
  else if (tp==='waterplant') {
    // Water treatment plant - 2x2 building with realistic clarifier pools
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    ctx.fillStyle='#3b82f6'; ctx.fillRect(px+1,py+ht-3,wd-2,2);
    
    // Calculate rotation angle for pools - using wind turbine animation pattern
    const rotationSpeed1 = 0.00125; // Slow rotation - 4x slower than before
    const rotationSpeed2 = 0.001; // Slightly different speed
    const angle1 = (Date.now() * rotationSpeed1) % (Math.PI * 2);
    const angle2 = (Date.now() * rotationSpeed2) % (Math.PI * 2);
    
    // Left clarifier pool (large circular pool)
    const pool1CenterX = px + 11;
    const pool1CenterY = py + 9;
    const pool1Radius = 7;
    
    // Pool 1 - outer concrete rim (blue)
    ctx.fillStyle='#60a5fa';
    ctx.beginPath();
    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 1 - water (deep blue)
    ctx.fillStyle='#1e40af';
    ctx.beginPath();
    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius - 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 1 - water surface reflection (lighter blue with gradient effect)
    ctx.fillStyle='#2563eb';
    ctx.beginPath();
    ctx.arc(pool1CenterX, pool1CenterY, pool1Radius - 2.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 1 - rotating arm (clarifier rake)
    ctx.save();
    ctx.translate(pool1CenterX, pool1CenterY);
    ctx.rotate(angle1);
    ctx.fillStyle='#d0d0d0';
    ctx.fillRect(-1, -0.5, pool1Radius - 2, 1); // Arm
    ctx.fillStyle='#b0b0b0';
    ctx.beginPath();
    ctx.arc(0, 0, 1.5, 0, Math.PI * 2); // Center hub
    ctx.fill();
    ctx.restore();
    
    // Right clarifier pool (large circular pool)
    const pool2CenterX = px + 23;
    const pool2CenterY = py + 21;
    const pool2Radius = 7;
    
    // Pool 2 - outer concrete rim (blue)
    ctx.fillStyle='#60a5fa';
    ctx.beginPath();
    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 2 - water (deep blue)
    ctx.fillStyle='#1e40af';
    ctx.beginPath();
    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius - 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 2 - water surface reflection (lighter blue)
    ctx.fillStyle='#2563eb';
    ctx.beginPath();
    ctx.arc(pool2CenterX, pool2CenterY, pool2Radius - 2.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Pool 2 - rotating arm (clarifier rake) - rotates opposite direction
    ctx.save();
    ctx.translate(pool2CenterX, pool2CenterY);
    ctx.rotate(-angle2);
    ctx.fillStyle='#d0d0d0';
    ctx.fillRect(-1, -0.5, pool2Radius - 2, 1); // Arm
    ctx.fillStyle='#b0b0b0';
    ctx.beginPath();
    ctx.arc(0, 0, 1.5, 0, Math.PI * 2); // Center hub
    ctx.fill();
    ctx.restore();
    
    // Small control building on the left side - drawn AFTER pools so it appears in front (blue)
    ctx.fillStyle='#3b82f6'; ctx.fillRect(px+3,py+ht-12,11,11);
    ctx.fillStyle='#2563eb'; ctx.fillRect(px+3,py+ht-12,11,3);
    ctx.fillStyle='#1e40af';
    ctx.fillRect(px+5,py+ht-8,2,2);
    ctx.fillRect(px+9,py+ht-8,2,2);
  }
  else if (tp==='watertower') {
    // Water tower - elevated tank on support structure
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,CL_SZ,CL_SZ);
    
    // Support structure (metal frame)
    ctx.fillStyle='#5a5a5a';
    ctx.fillRect(px+6,py+8,4,8); // Center column
    
    // Support legs
    ctx.fillStyle='#4a4a4a';
    ctx.fillRect(px+4,py+12,2,4);
    ctx.fillRect(px+10,py+12,2,4);
    
    // Cross braces
    ctx.fillRect(px+5,py+10,6,1);
    ctx.fillRect(px+5,py+14,6,1);
    
    // Large water tank on top
    ctx.fillStyle='#6a6a6a'; // Tank body
    ctx.beginPath();
    ctx.arc(px+8,py+6,5,0,Math.PI*2);
    ctx.fill();
    
    // Water inside tank (visible) - bright blue
    ctx.fillStyle='#2563eb';
    ctx.beginPath();
    ctx.arc(px+8,py+7,3.5,0,Math.PI*2);
    ctx.fill();
    
    // Water surface reflection (lighter)
    ctx.fillStyle='#3b82f6';
    ctx.fillRect(px+5,py+6,6,1);
    
    // Tank rim/top
    ctx.fillStyle='#7a7a7a';
    ctx.fillRect(px+3,py+4,10,2);
    
    // Access ladder
    ctx.fillStyle='#3a3a3a';
    ctx.fillRect(px+11,py+8,1,8);
    ctx.fillRect(px+10,py+10,2,1);
    ctx.fillRect(px+10,py+12,2,1);
    ctx.fillRect(px+10,py+14,2,1);
  }
  else if (tp==='wind') {
    // Background - grass with service road
    ctx.fillStyle='#2d5016'; ctx.fillRect(px,py,wd,ht);
    ctx.fillStyle='#4a4a3a'; ctx.fillRect(px+1,py+ht-3,wd-2,2);
    
    // Thin tall tower (1x2 building, so ht = 32)
    ctx.fillStyle='#d0d0d0'; 
    // Thin tower that gets slightly wider at bottom
    ctx.fillRect(px+7,py+6,2,ht-9);
    ctx.fillRect(px+6,py+ht-8,4,5);
    
    // Tower shading
    ctx.fillStyle='#b0b0b0';
    ctx.fillRect(px+7,py+6,1,ht-9);
    
    // Concrete base
    ctx.fillStyle='#8a8a8a';
    ctx.fillRect(px+5,py+ht-3,6,2);
    
    // Hub at top
    const hubX = px+8;
    const hubY = py+6;
    ctx.fillStyle='#c0c0c0';
    ctx.beginPath();
    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);
    ctx.fill();
    
    // Rotating turbine blades
    // Use Date.now() for smooth continuous animation
    const rotationSpeed = 0.002; // Adjust for faster/slower rotation
    const rotation = (Date.now() * rotationSpeed) % (Math.PI * 2);
    
    ctx.save();
    ctx.translate(hubX, hubY);
    ctx.rotate(rotation);
    
    // Three large turbine blades (white) - drawn at 120 degree intervals
    ctx.fillStyle='#ffffff';
    ctx.strokeStyle='#b0b0b0';
    ctx.lineWidth=0.8;
    
    for (let i=0; i<3; i++) {
      ctx.save();
      ctx.rotate((i * Math.PI * 2 / 3));
      // Blade pointing upward
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-1, -6);
      ctx.lineTo(1, -6);
      ctx.lineTo(0, 0);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    
    ctx.restore();
    
    // Redraw hub on top of blades
    ctx.fillStyle='#c0c0c0';
    ctx.beginPath();
    ctx.arc(hubX,hubY,1.5,0,Math.PI*2);
    ctx.fill();
  }
  ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,wd,ht);
  
  // Draw power/water warning indicators if building needs them but doesn't have them
  if (needsPowerButNoPower && !ab) {
    // Flash effect - show bolt every other half-second
    const flashOn = Math.floor(Date.now() / 500) % 2 === 0;
    if (flashOn) {
      ctx.save();
      // Draw a yellow lightning bolt in the top-right corner
      const indicatorSize = 10;
      const indicatorX = px + wd - indicatorSize - 1;
      const indicatorY = py + 1;
      
      // Draw yellow lightning bolt
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      // Lightning bolt shape
      ctx.moveTo(indicatorX + indicatorSize/2 + 2, indicatorY);
      ctx.lineTo(indicatorX + indicatorSize/2 - 2, indicatorY + indicatorSize/2);
      ctx.lineTo(indicatorX + indicatorSize/2 + 1, indicatorY + indicatorSize/2);
      ctx.lineTo(indicatorX + indicatorSize/2 - 3, indicatorY + indicatorSize);
      ctx.lineTo(indicatorX + indicatorSize/2 + 2, indicatorY + indicatorSize/2 + 2);
      ctx.lineTo(indicatorX + indicatorSize/2 - 1, indicatorY + indicatorSize/2 + 2);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  if (needsWaterButNoWater && !ab) {
    // Animated water drop indicator - drips down
    const dropAnim = (Date.now() / 400) % 4; // 4-frame animation
    const dropFrame = Math.floor(dropAnim);
    
    ctx.save();
    const indicatorX = px + 2;
    const indicatorY = py + 2;
    
    // Water drop animates falling down
    const yOffset = dropFrame; // 0, 1, 2, 3 pixels down
    const dropY = indicatorY + yOffset;
    
    // Draw water drop shape (teardrop)
    if (dropFrame < 3) {
      // Main drop body (bright blue matching water tile hue)
      ctx.fillStyle = dropFrame % 2 === 0 ? '#3b82f6' : '#60a5fa';
      ctx.beginPath();
      // Top curve
      ctx.arc(indicatorX + 3, dropY + 2, 2.5, Math.PI, 0, false);
      // Point at bottom
      ctx.lineTo(indicatorX + 5.5, dropY + 6);
      ctx.lineTo(indicatorX + 3, dropY + 7);
      ctx.lineTo(indicatorX + 0.5, dropY + 6);
      ctx.closePath();
      ctx.fill();
      
      // Highlight/shine
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(indicatorX + 2, dropY + 3, 1, 2);
    } else {
      // Splash effect at bottom (frame 3)
      ctx.fillStyle = '#3b82f6';
      // Small splash particles
      ctx.fillRect(indicatorX, dropY + 6, 2, 1);
      ctx.fillRect(indicatorX + 4, dropY + 6, 2, 1);
      ctx.fillRect(indicatorX + 2, dropY + 5, 2, 1);
    }
    
    ctx.restore();
  }
}

function drGr() {
  ctx.clearRect(0,0,cvs.width,cvs.height); const drn={};
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const k=`${x},${y}`; if (drn[k]) continue;
    const c=st.grid[y][x]; drTl(x,y,c.type,c.level||0,c.abandoned||false,c.w||1,c.h||1);
    for (let dy=0; dy<(c.h||1); dy++) for (let dx=0; dx<(c.w||1); dx++) drn[`${x+dx},${y+dy}`]=true;
  }
  
  // Draw pipes on multi-tile buildings after all buildings are drawn to avoid black tiles
  if (showWaterOverlay) {
    for (let y=0; y<GR_SZ; y++) {
      for (let x=0; x<GR_SZ; x++) {
        const c = st.grid[y][x];
        if (c.pipe && (c.w > 1 || c.h > 1)) {
          const px = x * CL_SZ, py = y * CL_SZ;
          const nb = getPipeNb(x, y);
          const ht = nb.top, hr = nb.right, hb = nb.bottom, hl = nb.left;
          const rc = (ht ? 1 : 0) + (hr ? 1 : 0) + (hb ? 1 : 0) + (hl ? 1 : 0);
          ctx.fillStyle = 'rgba(96,165,250,0.4)'; // Brighter blue with higher opacity
          ctx.fillRect(px, py, CL_SZ, CL_SZ);
          ctx.fillStyle = 'rgba(59,130,246,0.7)'; // Brighter blue for pipe connections
          
          // Draw pipe connections similar to roads
          if (rc === 4) { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px, py+6, CL_SZ, 4); }
          else if (rc === 3) {
            if (!ht) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px, py+6, CL_SZ, 4); }
            else if (!hr) { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px, py+6, 10, 4); }
            else if (!hb) { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px, py+6, CL_SZ, 4); }
            else { ctx.fillRect(px+6, py, 4, CL_SZ); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }
          } else if (rc === 2) {
            if ((ht && hb) || (!hl && !hr)) { ctx.fillRect(px+6, py, 4, CL_SZ); }
            else if ((hl && hr) || (!ht && !hb)) { ctx.fillRect(px, py+6, CL_SZ, 4); }
            else if (ht && hr) { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }
            else if (hr && hb) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px+6, py+6, CL_SZ-6, 4); }
            else if (hb && hl) { ctx.fillRect(px+6, py+6, 4, CL_SZ-6); ctx.fillRect(px, py+6, 10, 4); }
            else { ctx.fillRect(px+6, py, 4, 10); ctx.fillRect(px, py+6, 10, 4); }
          } else if (rc === 1) {
            if (ht || hb) { ctx.fillRect(px+6, py, 4, CL_SZ); }
            else { ctx.fillRect(px, py+6, CL_SZ, 4); }
          } else { ctx.fillRect(px+6, py, 4, CL_SZ); }
        }
      }
    }
  }
  
  if (showLandValueOverlay) drawLandValueOverlay();
  if (showCrimeOverlay) drawCrimeOverlay();
  if (showWaterOverlay) drawWaterOverlay();
  
  // Draw placement preview when hovering
  if (hoverPos && st.selectedTool && st.selectedTool !== 'bulldoze' && !showLandValueOverlay && !showCrimeOverlay) {
    const x = hoverPos.x, y = hoverPos.y;
    if (x >= 0 && x < GR_SZ && y >= 0 && y < GR_SZ) {
      // Determine building size
      let bw = 1, bh = 1;
      if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {
        bw = 2; bh = 2;
      } else if (st.selectedTool === 'wind') {
        bw = 1; bh = 2;
      } else if (st.selectedTool === 'waterplant') {
        bw = 2; bh = 2;
      } else if (st.selectedTool === 'watertower') {
        bw = 1; bh = 1;
      } else if (st.selectedTool === 'pipe') {
        bw = 1; bh = 1;
      }
      
      // Check if placement is valid
      let valid = true;
      const c = st.grid[y][x];
      const tr = st.terrain[y][x];
      // Pipes can be on water tiles, but not cliffs. Other buildings can't be on water or cliffs.
      if (st.selectedTool === 'pipe') {
        if (tr === 'cliff') valid = false;
      } else {
        if (tr === 'water' || tr === 'cliff') valid = false;
      }
      
      const isPk = st.selectedTool.startsWith('park');
      const isWaterTool = st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower';
      
      if (bw > 1 || bh > 1) {
        for (let dy=0; dy<bh; dy++) {
          for (let dx=0; dx<bw; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= GR_SZ || ny >= GR_SZ) { valid = false; break; }
            const nc = st.grid[ny][nx];
            const ntr = st.terrain[ny][nx];
            // Pipes can be on water tiles, but not cliffs. Other buildings can't be on water or cliffs.
            if (st.selectedTool === 'pipe') {
              if (ntr === 'cliff') { valid = false; break; }
            } else {
              if (ntr === 'water' || ntr === 'cliff') { valid = false; break; }
            }
            const isZone = nc.type === 'residential' || nc.type === 'commercial' || nc.type === 'industrial';
            const isEmptyZone = isZone && (nc.level === 0 || nc.abandoned);
            if (isPk) {
              if (nc.type !== 'empty' && !isEmptyZone) { valid = false; break; }
            } else if (isWaterTool) {
              // Pipes can overlay on any tile except water plants/towers
              if (st.selectedTool === 'pipe' && (nc.type === 'waterplant' || nc.type === 'watertower')) { valid = false; break; }
              // Water plants/towers need empty or abandoned tiles
              if (st.selectedTool !== 'pipe' && nc.type !== 'empty' && !nc.abandoned) { valid = false; break; }
            } else {
              if (nc.type !== 'empty' && !nc.abandoned) { valid = false; break; }
            }
          }
          if (!valid) break;
        }
        // Water plants must be within 2 tiles of water
        if (valid && (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower')) {
          let nearWater = false;
          for (let dy=0; dy<bh; dy++) {
            for (let dx=0; dx<bw; dx++) {
              const nx = x + dx, ny = y + dy;
              if (isNearWaterTile(nx, ny, 2)) {
                nearWater = true;
                break;
              }
            }
            if (nearWater) break;
          }
          if (!nearWater) valid = false;
        }
      } else {
        const isZone = c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial';
        const isEmptyZone = isZone && (c.level === 0 || c.abandoned);
        if (isPk) {
          if (c.type !== 'empty' && !isEmptyZone) valid = false;
        } else if (isWaterTool) {
          // Pipes can overlay on any tile except water plants/towers
          if (st.selectedTool === 'pipe' && (c.type === 'waterplant' || c.type === 'watertower')) valid = false;
          // Water plants/towers need empty or abandoned tiles
          if (st.selectedTool !== 'pipe' && c.type !== 'empty' && !c.abandoned) valid = false;
          // Water towers must be within 4 tiles of water
          if (st.selectedTool === 'watertower' && !isNearWaterTile(x, y, 4)) valid = false;
        } else {
          if (c.type !== 'empty' && !c.abandoned) valid = false;
        }
      }
      
      // Draw semi-transparent preview
      if (valid) {
        ctx.save();
        const px = x * CL_SZ, py = y * CL_SZ;
        
        // Draw the actual tile design semi-transparently
        ctx.globalAlpha = 0.6;
        drTl(x, y, st.selectedTool, 0, false, bw, bh);
        ctx.globalAlpha = 1.0;
        
        // Draw semi-transparent white border around the building footprint
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(px, py, bw * CL_SZ, bh * CL_SZ);
        ctx.restore();
      }
    }
  }
  
  // Draw highlighted building border
  if (highlightedBuilding) {
    ctx.save();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      highlightedBuilding.x * CL_SZ + 1,
      highlightedBuilding.y * CL_SZ + 1,
      highlightedBuilding.w * CL_SZ - 2,
      highlightedBuilding.h * CL_SZ - 2
    );
    ctx.restore();
  }
  
  st.fires.forEach(f => {
    if (f.age < 20) {
      const fx = f.x * CL_SZ;
      const fy = f.y * CL_SZ;

      // Time-based animation for smooth flicker and wobble
      const t = Date.now() / 160 + (f.x * 0.7 + f.y * 0.3);
      const wobble = Math.sin(t) * 1.5;
      const heightPulse = 1 + Math.sin(t * 1.7) * 0.6;

      // Base positions (slightly offset down on Y)
      const yOffset = 1; // move flame a bit lower in the tile
      const baseY = fy + 14 + yOffset;
      const centerX = fx + 8;

      ctx.save();

      // --- Outer glow (soft red/orange halo) ---
      ctx.fillStyle = 'rgba(255, 80, 0, 0.25)';
      ctx.beginPath();
      ctx.ellipse(centerX, fy + 9 + yOffset, 7 + Math.abs(wobble), 7 * heightPulse, 0, 0, Math.PI * 2);
      ctx.fill();

      // --- Base flame (deep orange) ---
      ctx.fillStyle = '#ff4b1f';
      ctx.beginPath();
      ctx.moveTo(centerX - (4 + wobble), baseY);
      ctx.lineTo(centerX - 2.5, fy + 10 + yOffset);
      ctx.lineTo(centerX - 3, fy + 8 + yOffset);
      ctx.lineTo(centerX - 0.5 + wobble, fy + yOffset + 5 * heightPulse);
      ctx.lineTo(centerX, fy + yOffset + 3 * heightPulse);
      ctx.lineTo(centerX + 0.5 + wobble, fy + yOffset + 5 * heightPulse);
      ctx.lineTo(centerX + 3, fy + 8 + yOffset);
      ctx.lineTo(centerX + 2.5, fy + 10 + yOffset);
      ctx.lineTo(centerX + (4 - wobble), baseY);
      ctx.closePath();
      ctx.fill();

      // --- Mid flame (bright orange/yellow, slightly narrower) ---
      const midPhase = (Math.sin(t * 1.3) + 1) / 2; // 0..1
      const midColor = midPhase < 0.5 ? '#ffb347' : '#ffd166';
      ctx.fillStyle = midColor;
      ctx.beginPath();
      ctx.moveTo(centerX - 2.5, baseY - 2);
      ctx.lineTo(centerX - 1.5, fy + 10 + yOffset);
      ctx.lineTo(centerX - 1, fy + 8 + yOffset);
      ctx.lineTo(centerX, fy + yOffset + 5 * heightPulse - 1);
      ctx.lineTo(centerX + 1, fy + 8 + yOffset);
      ctx.lineTo(centerX + 1.5, fy + 10 + yOffset);
      ctx.lineTo(centerX + 2.5, baseY - 2);
      ctx.closePath();
      ctx.fill();

      // --- Inner flame (white/hot core, animated height) ---
      const innerHeight = 4 * heightPulse;
      ctx.fillStyle = '#fff8c6';
      ctx.beginPath();
      ctx.moveTo(centerX - 0.8, baseY - 2);
      ctx.lineTo(centerX - 0.6, fy + 10 + yOffset);
      ctx.lineTo(centerX, fy + 10 + yOffset - innerHeight);
      ctx.lineTo(centerX + 0.6, fy + 10 + yOffset);
      ctx.lineTo(centerX + 0.8, baseY - 2);
      ctx.closePath();
      ctx.fill();

      // --- Small sparks/flickers above the flame ---
      const sparkPhase = (Math.floor(t / 4) % 3);
      ctx.fillStyle = '#ffff66';
      if (sparkPhase === 0) {
        ctx.fillRect(centerX - 2, fy + 3 + yOffset, 1, 1);
        ctx.fillRect(centerX + 1, fy + 4 + yOffset, 1, 1);
      } else if (sparkPhase === 1) {
        ctx.fillRect(centerX - 1, fy + 2 + yOffset, 1, 1);
        ctx.fillRect(centerX + 2, fy + 3 + yOffset, 1, 1);
      } else {
        ctx.fillRect(centerX - 3, fy + 4 + yOffset, 1, 1);
        ctx.fillRect(centerX + 0, fy + 2 + yOffset, 1, 1);
      }

      ctx.restore();
    }
  });
  st.crimeEvents.forEach(evt => {
    if (evt.age<20) {
      const cx = evt.x * CL_SZ;
      const cy = evt.y * CL_SZ;
      const anim = evt.age % 4;
      
      ctx.save();
      
      // Draw pulsing circle (siren effect)
      const pulseSize = anim < 2 ? 1 : 0.7;
      ctx.fillStyle = anim < 2 ? 'rgba(220, 20, 60, 0.6)' : 'rgba(255, 0, 0, 0.4)';
      ctx.beginPath();
      ctx.arc(cx + 8, cy + 8, 6 * pulseSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw siren light (alternating red/blue)
      ctx.fillStyle = anim < 2 ? '#dc143c' : '#0066ff';
      ctx.beginPath();
      ctx.arc(cx + 8, cy + 8, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw exclamation mark
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(cx + 7.5, cy + 6, 1, 3);
      ctx.fillRect(cx + 7.5, cy + 10, 1, 1);
      
      // Draw light rays
      if (anim < 2) {
        ctx.strokeStyle = 'rgba(220, 20, 60, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const angle = (i * Math.PI / 4) + (evt.age * 0.3);
          ctx.beginPath();
          ctx.moveTo(cx + 8, cy + 8);
          ctx.lineTo(cx + 8 + Math.cos(angle) * 8, cy + 8 + Math.sin(angle) * 8);
          ctx.stroke();
        }
      }
      
      ctx.restore();
    }
  });
  st.cars.forEach(c => {
    ctx.save();
    
    // Determine car direction for rotation
    let angle = 0; // Default: horizontal (0 degrees)
    const isReturning = c.mission && c.mission.returning;
    
    if (c.path && c.path.length > 1 && c.pathIdx < c.path.length - 1) {
      const curNode = c.path[c.pathIdx];
      const nextNode = c.path[c.pathIdx + 1];
      const dx = nextNode.x - curNode.x;
      const dy = nextNode.y - curNode.y;
      
      // If moving vertically (more vertical than horizontal), rotate 90 degrees
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2; // 90 degrees
      }
      // If returning, reverse the direction (add 180 degrees)
      if (isReturning) {
        angle += Math.PI;
      }
    } else if (c.entering && c.entryTarget) {
      // Check direction to entry target
      const dx = c.entryTarget.x - c.x;
      const dy = c.entryTarget.y - c.y;
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2;
      }
      // If returning, reverse the direction
      if (isReturning) {
        angle += Math.PI;
      }
    } else if (c.exiting && c.exitTarget) {
      // Check direction to exit target
      const dx = c.exitTarget.x - c.x;
      const dy = c.exitTarget.y - c.y;
      if (Math.abs(dy) > Math.abs(dx)) {
        angle = Math.PI / 2;
      }
      // If returning, reverse the direction
      if (isReturning) {
        angle += Math.PI;
      }
    } else if (c.path && c.path.length > 0 && c.pathIdx < c.path.length) {
      // Fallback: check movement direction from current position
      const nextTarget = getCarSegmentTarget(c);
      if (nextTarget) {
        const dx = nextTarget.tx - c.x;
        const dy = nextTarget.ty - c.y;
        if (Math.abs(dy) > Math.abs(dx)) {
          angle = Math.PI / 2;
        }
        // If returning, reverse the direction
        if (isReturning) {
          angle += Math.PI;
        }
      }
    }
    
    // Special handling for returning vehicles when path is very short or at end
    // Use direction to station when station is adjacent to scene
    if (isReturning && c.stationRoad && angle === 0) {
      // Check if we need to calculate angle based on direction to station
      // This handles cases where path is very short (station adjacent to scene)
      const pathTooShort = !c.path || c.path.length <= 1;
      const atPathEnd = c.path && c.pathIdx >= c.path.length - 1;
      const noClearDirection = !c.entering && !c.exiting && !c.entryTarget && !c.exitTarget;
      
      if (pathTooShort || (atPathEnd && noClearDirection)) {
        // Try to get direction from path if available (even if at end)
        if (c.path && c.path.length >= 2 && c.pathIdx < c.path.length) {
          const curNode = c.path[Math.min(c.pathIdx, c.path.length - 1)];
          const prevNode = c.pathIdx > 0 ? c.path[c.pathIdx - 1] : null;
          const nextNode = c.pathIdx < c.path.length - 1 ? c.path[c.pathIdx + 1] : null;
          
          if (nextNode) {
            // Use next node direction
            const dx = nextNode.x - curNode.x;
            const dy = nextNode.y - curNode.y;
            if (Math.abs(dy) > Math.abs(dx)) {
              angle = Math.PI / 2;
            }
            angle += Math.PI; // Reverse for returning
          } else if (prevNode) {
            // Use previous node direction (we're moving from prev to current)
            const dx = curNode.x - prevNode.x;
            const dy = curNode.y - prevNode.y;
            if (Math.abs(dy) > Math.abs(dx)) {
              angle = Math.PI / 2;
            }
            angle += Math.PI; // Reverse for returning
          }
        }
        
        // Fallback: use direction to station
        if (angle === 0) {
          const stationCenter = getRoadCenterCoords(c.stationRoad);
          const dx = stationCenter.x - c.x;
          const dy = stationCenter.y - c.y;
          // Only update if we have a meaningful direction
          if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
            // Calculate base angle based on direction to station
            if (Math.abs(dy) > Math.abs(dx)) {
              angle = Math.PI / 2;
            } else {
              angle = 0;
            }
            // For returning vehicles, reverse the direction (face backward/away from station)
            angle += Math.PI;
          }
        }
      }
    }
    
      // Translate to car center, rotate, then translate back
      let carWidth = 3, carHeight = 2;
      if (c.type === 'fire') {
        carWidth = 7; // Fire trucks are longer
        carHeight = 4;
      } else if (c.type === 'police') {
        carWidth = 5;
        carHeight = 4;
      }
      const halfWidth = carWidth / 2;
      const halfHeight = carHeight / 2;
      let drawX = c.x;
      let drawY = c.y;
      let carCenterX = drawX + halfWidth;
      let carCenterY = drawY + halfHeight;
      const isVertical = Math.abs(Math.abs(angle) - Math.PI / 2) < 0.001;
      if (isVertical) {
        const snappedCenterX = snapCenterToPixelGrid(carCenterX, halfHeight);
        const snappedCenterY = snapCenterToPixelGrid(carCenterY, halfWidth);
        drawX += snappedCenterX - carCenterX;
        drawY += snappedCenterY - carCenterY;
        carCenterX = snappedCenterX;
        carCenterY = snappedCenterY;
      }
      ctx.translate(carCenterX, carCenterY);
      ctx.rotate(angle);
      ctx.translate(-carCenterX, -carCenterY);
    
    // Draw emergency vehicles with special styling
    if (c.type === 'police') {
      // Police car: dark gray body with single red/blue siren
      ctx.fillStyle = '#1a1a1a'; // Very dark gray, almost black
      // Body centered on the same lane center as regular cars
      ctx.fillRect(drawX, drawY, carWidth, carHeight);

      // Single red/blue alternating siren on top center
      const time = Date.now() / 200; // Blinking effect
      const redOn = Math.floor(time) % 2 === 0;
      ctx.fillStyle = redOn ? '#ff0000' : '#0066ff'; // Red or blue

      const sirenWidth = 2;
      const sirenHeight = 1;
      const sirenX = drawX + (carWidth - sirenWidth) / 2;
      const sirenY = drawY - 1;
      ctx.fillRect(Math.round(sirenX), sirenY, sirenWidth, sirenHeight);
    } else if (c.type === 'fire') {
      // Fire truck: longer body with single side-mounted flashing siren
      ctx.fillStyle = '#8b0000';
      // Body centered on the same lane center as regular cars
      ctx.fillRect(drawX, drawY, carWidth, carHeight);

      // Single side siren (left side) alternating bright red/yellow
      const time = Date.now() / 200; // Blinking effect
      const redOn = Math.floor(time) % 2 === 0;
      ctx.fillStyle = redOn ? '#ff3333' : '#ffff00';

      const sirenWidth = 1;
      const sirenHeight = 2;
      const sirenX = drawX - sirenWidth; // Just to the left of the truck body
      const sirenY = drawY + (carHeight - sirenHeight) / 2;
      ctx.fillRect(sirenX, Math.round(sirenY), sirenWidth, sirenHeight);
    } else {
      // Regular cars
      ctx.fillStyle = c.color;
      ctx.fillRect(drawX, drawY, 3, 2);
    }
    
    ctx.restore();
  });
}

function drawLandValueOverlay() {
  ctx.save();
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      ctx.fillStyle=getLandValueOverlayColor(st.landValue[y][x]);
      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
    }
  }
  ctx.restore();
}

function getLandValueOverlayColor(value) {
  const ratio=Math.max(0,Math.min(1,(value||0)/100));
  const r=Math.round(LAND_VALUE_LOW_COLOR.r+(LAND_VALUE_HIGH_COLOR.r-LAND_VALUE_LOW_COLOR.r)*ratio);
  const g=Math.round(LAND_VALUE_LOW_COLOR.g+(LAND_VALUE_HIGH_COLOR.g-LAND_VALUE_LOW_COLOR.g)*ratio);
  const b=Math.round(LAND_VALUE_LOW_COLOR.b+(LAND_VALUE_HIGH_COLOR.b-LAND_VALUE_LOW_COLOR.b)*ratio);
  return `rgba(${r},${g},${b},0.4)`;
}

function setLandValueOverlay(active) {
  const enable=!!active;
  if (enable) {
    showLandValueOverlay=true;
    updLV();
    drGr();
    // Update status text to indicate stats mode
    const sTx = document.getElementById('statusText');
    sTx.textContent = 'click buildings to view details';
    return;
  }
  if (showLandValueOverlay) {
    showLandValueOverlay=false;
    hideBuildingInfo();
    drGr();
    // Restore status text
    const sTx = document.getElementById('statusText');
    if (st.selectedTool) {
      const tl = st.selectedTool;
      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';
      else {
        const dn = tl.startsWith('park') ? 'park' : tl;
        sTx.textContent = `placing ${dn}`;
      }
    } else {
      sTx.textContent = 'select a tool to start building';
    }
  }
}

function drawCrimeOverlay() {
  ctx.save();
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      ctx.fillStyle=getCrimeOverlayColor(st.crime[y][x]||30);
      ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
    }
  }
  ctx.restore();
}

function getCrimeOverlayColor(value) {
  const crimeLevel=Math.max(0,Math.min(100,value||30));
  let r, g, b;
  if (crimeLevel>=70) {
    // High crime: red (255,0,0) to dark red (200,0,0)
    const ratio=(crimeLevel-70)/30;
    r=Math.round(200+55*ratio);
    g=0;
    b=0;
  } else if (crimeLevel>=30) {
    // Medium crime: yellow (255,255,0) to red (255,0,0)
    const ratio=(crimeLevel-30)/40;
    r=255;
    g=Math.round(255*(1-ratio));
    b=0;
  } else {
    // Low crime: green (0,255,0) to yellow (255,255,0)
    const ratio=crimeLevel/30;
    r=Math.round(255*ratio);
    g=255;
    b=0;
  }
  return `rgba(${r},${g},${b},0.5)`;
}

function setCrimeOverlay(active) {
  const enable=!!active;
  if (enable) {
    showCrimeOverlay=true;
    updCrime();
    drGr();
    // Update status text to indicate stats mode
    const sTx = document.getElementById('statusText');
    sTx.textContent = 'click buildings to view details';
    return;
  }
  if (showCrimeOverlay) {
    showCrimeOverlay=false;
    hideBuildingInfo();
    drGr();
    // Restore status text
    const sTx = document.getElementById('statusText');
    if (st.selectedTool) {
      const tl = st.selectedTool;
      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';
      else {
        const dn = tl.startsWith('park') ? 'park' : tl;
        sTx.textContent = `placing ${dn}`;
      }
    } else {
      sTx.textContent = 'select a tool to start building';
    }
  }
}

function drawWaterOverlay() {
  // Only show overlay when water tools are active
  if (st.selectedTool !== 'pipe' && st.selectedTool !== 'waterplant' && st.selectedTool !== 'watertower' && st.selectedTool !== 'bulldoze') {
    return;
  }
  
  ctx.save();
  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) {
    calculateWaterGrid();
  }
  
  // Show allowed placement range around water tiles when water plant tools are selected
  if (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {
    for (let y=0; y<GR_SZ; y++) {
      for (let x=0; x<GR_SZ; x++) {
        const terrain=st.terrain[y][x];
        // Skip water and cliff tiles themselves
        if (terrain==='water'||terrain==='cliff') continue;
        
        // Check if this tile is within 4 tiles of water
        if (isNearWaterTile(x, y, 4)) {
          // Use a blue tint to show valid placement area
          ctx.fillStyle='rgba(59,130,246,0.15)'; // Blue tint for valid placement range
          ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
        }
      }
    }
  }
  
  // First pass: show coverage areas around pipes (lighter blue)
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      
      // Only show coverage for non-pipe tiles
      if (st.waterGrid[y][x] && !st.grid[y][x].pipe) {
        // Check if there's a connected pipe nearby (within 2-tile range to match actual coverage)
        let hasNearbyPipe = false;
        for (let dy=-2; dy<=2; dy++) {
          for (let dx=-2; dx<=2; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
              if (st.grid[ny][nx].pipe && st.waterGrid[ny][nx]) {
                hasNearbyPipe = true;
                break;
              }
            }
          }
          if (hasNearbyPipe) break;
        }
        
        if (hasNearbyPipe) {
          ctx.fillStyle='rgba(59,130,246,0.2)'; // Bright blue with transparency for coverage
          ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
        }
      }
    }
  }
  
  // Second pass: highlight water infrastructure
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const terrain=st.terrain[y][x];
      if (terrain==='water'||terrain==='cliff') continue;
      
      // Highlight water plants/towers with border
      if (st.grid[y][x].type === 'waterplant' || st.grid[y][x].type === 'watertower') {
        // Check if connected to pipe network
        let isConnected = false;
        const directions = [[0,-1], [0,1], [-1,0], [1,0]];
        for (const [dx, dy] of directions) {
          const nx = x + dx, ny = y + dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            if (st.grid[ny][nx].pipe && st.waterGrid[ny][nx]) {
              isConnected = true;
              break;
            }
          }
        }
        
        if (isConnected) {
          ctx.fillStyle='rgba(59,130,246,0.25)'; // Bright blue for connected plants
        } else {
          ctx.fillStyle='rgba(239,68,68,0.3)'; // Red tint for disconnected plants
        }
        ctx.fillRect(x*CL_SZ,y*CL_SZ,CL_SZ,CL_SZ);
      }
    }
  }
  ctx.restore();
}

function setWaterOverlay(active) {
  const enable=!!active;
  // Only allow overlay if water tool is selected
  if (enable && st.selectedTool !== 'pipe' && st.selectedTool !== 'waterplant' && st.selectedTool !== 'watertower') {
    return;
  }
  
  if (enable) {
    showWaterOverlay=true;
    calculateWaterGrid();
    drGr();
    // Update status text
    const sTx = document.getElementById('statusText');
    sTx.textContent = 'water overlay active - click buildings to view details';
    return;
  }
  if (showWaterOverlay) {
    showWaterOverlay=false;
    hideBuildingInfo();
    drGr();
    // Restore status text
    const sTx = document.getElementById('statusText');
    if (st.selectedTool) {
      const tl = st.selectedTool;
      if (tl === 'bulldoze') sTx.textContent = 'click to demolish buildings';
      else {
        const dn = tl.startsWith('park') ? 'park' : tl;
        sTx.textContent = `placing ${dn}`;
      }
    } else {
      sTx.textContent = 'select a tool to start building';
    }
  }
}

function findPath(sx,sy,ex,ey, maxLength=50) {
  const q=[{x:sx,y:sy,path:[{x:sx,y:sy}]}], vis=new Set();
  while(q.length>0) {
    const cur=q.shift(), k=`${cur.x},${cur.y}`;
    if (vis.has(k)) continue;
    vis.add(k);
    if (cur.x===ex && cur.y===ey) return cur.path;
    if (cur.path.length>maxLength) continue;
    const dirs=[[0,-1],[1,0],[0,1],[-1,0]];
    for (const [dx,dy] of dirs) {
      const nx=cur.x+dx, ny=cur.y+dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && !vis.has(`${nx},${ny}`)) {
        if (st.grid[ny][nx].type==='road') {
          q.push({x:nx,y:ny,path:[...cur.path,{x:nx,y:ny}]});
        }
      }
    }
  }
  return null;
}

function ensureStationDispatchMap() {
  if (!st.stationDispatches) st.stationDispatches={};
}

function getStationKeyFromCoords(x,y) {
  return `${x},${y}`;
}

function getStationDispatchCount(key) {
  ensureStationDispatchMap();
  return st.stationDispatches[key]||0;
}

function incrementStationDispatchCount(key) {
  ensureStationDispatchMap();
  st.stationDispatches[key]=(st.stationDispatches[key]||0)+1;
}

function releaseStationSlot(car) {
  if (!car || !car.stationKey) return;
  ensureStationDispatchMap();
  if (st.stationDispatches[car.stationKey]) {
    st.stationDispatches[car.stationKey]--;
    if (st.stationDispatches[car.stationKey]<0) st.stationDispatches[car.stationKey]=0;
  }
  car.stationKey=null;
}

function getCurrentRoadNode(car) {
  if (car && car.path && car.path[car.pathIdx]) return car.path[car.pathIdx];
  if (car && car.sceneRoad) return car.sceneRoad;
  if (car && car.stationRoad) return car.stationRoad;
  return null;
}

function findPreferredAdjacentRoad(x,y) {
  const primaryDirs = [
    {dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}
  ];
  const diagonalDirs = [
    {dx:-1,dy:-1},{dx:1,dy:-1},{dx:1,dy:1},{dx:-1,dy:1}
  ];
  for (const dirs of [primaryDirs, diagonalDirs]) {
    for (const {dx,dy} of dirs) {
      const nx = x + dx, ny = y + dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
        if (st.grid[ny][nx].type === 'road') {
          return {x:nx,y:ny};
        }
      }
    }
  }
  return null;
}

function isWithinCoverageRange(targetX, targetY, checkX, checkY) {
  // Check if checkX,checkY is within 2 tiles of targetX,targetY
  // This covers 2x2, 2x1, 1x2 buildings
  const dx = Math.abs(checkX - targetX);
  const dy = Math.abs(checkY - targetY);
  return dx <= 2 && dy <= 2;
}

function findNearestStation(targetX, targetY, stationType) {
  // Find nearest road to target location - check up to 2 tiles away
  const targetRoads = [];
  
  // Check all roads within 2 tiles (orthogonal and diagonal)
  for (let dy = -2; dy <= 2; dy++) {
    for (let dx = -2; dx <= 2; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = targetX + dx, ny = targetY + dy;
      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {
        if (st.grid[ny][nx].type === 'road') {
          const dist = Math.abs(dx) + Math.abs(dy);
          targetRoads.push({x: nx, y: ny, distToBuilding: dist});
        }
      }
    }
  }
  
  // Sort by distance (closest first)
  targetRoads.sort((a, b) => a.distToBuilding - b.distToBuilding);
  
  if (targetRoads.length === 0) return null;
  
  // Find all stations of the requested type
  const stations = [];
  for (let y = 0; y < GR_SZ; y++) {
    for (let x = 0; x < GR_SZ; x++) {
      const c = st.grid[y][x];
      if (c.type === stationType && hasRdAcc(x, y)) {
        const adjacentRoad = findPreferredAdjacentRoad(x,y);
        if (adjacentRoad) {
          stations.push({stationX: x, stationY: y, roadX: adjacentRoad.x, roadY: adjacentRoad.y});
        }
      }
    }
  }
  if (stations.length === 0) return null;
  
  // Find nearest station - prioritize closest road to building
  // Try each target road in order (closest to building first)
  for (const targetRoad of targetRoads) {
    let bestStationForThisRoad = null;
    let minPathLength = Infinity;
    
    // Find the nearest station that can reach this specific target road
    for (const station of stations) {
      const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);
      if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) continue;
      
      const manhattanDist = Math.abs(station.roadX - targetRoad.x) + Math.abs(station.roadY - targetRoad.y);
      if (manhattanDist > 100) continue; // Skip stations that are clearly too far
      
      const path = findPath(station.roadX, station.roadY, targetRoad.x, targetRoad.y, 100);
      if (path && path.length < minPathLength) {
        minPathLength = path.length;
        bestStationForThisRoad = {
          stationX: station.stationX,
          stationY: station.stationY,
          roadX: station.roadX,
          roadY: station.roadY,
          targetRoadX: targetRoad.x,
          targetRoadY: targetRoad.y,
          path: path
        };
      }
    }
    
    // If we found a station that can reach this road, use it
    // This ensures we park at the closest road to the building
    if (bestStationForThisRoad) {
      return bestStationForThisRoad;
    }
  }
  
  return null;
}

function dispatchEmergencyVehicle(stationType, targetX, targetY, missionType) {
  const station = findNearestStation(targetX, targetY, stationType);
  if (!station || !station.path || station.path.length < 2) return false;
  const stationKey = getStationKeyFromCoords(station.stationX, station.stationY);
  if (getStationDispatchCount(stationKey) >= STATION_MAX_ACTIVE) return false;
  
  const start = {x: station.roadX, y: station.roadY};
  const end = {x: station.targetRoadX, y: station.targetRoadY};
  const path = station.path;
  
  // Determine lane offset
  let laneOffset = 0;
  const startCenterX = path[0].x * CL_SZ + 7;
  const startCenterY = path[0].y * CL_SZ + 7;
  let startX = startCenterX;
  let startY = startCenterY;
  
  if (path.length >= 2) {
    const dx = path[1].x - path[0].x;
    const dy = path[1].y - path[0].y;
    if (Math.abs(dx) > Math.abs(dy)) {
      laneOffset = dx > 0 ? 5 : -5;
      startY += laneOffset;
    } else {
      laneOffset = dy > 0 ? -5 : 5;
      startX += laneOffset;
    }
  }
  
  const stationBuilding = {x: station.stationX, y: station.stationY};
  const roadCenter = getRoadCenterCoords(start);
  const entryDir = getEdgeDirection(stationBuilding, start);
  let entryTarget = null;
  let entering = false;
  let spawnX = roadCenter.x;
  let spawnY = roadCenter.y;
  
  if (entryDir.x !== 0 || entryDir.y !== 0) {
    entering = true;
    entryTarget = {x: startX, y: startY};
  } else if (startX !== roadCenter.x || startY !== roadCenter.y) {
    entering = true;
    entryTarget = {x: startX, y: startY};
  }
  
  // Fire trucks: red (will be styled with lights), Police cars: very dark gray (will be styled with lights)
  const color = stationType === 'fire' ? '#ff0000' : '#1a1a1a';
  const vehicleType = stationType === 'fire' ? 'fire' : 'police';
  
  // Scene road is the last node in the path (where vehicle will actually arrive)
  const sceneRoadNode = path[path.length - 1];
  const sceneParkingCenter = getRoadCenterCoords(sceneRoadNode);
  
  st.cars.push({
    x: spawnX,
    y: spawnY,
    path: path,
    pathIdx: 0,
    color: color,
    type: vehicleType,
    laneOffset: laneOffset,
    reverse: false,
    entering: entering,
    entryTarget: entryTarget,
    exiting: false,
    exitLaneTarget: null,
    exitTarget: null,
    positioningForExit: false,
    stationRoad: { x: start.x, y: start.y },
    sceneRoad: { x: sceneRoadNode.x, y: sceneRoadNode.y },
    sceneParkingTarget: sceneParkingCenter,
    scenePositioning: false,
    missionPhase: 'enroute',
    stationKey: stationKey,
    stationCoords: { x: station.stationX, y: station.stationY },
    mission: {
      type: missionType,
      targetX: targetX,
      targetY: targetY,
      arrived: false,
      returning: false
    }
  });
  incrementStationDispatchCount(stationKey);
  
  return true;
}

function getRoadCenterCoords(node) {
  if (!node) return { x: 0, y: 0 };
  return { x: node.x * CL_SZ + 7, y: node.y * CL_SZ + 7 };
}

function prepareEmergencyVehicleReturn(car, opts={}) {
  if (!car || !car.mission || car.mission.returning) return;
  
  // Use sceneRoad (where vehicle parked) as the starting point for return path
  const startRoad = car.sceneRoad || getCurrentRoadNode(car);
  const stationRoad = car.stationRoad;
  if (!startRoad || !stationRoad) {
    car.removeOnNextTick = true;
    releaseStationSlot(car);
    return;
  }
  
  if (!opts.skipSceneDecrement && car.mission.arrived) {
    if (car.mission.type === 'fire') {
      const fire = st.fires.find(f => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, f.x, f.y));
      if (fire && fire.fireTrucksAtScene>0) fire.fireTrucksAtScene--;
    } else if (car.mission.type === 'crime') {
      const crime = st.crimeEvents.find(evt => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, evt.x, evt.y));
      if (crime && crime.policeCarsAtScene>0) crime.policeCarsAtScene--;
    }
  }
  
  const returnPath = findPath(startRoad.x, startRoad.y, stationRoad.x, stationRoad.y, 100);
  if (!returnPath || returnPath.length<2) {
    car.removeOnNextTick = true;
    releaseStationSlot(car);
    return;
  }
  
  car.path = returnPath;
  car.pathIdx = 0;
  car.mission.returning = true;
  car.mission.arrived = false;
  car.missionPhase = 'returning';
  car.entering = true;
  car.exiting = false;
  car.exitTarget = null;
  car.reverse = false;
  car.holdPosition = null;
  car.scenePositioning = false;
  car.sceneParkingTarget = null;
  
  const startCenter = getRoadCenterCoords(returnPath[0]);
  car.x = startCenter.x;
  car.y = startCenter.y;
  let entryX = startCenter.x;
  let entryY = startCenter.y;
  car.laneOffset = 0;
  if (returnPath.length>=2) {
    const dx = returnPath[1].x - returnPath[0].x;
    const dy = returnPath[1].y - returnPath[0].y;
    if (Math.abs(dx)>Math.abs(dy)) {
      car.laneOffset = dx>0 ? 5 : -5;
      entryY += car.laneOffset;
    } else {
      car.laneOffset = dy>0 ? -5 : 5;
      entryX += car.laneOffset;
    }
  }
  car.entryTarget = { x: entryX, y: entryY };

  const stationBuilding = car.stationCoords || { x: car.stationRoad.x, y: car.stationRoad.y };
  const parkingCenter = car.stationRoad ? getRoadCenterCoords(car.stationRoad) : getRoadCenterCoords(endNode);
  const endIdx = returnPath.length - 1;
  const endNode = returnPath[endIdx];
  const endCenterX = endNode.x * CL_SZ + 7;
  const endCenterY = endNode.y * CL_SZ + 7;
  let exitLaneX = endCenterX;
  let exitLaneY = endCenterY;
  if (returnPath.length >= 2) {
    const dxLast = returnPath[endIdx].x - returnPath[endIdx - 1].x;
    const dyLast = returnPath[endIdx].y - returnPath[endIdx - 1].y;
    if (Math.abs(dxLast) > Math.abs(dyLast)) {
      exitLaneY += dxLast > 0 ? 5 : -5;
    } else {
      exitLaneX += dyLast > 0 ? -5 : 5;
    }
  }
  const exitDir = getEdgeDirection(stationBuilding, stationRoad);
  let exitTarget = parkingCenter;
  if (!exitTarget || Number.isNaN(exitTarget.x) || Number.isNaN(exitTarget.y)) {
    exitTarget = { x: exitLaneX, y: exitLaneY };
  }
  if (exitDir.x !== 0 || exitDir.y !== 0) {
    exitTarget = parkingCenter;
  }
  car.exitLaneTarget = { x: exitLaneX, y: exitLaneY };
  car.exitTarget = exitTarget;
  car.positioningForExit = false;
}

function sendEmergencyVehiclesHome(missionType, targetX, targetY) {
  st.cars.forEach(car => {
    if (!car.mission || car.mission.returning) return;
    if (car.mission.type===missionType && isWithinCoverageRange(car.mission.targetX, car.mission.targetY, targetX, targetY)) {
      prepareEmergencyVehicleReturn(car);
    }
  });
}
  
function attemptMissionArrival(car) {
  if (!car || !car.mission || car.mission.returning) return false;
  const buildingTarget = {
    x: car.mission.targetX * CL_SZ + CL_SZ / 2,
    y: car.mission.targetY * CL_SZ + CL_SZ / 2
  };
  const roadTarget = car.sceneRoad ? getRoadCenterCoords(car.sceneRoad) : null;
  // Fire and police cars should always stop at the road tile center, no offsets
  const targetToUse = roadTarget || buildingTarget;
  if (!targetToUse) return false;
  const dx = targetToUse.x - car.x;
  const dy = targetToUse.y - car.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const threshold = CL_SZ * 2.5;
  if (dist < threshold) {
    if (!car.mission.arrived) {
      car.mission.arrived = true;
      car.missionPhase = 'onscene';
        // Police and fire vehicles stop exactly at road tile center, no lane offsets
        const holdTarget = roadTarget || buildingTarget;
        if (holdTarget) {
          car.holdPosition = { x: holdTarget.x, y: holdTarget.y };
          car.x = car.holdPosition.x;
          car.y = car.holdPosition.y;
          // Clear any lane offsets for emergency vehicles
          if (car.type === 'police' || car.type === 'fire') {
            car.laneOffset = 0;
          }
        } else {
          car.holdPosition = { x: car.x, y: car.y };
        }
      if (!car.arrivalLogged) {
        if (car.mission.type === 'fire') {
          const fire = st.fires.find(f => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, f.x, f.y));
          if (fire) fire.fireTrucksAtScene = (fire.fireTrucksAtScene || 0) + 1;
        } else if (car.mission.type === 'crime') {
          const crime = st.crimeEvents.find(evt => isWithinCoverageRange(car.mission.targetX, car.mission.targetY, evt.x, evt.y));
          if (crime) crime.policeCarsAtScene = (crime.policeCarsAtScene || 0) + 1;
        }
        car.arrivalLogged = true;
      }
    } else if (!car.holdPosition) {
      car.holdPosition = { x: car.x, y: car.y };
    }
    return true;
  }
  return false;
}
 
function countActiveResponders(missionType, targetX, targetY) {
  if (!st.cars) return 0;
  return st.cars.reduce((sum, car) => {
    if (car.mission && !car.mission.returning && car.mission.type===missionType) {
      // Check if vehicle's target is within 2 tiles of the requested location
      if (isWithinCoverageRange(car.mission.targetX, car.mission.targetY, targetX, targetY)) {
        return sum+1;
      }
    }
    return sum;
  },0);
}

function ensureEmergencyCoverage() {
  if (st.fires) {
    st.fires.forEach(fire => {
      if (countActiveResponders('fire', fire.x, fire.y)===0) {
        dispatchEmergencyVehicle('fire', fire.x, fire.y, 'fire');
      }
    });
  }
  if (st.crimeEvents) {
    st.crimeEvents.forEach(evt => {
      if (countActiveResponders('crime', evt.x, evt.y)===0) {
        dispatchEmergencyVehicle('police', evt.x, evt.y, 'crime');
      }
    });
  }
}
 
function getEdgeDirection(structCell,roadCell) {
  if (!structCell || !roadCell) return {x:0,y:0};
  const dx=structCell.x-roadCell.x;
  const dy=structCell.y-roadCell.y;
  if (dx===0 && dy===0) return {x:0,y:0};
  if (Math.abs(dx)>Math.abs(dy)) return {x:dx>0?1:-1,y:0};
  if (Math.abs(dy)>Math.abs(dx)) return {x:0,y:dy>0?1:-1};
  if (dx!==0) return {x:dx>0?1:-1,y:0};
  return {x:0,y:dy>0?1:-1};
}

function spawnCar() {
  const res=[], com=[], ind=[], pol=[], fir=[];
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential' && !c.abandoned && hasRdAcc(x,y)) res.push({x,y});
    else if (c.type==='commercial' && !c.abandoned && hasRdAcc(x,y)) com.push({x,y});
    else if (c.type==='industrial' && !c.abandoned && hasRdAcc(x,y)) ind.push({x,y});
    else if (c.type==='police' && hasRdAcc(x,y)) pol.push({x,y});
    else if (c.type==='fire' && hasRdAcc(x,y)) fir.push({x,y});
  }
  if (res.length===0) return;
  
  let tp='normal', src, dst, clr;
  // Emergency vehicles are now dispatched via dispatchEmergencyVehicle(), not spawned randomly
  // So we only spawn normal civilian cars here
  {
    src=res[Math.floor(Math.random()*res.length)];
    const dests=[...com,...ind].filter(d=>d.x!==src.x||d.y!==src.y);
    if (dests.length===0) return;
    dst=dests[Math.floor(Math.random()*dests.length)];
    const rnd=Math.random();
    if (rnd<0.7) clr='#808080';
    else if (rnd<0.85) clr='#a0a0a0';
    else if (rnd<0.95) clr='#606060';
    else clr=['#ffeb3b','#4caf50','#9c27b0'][Math.floor(Math.random()*3)];
  }
  
  const rdNear=[];
  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
    const nx=src.x+dx, ny=src.y+dy;
    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdNear.push({x:nx,y:ny});
  }
  if (rdNear.length===0) return;
  const start=rdNear[Math.floor(Math.random()*rdNear.length)];
  
  const rdEnd=[];
  for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
    const nx=dst.x+dx, ny=dst.y+dy;
    if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ && st.grid[ny][nx].type==='road') rdEnd.push({x:nx,y:ny});
  }
  if (rdEnd.length===0) return;
  const end=rdEnd[Math.floor(Math.random()*rdEnd.length)];
  
  const path=findPath(start.x,start.y,end.x,end.y);
  if (!path || path.length<2) return;
  
    // Determine direction: randomly choose forward or reverse
    const reverse=Math.random()<0.5;
    const carPath=reverse ? [...path].reverse() : path;
    const spawnRoad=reverse ? end : start;
    const exitRoad=reverse ? start : end;
    const spawnBuilding=reverse ? dst : src;
    const exitBuilding=reverse ? src : dst;
    
    // Determine lane offset based on first segment direction
    // Cars going in opposite directions should be in opposite lanes
    let laneOffset=0;
    const startCenterX=carPath[0].x*CL_SZ+7;
    const startCenterY=carPath[0].y*CL_SZ+7;
    let startX=startCenterX;
    let startY=startCenterY;
    
    if (carPath.length>=2) {
      const dx=carPath[1].x-carPath[0].x;
      const dy=carPath[1].y-carPath[0].y;
      
      if (Math.abs(dx)>Math.abs(dy)) {
        // Horizontal movement: use y offset for lanes
        // Left-to-right (dx > 0): bottom lane (+5)
        // Right-to-left (dx < 0): top lane (-5)
        laneOffset=dx>0 ? 5 : -5;
        startY+=laneOffset;
      } else {
        // Vertical movement: use x offset for lanes
        // Ensure right-hand traffic: southbound (dy > 0) stays to the viewer's left (laneOffset = -5)
        laneOffset=dy>0 ? -5 : 5;
        startX+=laneOffset;
      }
    }
    
    const entryDir=getEdgeDirection(spawnBuilding,spawnRoad);
    let entryTarget=null;
    let entering=false;
    let spawnX=startX;
    let spawnY=startY;
    if (entryDir.x!==0 || entryDir.y!==0) {
      entering=true;
      entryTarget={x:startX,y:startY};
      if (Math.abs(entryDir.x)>=Math.abs(entryDir.y) && entryDir.x!==0) {
        spawnX=startCenterX+entryDir.x*CAR_EDGE_OFFSET;
        spawnY=startY;
      } else if (entryDir.y!==0) {
        spawnY=startCenterY+entryDir.y*CAR_EDGE_OFFSET;
        spawnX=startX;
      }
    }
    
    const endIdx=carPath.length-1;
    const endNode=carPath[endIdx];
    const endCenterX=endNode.x*CL_SZ+7;
    const endCenterY=endNode.y*CL_SZ+7;
    let exitLaneX=endCenterX;
    let exitLaneY=endCenterY;
    if (carPath.length>=2) {
      const dxLast=carPath[endIdx].x-carPath[endIdx-1].x;
      const dyLast=carPath[endIdx].y-carPath[endIdx-1].y;
      if (Math.abs(dxLast)>Math.abs(dyLast)) {
        exitLaneY+=dxLast>0 ? 5 : -5;
      } else {
        exitLaneX+=dyLast>0 ? -5 : 5;
      }
    }
    const exitDir=getEdgeDirection(exitBuilding,exitRoad);
    let exitLaneTarget={x:exitLaneX,y:exitLaneY};
    let exitTarget=null;
    if (exitDir.x!==0 || exitDir.y!==0) {
      exitTarget={x:exitLaneX,y:exitLaneY};
      if (Math.abs(exitDir.x)>=Math.abs(exitDir.y) && exitDir.x!==0) {
        exitTarget.x=endCenterX+exitDir.x*CAR_EDGE_OFFSET;
      } else if (exitDir.y!==0) {
        exitTarget.y=endCenterY+exitDir.y*CAR_EDGE_OFFSET;
      }
    }
    
    st.cars.push({
      x:spawnX,
      y:spawnY,
      path:carPath,
      pathIdx:0,
      color:clr,
      type:tp,
      laneOffset:laneOffset,
      reverse:reverse,
      entering:entering,
      entryTarget:entryTarget,
      exiting:false,
      exitLaneTarget:exitLaneTarget,
      exitTarget:exitTarget
    });
}
  
function updCars() {
  st.cars=st.cars.filter(c => {
      const finalizeRemoval = () => {
        if (c.mission && c.mission.returning) releaseStationSlot(c);
        return false;
      };
      if (c.removeOnNextTick) return finalizeRemoval();
    
      if (c.mission && !c.mission.returning) {
      const targetGridX = c.mission.targetX;
      const targetGridY = c.mission.targetY;
      let targetExists = false;
      if (c.mission.type === 'fire') {
        targetExists = st.fires.some(f => isWithinCoverageRange(targetGridX, targetGridY, f.x, f.y));
      } else if (c.mission.type === 'crime') {
        targetExists = st.crimeEvents.some(evt => isWithinCoverageRange(targetGridX, targetGridY, evt.x, evt.y));
      }
      
        if (!targetExists) {
        prepareEmergencyVehicleReturn(c);
        } else if (!c.mission.arrived) {
          if (attemptMissionArrival(c)) return true;
      } else {
        return true;
      }
    }
    
    if (c.mission && c.mission.arrived && !c.mission.returning) {
      if (c.holdPosition) {
        c.x = c.holdPosition.x;
        c.y = c.holdPosition.y;
        // Ensure emergency vehicles stay at exact road center, no offsets
        if ((c.type === 'police' || c.type === 'fire') && c.sceneRoad) {
          const exactCenter = getRoadCenterCoords(c.sceneRoad);
          c.x = exactCenter.x;
          c.y = exactCenter.y;
          c.holdPosition = exactCenter;
          c.laneOffset = 0;
        }
      } else if (c.sceneRoad) {
        const center = getRoadCenterCoords(c.sceneRoad);
        c.holdPosition = center;
        c.x = center.x;
        c.y = center.y;
        if (c.type === 'police' || c.type === 'fire') {
          c.laneOffset = 0;
        }
      } else {
        c.holdPosition = { x: c.x, y: c.y };
      }
      return true;
    }
    
    let remainingDist=getCarSpeedPerFrame(c);
    if (remainingDist<=0) return true;
    
    // Helper to check if car reached end of path
    const isAtPathEnd = () => c.pathIdx >= c.path.length - 1;
    
    // Helper to initiate exit sequence
    const startExitSequence = () => {
        if (c.exitLaneTarget) {
        c.positioningForExit = true;
      } else if (c.exitTarget) {
        c.exiting = true;
      } else {
        return false; // No exit sequence available
      }
      return true;
    };
    
    while (remainingDist>0) {
      // Determine target based on current car state
      let targetStage, tx, ty;
      
        if (c.entering && c.entryTarget) {
        targetStage = 'entry';
        tx = c.entryTarget.x;
        ty = c.entryTarget.y;
      } else if (c.exiting && c.exitTarget) {
        targetStage = 'exit';
        tx = c.exitTarget.x;
        ty = c.exitTarget.y;
      } else if (c.positioningForExit && c.exitLaneTarget) {
        targetStage = 'positioning';
        tx = c.exitLaneTarget.x;
        ty = c.exitLaneTarget.y;
      } else {
        // Handle path-following and end-of-path logic
        if (isAtPathEnd()) {
          // Mission vehicles that haven't arrived yet
          if (c.mission && !c.mission.returning) {
            // For emergency vehicles, move to exact center of scene road tile
            if (c.sceneRoad && (c.type === 'police' || c.type === 'fire')) {
              const sceneCenter = getRoadCenterCoords(c.sceneRoad);
              // Set this as our target for final approach
              targetStage = 'finalApproach';
              tx = sceneCenter.x;
              ty = sceneCenter.y;
              // Continue to movement logic below
            } else {
              // Non-emergency vehicles
              if (attemptMissionArrival(c)) return true;
              c.holdPosition = c.holdPosition || { x: c.x, y: c.y };
              c.x = c.holdPosition.x;
              c.y = c.holdPosition.y;
              return true;
            }
          } else {
            // Start exit sequence or despawn
            if (!startExitSequence()) {
              return finalizeRemoval();
            }
            continue;
          }
        } else {
          // Normal path following
          targetStage = 'path';
          const nextTarget = getCarSegmentTarget(c);
          tx = nextTarget.tx;
          ty = nextTarget.ty;
        }
      }
      
      // Move toward target
      const dx = tx - c.x;
      const dy = ty - c.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      // Snap to target when very close
        if (dist < CAR_SNAP_THRESHOLD) {
        c.x = tx;
        c.y = ty;
        
        // Handle state transitions
        if (targetStage === 'entry') {
          c.entering = false;
          c.entryTarget = null;
        } else if (targetStage === 'positioning') {
          c.positioningForExit = false;
          if (c.exitTarget) {
            c.exiting = true;
          } else {
            return finalizeRemoval();
          }
        } else if (targetStage === 'exit') {
          return finalizeRemoval();
        } else if (targetStage === 'finalApproach') {
          // Emergency vehicle reached exact parking position
          c.laneOffset = 0; // Clear lane offset for clean parking
          if (attemptMissionArrival(c)) return true;
          c.holdPosition = { x: c.x, y: c.y };
          return true;
        } else {
          // Advance path
          c.pathIdx++;
          if (isAtPathEnd()) {
            // Will be handled in next iteration
          } else {
            updateCarLaneOffset(c);
          }
        }
        continue;
      }
      
      // Move step toward target
      const step = Math.min(dist, remainingDist);
      c.x += dx / dist * step;
      c.y += dy / dist * step;
      remainingDist -= step;
      
      if (step < dist) break; // Not enough distance remaining
    }
    return true;
  });
  
  const maxCars=Math.min(60,Math.floor(st.population/18)+8);
  const populationFactor=Math.min(1,st.population/4000);
  const totalDemand=
    Math.max(0,(st.rDemand||0))+
    Math.max(0,(st.cDemand||0))+
    Math.max(0,(st.iDemand||0));
  const demandFactor=Math.min(1,totalDemand/400);
  const spawnChance=Math.min(0.25,0.02+0.1*populationFactor+0.08*demandFactor);
  if (st.speed>0 && st.population>10 && st.cars.length<maxCars && Math.random()<spawnChance) {
    spawnCar();
    if (st.cars.length<maxCars && Math.random()<0.15) spawnCar();
  }
}

// ===== UI Updates =====
function updInpWd() {
  const inp=document.getElementById('cityName'), tmp=document.createElement('span');
  tmp.style.font=window.getComputedStyle(inp).font; tmp.style.visibility='hidden'; tmp.style.position='absolute'; tmp.style.whiteSpace='pre';
  tmp.textContent=inp.value||inp.placeholder||'new city'; document.body.appendChild(tmp); inp.style.width=(tmp.offsetWidth+8)+'px'; document.body.removeChild(tmp);
}

function shwNxtNws() {
  if (nwsQ.length>0 && !trans) {
    const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=nwsQ.shift();
    if (ot===nt) return;
    trans=true; tk.classList.add('ticker-roll');
    setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';
      setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';
        setTimeout(() => { trans=false; if (nwsQ.length>0) setTimeout(shwNxtNws,100); },500);
      },10);
    },500);
    return;
  }
  if (st.newsEvents.length===0||trans) return;
  const tk=document.getElementById('newsTicker'), ot=tk.textContent, nt=st.newsEvents[nwsIdx];
  if (ot===nt) { nwsIdx=(nwsIdx+1)%st.newsEvents.length; return; }
  trans=true; tk.classList.add('ticker-roll');
  setTimeout(() => { tk.textContent=nt; tk.classList.remove('ticker-roll'); tk.style.transform='translateY(100%)'; tk.style.opacity='0';
    setTimeout(() => { tk.style.transition='all 0.5s ease-out'; tk.style.transform='translateY(0)'; tk.style.opacity='1';
      setTimeout(() => { trans=false; },500);
    },10);
  },500);
  nwsIdx=(nwsIdx+1)%st.newsEvents.length;
}

function updNwsTk() {
  if (tkrTmr) clearInterval(tkrTmr);
  if (st.newsEvents.length>0 && st.speed>0) {
    nwsIdx=st.newsEvents.length-1; const tk=document.getElementById('newsTicker');
    tk.textContent=st.newsEvents[nwsIdx]; tk.style.transform='translateY(0)'; tk.style.opacity='1';
    nwsIdx=(nwsIdx+1)%st.newsEvents.length; tkrTmr=setInterval(shwNxtNws,5000);
  } else {
    const tk=document.getElementById('newsTicker');
    if (st.speed===0) tk.textContent=st.newsEvents.length>0?st.newsEvents[st.newsEvents.length-1]:'';
    else if (st.newsEvents.length===0) tk.textContent='';
    tk.classList.remove('ticker-roll');
  }
}

function shwInfo(title,content,infoType) {
  plySnd('click');
  const pnl=document.getElementById('infoPanel');
  
  // If clicking the same stat, toggle it off
  if (currentInfoType === infoType && !pnl.classList.contains('hidden')) {
    pnl.classList.add('hidden');
    currentInfoType = null;
    setLandValueOverlay(false);
    setCrimeOverlay(false);
    setWaterOverlay(false);
    return;
  }
  
  // Otherwise, show the new panel
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('aiPanel').classList.add('hidden');
  document.getElementById('infoTitle').textContent=title;
  document.getElementById('infoContent').innerHTML=content;
  pnl.classList.remove('hidden');
  currentInfoType = infoType;
  if (infoType === 'happy') {
    setLandValueOverlay(false);
    setCrimeOverlay(true);
    setWaterOverlay(false);
  } else if (infoType === 'water') {
    setLandValueOverlay(false);
    setCrimeOverlay(false);
    // Only show water overlay if a water tool is selected
    if (st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {
      setWaterOverlay(true);
    } else {
      setWaterOverlay(false);
    }
  } else {
    setCrimeOverlay(false);
    setWaterOverlay(false);
    setLandValueOverlay(STAT_INFO_TYPES.includes(infoType));
  }
}

// Format numbers compactly (e.g., $1.5M, $234.5k)
function fmtCompact(num) {
  const absNum = Math.abs(num);
  if (absNum >= 1000000) {
    return `${(num/1000000).toFixed(1)}M`;
  } else if (absNum >= 1000) {
    return `${(num/1000).toFixed(1)}k`;
  }
  return num.toString();
}

function updUI() {
  const inp=document.getElementById('cityName'); if (!edtNm) { inp.value=st.cityName; updInpWd(); }
  document.getElementById('population').textContent=fmtCompact(st.population);
  document.getElementById('money').textContent=fmtCompact(st.money);
  document.getElementById('happiness').textContent=st.happiness;
  
  // Calculate and update power/water shortage indicators (only show when negative)
  const powerStats = calculatePowerStats();
  const powerSurplus = powerStats.powerSurplus;
  const powerShortageIndicator = document.getElementById('powerShortageIndicator');
  const powerShortageValue = document.getElementById('powerShortageValue');
  if (powerSurplus < 0) {
    powerShortageIndicator.style.display = 'flex';
    powerShortageValue.textContent = powerSurplus.toString();
  } else {
    powerShortageIndicator.style.display = 'none';
  }
  
  const waterStats = calculateWaterStats();
  const waterSurplus = waterStats.waterSurplus;
  const waterShortageIndicator = document.getElementById('waterShortageIndicator');
  const waterShortageValue = document.getElementById('waterShortageValue');
  if (waterSurplus < 0) {
    waterShortageIndicator.style.display = 'flex';
    waterShortageValue.textContent = waterSurplus.toString();
  } else {
    waterShortageIndicator.style.display = 'none';
  }
  
  if (!edtNm) {
    const month = (st.tickCount % 12) + 1;
    const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
    document.getElementById('yearDisplay').textContent=`${monthNames[month-1]} ${st.year}`;
  }
  const mEl=document.getElementById('money');
  if (st.money<0) { mEl.classList.remove('text-white'); mEl.classList.add('text-red-400'); }
  else { mEl.classList.remove('text-red-400'); mEl.classList.add('text-white'); }
  const rB=document.getElementById('rDemand'), cB=document.getElementById('cDemand'), iB=document.getElementById('iDemand');
  rB.style.height=`${st.rDemand}%`; cB.style.height=`${st.cDemand}%`; iB.style.height=`${st.iDemand}%`;
  [rB,cB,iB].forEach(el => { el.parentElement.style.display='flex'; el.parentElement.style.flexDirection='column'; el.parentElement.style.justifyContent='flex-end'; });
  const sBtn=document.getElementById('speedToggle');
  if (st.speed===0) sBtn.textContent='‚è∏';
  else if (st.speed===3000) sBtn.textContent='1x';
  else if (st.speed===1500) sBtn.textContent='2x';
  else if (st.speed===500) sBtn.textContent='3x';
}

function selTl(tl) {
  // Check if we're in water tool mode (water submenu is open or water tool was selected)
  const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';
  const wasWaterTool = st.selectedTool === 'pipe' || st.selectedTool === 'waterplant' || st.selectedTool === 'watertower';
  
  // Auto-show water overlay when water tools are selected, hide otherwise
  if (tl === 'pipe' || tl === 'waterplant' || tl === 'watertower') {
    setWaterOverlay(true);
  } else if (tl === 'bulldoze' && (isWaterToolMode || wasWaterTool)) {
    // Keep water overlay when switching to bulldoze from water tools
    setWaterOverlay(true);
  } else {
    // Always hide water overlay when switching to non-water tools (unless coming from water mode)
    if (!isWaterToolMode && !wasWaterTool) {
      setWaterOverlay(false);
    }
  }
  st.selectedTool=tl;
  updateToolSelection();
  const c=COSTS[tl]||0, cTx=document.getElementById('costText'), sTx=document.getElementById('statusText');
  if (tl==='bulldoze') {
    // Check if we're in water tool mode
    const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';
    if (isWaterToolMode) {
      sTx.textContent='click to demolish water infrastructure'; 
    } else {
      sTx.textContent='click to demolish buildings';
    }
    cTx.textContent='';
  }
  else if (tl) {
    const dn=tl.startsWith('park')?'park':tl;
    sTx.textContent=`placing ${dn}`;
    cTx.textContent=c>0?`$${fmtCompact(c)}`:'';
  }
  else { sTx.textContent='select a tool to start building'; cTx.textContent=''; }
}

// ===== Building Placement =====
function canPlLg(x,y,w,h,zt) {
  for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=GR_SZ||ny>=GR_SZ) return false;
    const c=st.grid[ny][nx]; 
    // Normalize empty cells to ensure they're 1x1
    if (c.type==='empty') normalizeEmptyCell(nx,ny);
    // Prevent merging through roads and other incompatible tiles
    if (c.type==='road') return false;
    if (c.type!=='empty' && c.type!==zt && !c.abandoned) return false;
    const tr=st.terrain[ny][nx]; if (tr==='water'||tr==='cliff') return false;
  }
  return true;
}

// Helper: given any cell in a building, find the building's top-left and size
function getBuildingBoundsFromCell(x,y) {
  const c=st.grid[y][x];
  if (!c) return {startX:x,startY:y,w:1,h:1};
  // If this cell has a buildingId, use it as the primary way to find bounds
  if (c.buildingId != null && c.type!=='empty') {
    const targetId = c.buildingId;
    const visited = new Set();
    const queue = [{x,y}];
    let minX = x, maxX = x, minY = y, maxY = y;

    while (queue.length>0) {
      const cur = queue.shift();
      const key = `${cur.x},${cur.y}`;
      if (visited.has(key)) continue;
      visited.add(key);
      if (cur.x<0 || cur.x>=GR_SZ || cur.y<0 || cur.y>=GR_SZ) continue;
      const cell = st.grid[cur.y][cur.x];
      if (!cell || cell.buildingId!==targetId) continue;

      if (cur.x<minX) minX=cur.x;
      if (cur.x>maxX) maxX=cur.x;
      if (cur.y<minY) minY=cur.y;
      if (cur.y>maxY) maxY=cur.y;

      queue.push({x:cur.x-1,y:cur.y});
      queue.push({x:cur.x+1,y:cur.y});
      queue.push({x:cur.x,y:cur.y-1});
      queue.push({x:cur.x,y:cur.y+1});
    }

    const w = maxX-minX+1;
    const h = maxY-minY+1;
    return {startX:minX,startY:minY,w,h};
  }

  // Fallback: legacy logic based on w/h only
  const baseW=c.w||1, baseH=c.h||1;

  // Single-tile structures (including empty zones) should never sweep across
  // adjacent tiles just because they share the same zone type. Treat them as
  // isolated cells so bulldozing/park placement only affects the clicked tile.
  if (baseW===1 && baseH===1) return {startX:x,startY:y,w:1,h:1};

  let startX = x;
  let startY = y;

  let stepsLeft = 0;
  while (startX > 0 && stepsLeft < baseW-1) {
    const left = st.grid[y][startX-1];
    if (left && left.type === c.type && (left.w||1) === baseW && (left.h||1) === baseH) {
      startX--;
      stepsLeft++;
    } else {
      break;
    }
  }

  let stepsUp = 0;
  while (startY > 0 && stepsUp < baseH-1) {
    const above = st.grid[startY-1][startX];
    if (above && above.type === c.type && (above.w||1) === baseW && (above.h||1) === baseH) {
      startY--;
      stepsUp++;
    } else {
      break;
    }
  }

  let consistent = true;
  for (let dy=0; dy<baseH && consistent; dy++) {
    for (let dx=0; dx<baseW; dx++) {
      const nx=startX+dx, ny=startY+dy;
      if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { consistent=false; break; }
      const cell=st.grid[ny][nx];
      if (!cell || cell.type!==c.type || (cell.w||1)!==baseW || (cell.h||1)!==baseH) {
        consistent=false;
        break;
      }
    }
  }
  if (!consistent) return {startX:x,startY:y,w:1,h:1};

  return {startX:startX, startY:startY, w:baseW, h:baseH};
}

function isTopLeftCell(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return false;
  const cell=st.grid[y][x];
  if (!cell) return false;
  const w=cell.w||1, h=cell.h||1;
  if (w===1 && h===1) return true;
  if (x>0) {
    const left=st.grid[y][x-1];
    if (left && left.type===cell.type && (left.w||1)===w && (left.h||1)===h) return false;
  }
  if (y>0) {
    const above=st.grid[y-1][x];
    if (above && above.type===cell.type && (above.w||1)===w && (above.h||1)===h) return false;
  }
  return true;
}

// Recompute buildingId metadata for all non-empty cells based on rectangular buildings
function rebuildBuildingIdsFromGrid() {
  nextBuildingId = 1;
  const visited = [];

  for (let y=0; y<GR_SZ; y++) {
    const row = [];
    for (let x=0; x<GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (cell && cell.type === 'empty') {
        cell.buildingId = null;
      } else if (cell) {
        cell.buildingId = undefined;
      }
      row.push(false);
    }
    visited.push(row);
  }

  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      if (visited[y][x]) continue;
      const cell = st.grid[y][x];
      if (!cell || cell.type === 'empty') {
        visited[y][x] = true;
        continue;
      }

      const w = cell.w || 1;
      const h = cell.h || 1;
      const buildingId = nextBuildingId++;

      let isRectangular = true;
      for (let dy=0; dy<h && isRectangular; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx = x+dx;
          const ny = y+dy;
          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) { isRectangular=false; break; }
          const target = st.grid[ny][nx];
          if (!target || target.type !== cell.type || (target.w||1)!==w || (target.h||1)!==h || visited[ny][nx]) {
            isRectangular = false;
            break;
          }
        }
      }

      if (!isRectangular) {
        cell.buildingId = buildingId;
        visited[y][x] = true;
        continue;
      }

      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx = x+dx;
          const ny = y+dy;
          if (nx<0 || nx>=GR_SZ || ny<0 || ny>=GR_SZ) continue;
          const target = st.grid[ny][nx];
          if (!target) continue;
          target.buildingId = buildingId;
          visited[ny][nx] = true;
        }
      }
    }
  }
}

function plcTl(x,y) {
  if (x<0||x>=GR_SZ||y<0||y>=GR_SZ) return; if (!st.selectedTool) return;
  const c=st.grid[y][x], tr=st.terrain[y][x];
  if (tr==='water'||tr==='cliff') { plySnd('error'); return; }
  if (st.selectedTool==='bulldoze') {
    // Check if we're in water tool mode
    const isWaterToolMode = activeSubmenu && activeSubmenu.submenuKey === 'water';
    
    if (isWaterToolMode) {
      // In water tool mode, only allow demolishing water-related items
      let removedWaterItem = false;
      
      // Remove pipes (can be on any tile)
      if (c.pipe) {
        delete c.pipe;
        normalizeEmptyCell(x,y);
        calculateWaterGrid();
        removedWaterItem = true;
      }
      
      // Remove water plants/towers (check the clicked cell)
      if (c.type === 'waterplant' || c.type === 'watertower') {
        const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);
        for (let dy=0; dy<h; dy++) {
          for (let dx=0; dx<w; dx++) {
            const nx=startX+dx, ny=startY+dy;
            if (nx<GR_SZ && ny<GR_SZ) {
              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
              normalizeEmptyCell(nx,ny);
            }
          }
        }
        calculateWaterGrid();
        removedWaterItem = true;
      }
      
      if (removedWaterItem) {
        plySnd('bulldoze');
        drGr(); sv();
      } else {
        plySnd('error');
      }
      return;
    }
    
    // Normal bulldoze mode (not in water tool mode)
    if (c.type!=='empty') {
      plySnd('bulldoze');

      // Roads: always bulldoze a single tile only
      if (c.type==='road') {
        st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
        normalizeEmptyCell(x,y);
        calculatePowerGrid();
  calculateWaterGrid(); // Recalculate power grid when roads are removed
        drGr(); sv();
        return;
      }
      
      // Pipes: remove pipe property (pipes overlay on tiles)
      if (c.pipe) {
        delete c.pipe;
        normalizeEmptyCell(x,y);
        calculateWaterGrid(); // Recalculate water grid when pipes are removed
        drGr(); sv();
        return;
      }
      
      // Check if removing a water plant
      const wasWaterPlant = c.type === 'waterplant' || c.type === 'watertower';
      

        const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);
        const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
        const isMultiTileBuilding=(w>1 || h>1);
        const isEmptyZoneCell=isZone && (c.level===0 || c.abandoned) && !isMultiTileBuilding;

        // Single-tile empty zones (fresh or abandoned) can be cleared one cell at a time.
        // Any merged/multi-tile structure should always clear its entire footprint to avoid "shifting" artifacts.
        if (isEmptyZoneCell) {
          st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
          normalizeEmptyCell(x,y);
        } else if (isMultiTileBuilding) {
          for (let dy=0; dy<h; dy++) {
            for (let dx=0; dx<w; dx++) {
              const nx=startX+dx, ny=startY+dy;
              if (nx<GR_SZ && ny<GR_SZ) {
                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
                normalizeEmptyCell(nx,ny);
              }
            }
          }
        } else {
          // All other buildings: only bulldoze the clicked cell
          st.grid[y][x]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
          normalizeEmptyCell(x,y);
        }
      
      // Recalculate power grid if a power plant was removed
      const wasPowerPlant = c.type === 'coal' || c.type === 'nuclear' || c.type === 'wind';
      if (wasPowerPlant) {
        calculatePowerGrid();
  calculateWaterGrid();
      }
      
      // Recalculate water grid if a water plant was removed
      if (wasWaterPlant) {
        calculateWaterGrid();
      }

      drGr(); sv();
    }
    return;
  }
  const isPk=st.selectedTool.startsWith('park');
  
  // For parks: allow placing on empty zones (level 0 or abandoned zones)
  if (isPk) {
    const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
    const isEmptyZone=isZone && (c.level===0 || c.abandoned);
    if (c.type!=='empty' && !isEmptyZone) return;
    
    const cs=COSTS[st.selectedTool]||0; 
    if (st.money<cs) { plySnd('error'); return; }
    
    plySnd('place'); 
    st.money-=cs;
    
    // If replacing an empty zone, replace the entire building
    if (isEmptyZone) {
      const {startX,startY,w,h}=getBuildingBoundsFromCell(x,y);
      // Replace all cells of the zone building with park
      const parkBuildingId = nextBuildingId++;
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=startX+dx, ny=startY+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            st.grid[ny][nx]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};
          }
        }
      }
      // Try to merge parks after placement (from the top-left)
      tryMrgPark(startX,startY);
    } else {
      // Normal placement on empty terrain
      const parkBuildingId = nextBuildingId++;
      st.grid[y][x]={type:st.selectedTool,age:0,level:1,w:1,h:1,buildingId:parkBuildingId};
      // Try to merge with adjacent parks of the same type
      tryMrgPark(x,y);
    }
  } else {
    // For non-park tools: only allow empty or abandoned
    // Determine building size
    let bw = 1, bh = 1;
    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear') {
      bw = 2; bh = 2; // 2x2 for coal and nuclear
    } else if (st.selectedTool === 'wind') {
      bw = 1; bh = 2; // 1x2 for wind
    } else if (st.selectedTool === 'waterplant') {
      bw = 2; bh = 2; // 2x2 for water treatment plant
    } else if (st.selectedTool === 'watertower') {
      bw = 1; bh = 1; // 1x1 for water tower
    } else if (st.selectedTool === 'pipe') {
      bw = 1; bh = 1; // 1x1 for pipes
    }
    
    // Check if we can place a multi-tile building
    if (bw > 1 || bh > 1) {
      // Check all cells are empty or abandoned
      let canPlace = true;
      for (let dy=0; dy<bh; dy++) {
        for (let dx=0; dx<bw; dx++) {
          const nx = x + dx, ny = y + dy;
          if (nx >= GR_SZ || ny >= GR_SZ) { canPlace = false; break; }
          const nc = st.grid[ny][nx];
          const ntr = st.terrain[ny][nx];
          if (ntr === 'water' || ntr === 'cliff') { canPlace = false; break; }
          if (nc.type !== 'empty' && !nc.abandoned) { canPlace = false; break; }
        }
        if (!canPlace) break;
      }
      // Water plants must be within 4 tiles of water
      if (canPlace && (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower')) {
        let nearWater = false;
        for (let dy=0; dy<bh; dy++) {
          for (let dx=0; dx<bw; dx++) {
            const nx = x + dx, ny = y + dy;
            if (isNearWaterTile(nx, ny, 4)) {
              nearWater = true;
              break;
            }
          }
          if (nearWater) break;
        }
        if (!nearWater) { canPlace = false; }
      }
      if (!canPlace) { plySnd('error'); return; }
    } else {
      // For single-tile buildings, check if pipe can overlay
      if (st.selectedTool === 'pipe') {
        // Pipes can overlay on any tile except cliff terrain and water plants
        if (tr === 'cliff') {
          plySnd('error');
          return;
        }
        // Cannot place pipes on water plants/towers
        if (c.type === 'waterplant' || c.type === 'watertower') {
          plySnd('error');
          return;
        }
        // Add pipe property to the cell
        if (!st.grid[y][x].pipe) {
          const cs=COSTS.pipe||0; 
          if (st.money<cs) { plySnd('error'); return; }
          st.grid[y][x].pipe = true;
          plySnd('place');
          st.money -= cs;
          calculateWaterGrid();
          drGr(); updUI(); sv();
        }
        return;
      }
      // Water towers must be within 4 tiles of water
      if (st.selectedTool === 'watertower' && !isNearWaterTile(x, y, 4)) {
        plySnd('error');
        return;
      }
      if (c.type!=='empty' && !c.abandoned) return;
    }
    
    const cs=COSTS[st.selectedTool]||0; 
    if (st.money<cs) { plySnd('error'); return; }
    plySnd('place'); 
    st.money-=cs;
    const buildingId = nextBuildingId++;
    
    // Place the building across all its cells
    for (let dy=0; dy<bh; dy++) {
      for (let dx=0; dx<bw; dx++) {
        const nx = x + dx, ny = y + dy;
        if (nx < GR_SZ && ny < GR_SZ) {
          st.grid[ny][nx]={type:st.selectedTool,age:0,level:0,w:bw,h:bh,buildingId:buildingId};
        }
      }
    }
    
    // Recalculate power grid if a power plant or road was placed
    if (st.selectedTool === 'coal' || st.selectedTool === 'nuclear' || st.selectedTool === 'wind' || st.selectedTool === 'road') {
      calculatePowerGrid();
  calculateWaterGrid();
    }
    
    // Recalculate water grid if a water plant or water tower was placed
    if (st.selectedTool === 'waterplant' || st.selectedTool === 'watertower') {
      calculateWaterGrid();
    }
  }
  drGr(); updUI(); sv();
}

function getCarSpeedMultiplier() {
  if (st.speed<=0) return 0;
  if (st.speed===500) return 3;
  if (st.speed===1500) return 2;
  return 1;
}

function getCarSpeedPerFrame(car) {
  const baseSpeed = CAR_BASE_SPEED * getCarSpeedMultiplier();
  // Police and fire cars move faster than normal cars
  if (car && (car.type === 'police' || car.type === 'fire')) {
    return baseSpeed * EMERGENCY_SPEED_MULTIPLIER;
  }
  return baseSpeed;
}

function updateCarLaneOffset(car) {
  if (car.pathIdx>=car.path.length-1) return;
  const curNode=car.path[car.pathIdx];
  const nextNode=car.path[car.pathIdx+1];
  const dxSeg=nextNode.x-curNode.x;
  const dySeg=nextNode.y-curNode.y;
    if (Math.abs(dxSeg)>Math.abs(dySeg)) {
      car.laneOffset=dxSeg>0 ? 5 : -5;
    } else {
      car.laneOffset=dySeg>0 ? -5 : 5;
    }
}

function getCarSegmentTarget(car) {
  const curNode=car.path[car.pathIdx];
  const nextNode=car.path[car.pathIdx+1];
  let tx=nextNode.x*CL_SZ+7;
  let ty=nextNode.y*CL_SZ+7;
  const dxSeg=nextNode.x-curNode.x;
  const dySeg=nextNode.y-curNode.y;
    const horizontal=Math.abs(dxSeg)>Math.abs(dySeg);
    if (horizontal) ty+=car.laneOffset;
    else tx+=car.laneOffset;
    
    const hasNextTurn=car.pathIdx+2<car.path.length;
    if (hasNextTurn) {
      const afterNode=car.path[car.pathIdx+2];
      const dxNext=afterNode.x-nextNode.x;
      const dyNext=afterNode.y-nextNode.y;
      const nextHorizontal=Math.abs(dxNext)>Math.abs(dyNext);
      if (horizontal && !nextHorizontal) {
        const nextLaneOffset=dyNext>0 ? -5 : 5;
        tx+=nextLaneOffset;
      } else if (!horizontal && nextHorizontal) {
        const nextLaneOffset=dxNext>0 ? 5 : -5;
        ty+=nextLaneOffset;
      }
    }
  return {tx,ty};
}

function getCanvasPos(e) {
  const r = cvs.getBoundingClientRect();
  const sx = cvs.width / r.width, sy = cvs.height / r.height;
  let clientX, clientY;
  
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
    lastTouchPos = { x: clientX, y: clientY };
  } else if (e.changedTouches && e.changedTouches.length > 0) {
    // For touchend events
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else if (lastTouchPos) {
    // Fallback to last known touch position
    clientX = lastTouchPos.x;
    clientY = lastTouchPos.y;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  
  const x = Math.floor((clientX - r.left) * sx / CL_SZ);
  const y = Math.floor((clientY - r.top) * sy / CL_SZ);
  return { x, y };
}

function placeLine(x0, y0, x1, y1) {
  const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy, x = x0, y = y0;
  const placed = new Set();
  
  while (true) {
    const key = `${x},${y}`;
    if (!placed.has(key)) {
      placed.add(key);
      plcTl(x, y);
    }
    if (x === x1 && y === y1) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x += sx; }
    if (e2 < dx) { err += dx; y += sy; }
  }
}

function placeZone(x0, y0, x1, y1) {
  const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
  const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
  const currentBounds = `${minX},${minY},${maxX},${maxY}`;
  
  // Only place if bounds changed to avoid redundant work
  if (currentBounds === lastZoneBounds) return;
  lastZoneBounds = currentBounds;
  
  for (let y = minY; y <= maxY; y++) {
    for (let x = minX; x <= maxX; x++) {
      plcTl(x, y);
    }
  }
}

function handleDragStart(e) {
  // On mobile (touch events), allow scrolling and only handle taps
  if (e.touches) {
    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    isDragging = false;
    isScrolling = false;
    // Don't prevent default - allow native scrolling
    return;
  }
  
  // Desktop mouse behavior
  // Don't start drag if stats view is active
  if (!st.selectedTool || showLandValueOverlay || showCrimeOverlay) return;
  
  const pos = getCanvasPos(e);
  dragStart = pos;
  lastPlaced = { x: pos.x, y: pos.y };
  lastZoneBounds = null; // Reset zone bounds tracking
  isDragging = true;
  isScrolling = false;
}

function handleDragMove(e) {
  // On mobile (touch events), allow native scrolling - don't place tiles while dragging
  if (e.touches) {
    if (touchStartPos) {
      const dx = Math.abs(e.touches[0].clientX - touchStartPos.x);
      const dy = Math.abs(e.touches[0].clientY - touchStartPos.y);
      // If moved significantly, mark as scrolling (not a tap)
      if (dx > 5 || dy > 5) {
        isScrolling = true;
      }
    }
    // Don't prevent default - allow native scrolling
    return;
  }
  
  // Desktop mouse behavior
  // Don't drag if stats view is active
  if (!st.selectedTool || !isDragging || !dragStart || showLandValueOverlay || showCrimeOverlay) return;
  
  const pos = getCanvasPos(e);
  
  // For roads: place as line
  if (st.selectedTool === 'road') {
    placeLine(dragStart.x, dragStart.y, pos.x, pos.y);
    dragStart = pos; // Update start for continuous line
  }
  // For RCI zones: place as zone
  else if (st.selectedTool === 'residential' || st.selectedTool === 'commercial' || st.selectedTool === 'industrial') {
    placeZone(dragStart.x, dragStart.y, pos.x, pos.y);
  }
  // For other tools: place individual tiles
  else {
    const key = `${pos.x},${pos.y}`;
    const lastKey = `${lastPlaced.x},${lastPlaced.y}`;
    if (key !== lastKey) {
      plcTl(pos.x, pos.y);
      lastPlaced = pos;
    }
  }
}

function handleDragEnd(e) {
  // Handle mobile tap (touch without scrolling)
  if (e.changedTouches && touchStartPos && !isScrolling) {
    const pos = getCanvasPos(e);
    
    // If stat view is active, show building info instead of placing tool
    if (showLandValueOverlay || showCrimeOverlay) {
      showBuildingInfo(pos.x, pos.y);
    } else if (st.selectedTool) {
      // This was a tap, not a scroll - place a tile
      plcTl(pos.x, pos.y);
    }
  }
  // Handle desktop mouse drag end
  else if (isDragging && !isScrolling && dragStart && !e.touches) {
    const pos = getCanvasPos(e);
    // If we didn't move much (or at all), treat as click
    const moved = Math.abs(pos.x - dragStart.x) > 0 || Math.abs(pos.y - dragStart.y) > 0;
    if (!moved) {
      // If stat view is active, show building info instead of placing tool
      if (showLandValueOverlay || showCrimeOverlay) {
        showBuildingInfo(pos.x, pos.y);
      } else if (st.selectedTool) {
        plcTl(pos.x, pos.y);
      }
    }
  }
  
  isDragging = false;
  isScrolling = false;
  dragStart = null;
  lastPlaced = null;
  touchStartPos = null;
  lastTouchPos = null;
  lastZoneBounds = null;
}

// Mouse events
cvs.addEventListener('mousedown', handleDragStart);
cvs.addEventListener('mousemove', handleDragMove);
cvs.addEventListener('mouseup', handleDragEnd);
cvs.addEventListener('mouseleave', (e) => {
  hoverPos = null;
  handleDragEnd(e);
});

// Track hover for placement preview
cvs.addEventListener('mousemove', (e) => {
  if (!isDragging && st.selectedTool && st.selectedTool !== 'bulldoze') {
    const pos = getCanvasPos(e);
    hoverPos = pos;
  } else {
    hoverPos = null;
  }
});

// Touch events - passive for smooth scrolling on mobile
cvs.addEventListener('touchstart', handleDragStart, { passive: true });
cvs.addEventListener('touchmove', handleDragMove, { passive: true });
cvs.addEventListener('touchend', handleDragEnd, { passive: true });
cvs.addEventListener('touchcancel', handleDragEnd, { passive: true });

// Click handler for mouse only (touch events are handled separately)
cvs.addEventListener('click', e => {
  // Only handle mouse clicks, not touch-generated clicks
  if (e.detail === 0) return; // Touch events have detail = 0
  if (!isDragging && !isScrolling) {
    const r = cvs.getBoundingClientRect(), sx = cvs.width / r.width, sy = cvs.height / r.height;
    const x = Math.floor((e.clientX - r.left) * sx / CL_SZ), y = Math.floor((e.clientY - r.top) * sy / CL_SZ);
    
    // If stat view is active, show building info instead of placing tool
    if (showLandValueOverlay || showCrimeOverlay) {
      showBuildingInfo(x, y);
    } else if (st.selectedTool) {
      plcTl(x, y);
    }
  }
});

const submenuItems = {
  park: [
    { tool: 'park', icon: 'üå≥', tooltip: 'park', shortcut: '1' },
    { tool: 'park2', icon: 'üå∏', tooltip: 'park', shortcut: '2' },
    { tool: 'park3', icon: 'üå≤', tooltip: 'park', shortcut: '3' },
    { tool: 'park4', icon: 'üåª', tooltip: 'park', shortcut: '4' }
  ],
  services: [
    { tool: 'police', icon: 'üöì', tooltip: 'police station', shortcut: '1' },
    { tool: 'fire', icon: 'üöí', tooltip: 'fire station', shortcut: '2' },
    { tool: 'school', icon: 'üè´', tooltip: 'school', shortcut: '3' },
    { tool: 'hospital', icon: 'üè•', tooltip: 'hospital', shortcut: '4' }
  ],
  water: [
    { tool: 'pipe', icon: 'üíß', tooltip: 'water pipe', shortcut: '1' },
    { tool: 'waterplant', icon: 'üè≠', tooltip: 'water treatment plant', shortcut: '2' },
    { tool: 'watertower', icon: 'üóº', tooltip: 'water tower', shortcut: '3' }
  ],
  power: [
    { tool: 'coal', icon: '‚ö°', tooltip: 'coal plant', shortcut: '1' },
    { tool: 'nuclear', icon: '‚ò¢Ô∏è', tooltip: 'nuclear plant', shortcut: '2' },
    { tool: 'wind', icon: 'üí®', tooltip: 'wind plant', shortcut: '3' }
  ],
  disaster: [
    { disaster: 'fire', icon: 'üî•', tooltip: 'fire', shortcut: '1' },
    { disaster: 'crime', icon: 'üö®', tooltip: 'crime', shortcut: '2' },
    { disaster: 'earthquake', icon: 'üåç', tooltip: 'earthquake', shortcut: '3' }
  ]
};

function openSubmenu(button, submenuKey) {
  // Don't close water submenu if switching to bulldoze
  if (activeSubmenu && activeSubmenu.submenuKey === 'water' && st.selectedTool === 'bulldoze') {
    // Keep water submenu open
  } else {
    // Close any existing submenu
    closeSubmenu();
  }
  
  // Store reference to the button
  activeSubmenu = { button, submenuKey };
  
  // Change button to X
  const originalContent = button.innerHTML;
  button.dataset.originalContent = originalContent;
  button.innerHTML = '‚úï';
  button.classList.add('submenu-active');
  
  // Get sub-toolbar
  const subToolbar = document.getElementById('subToolbar');
  
  // Populate sub-toolbar with items (but keep hidden for now)
  subToolbar.innerHTML = '';
  const items = submenuItems[submenuKey];
  items.forEach(item => {
    const subBtn = document.createElement('button');
    subBtn.className = 'tool-btn w-full aspect-square text-xl rounded transition-colors border border-transparent flex items-center justify-center';
    if (item.tool) {
      subBtn.dataset.tool = item.tool;
    }
    if (item.disaster) {
      subBtn.dataset.disaster = item.disaster;
    }
    if (item.tooltip) {
      subBtn.dataset.tooltip = item.tooltip;
      if (item.shortcut) {
        subBtn.dataset.shortcut = item.shortcut;
      }
      subBtn.addEventListener('mouseenter', () => {
        showTooltip(subBtn, item.tooltip);
      });
      subBtn.addEventListener('mouseleave', () => {
        hideTooltip();
      });
    }
    subBtn.textContent = item.icon;
    subBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      plySnd('click');
      if (item.tool) {
        selTl(item.tool);
        // Don't close submenu - keep it open so user can switch tools
      } else if (item.disaster) {
        // Trigger disaster and close submenu
        if (item.disaster === 'fire') {
          startFire();
        } else if (item.disaster === 'crime') {
          startCrimeEvent();
        } else if (item.disaster === 'earthquake') {
          startQuake();
        }
        closeSubmenu();
      }
    });
    subToolbar.appendChild(subBtn);
  });
  
  // Auto-select the first tool in the submenu (only for tools, not disasters)
  if (items.length > 0 && items[0].tool) {
    selTl(items[0].tool);
  }
  
  // Show water overlay when water submenu opens
  if (submenuKey === 'water') {
    setWaterOverlay(true);
  }
  
  // Make submenu invisible but rendered to measure it
  subToolbar.style.visibility = 'hidden';
  subToolbar.classList.remove('hidden');
  
  // Position submenu vertically centered on the toggle button
  requestAnimationFrame(() => {
    const parentContainer = button.closest('.flex.flex-shrink-0.relative');
    const parentRect = parentContainer.getBoundingClientRect();
    const buttonRect = button.getBoundingClientRect();
    const subToolbarRect = subToolbar.getBoundingClientRect();
    
    // Calculate positions relative to parent container
    const buttonTopRelative = buttonRect.top - parentRect.top;
    const buttonCenterY = buttonTopRelative + buttonRect.height / 2;
    const submenuHeight = subToolbarRect.height;
    const submenuCenterY = submenuHeight / 2;
    
    // Calculate top position to center submenu on button
    const topPosition = buttonCenterY - submenuCenterY;
    subToolbar.style.top = `${topPosition}px`;
    
    // Now make it visible
    subToolbar.style.visibility = '';
    
    updateToolSelection();
  });
}

function closeSubmenu() {
  if (activeSubmenu) {
    // Don't close water submenu if bulldoze is selected (water tool mode)
    if (activeSubmenu.submenuKey === 'water' && st.selectedTool === 'bulldoze') {
      return;
    }
    
    // Restore original button content
    if (activeSubmenu.button.dataset.originalContent) {
      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;
      activeSubmenu.button.classList.remove('submenu-active');
    }
    const wasWaterSubmenu = activeSubmenu.submenuKey === 'water';
    activeSubmenu = null;
    
    // Always hide water overlay when water submenu closes (unless bulldoze is selected)
    if (wasWaterSubmenu && st.selectedTool !== 'bulldoze') {
      setWaterOverlay(false);
    }
  }
  
  // Hide sub-toolbar and reset position
  const subToolbar = document.getElementById('subToolbar');
  subToolbar.classList.add('hidden');
  subToolbar.style.top = '';
  subToolbar.style.visibility = '';
}

function forceCloseSubmenu() {
  if (activeSubmenu) {
    // Restore original button content
    if (activeSubmenu.button.dataset.originalContent) {
      activeSubmenu.button.innerHTML = activeSubmenu.button.dataset.originalContent;
      activeSubmenu.button.classList.remove('submenu-active');
    }
    const wasWaterSubmenu = activeSubmenu.submenuKey === 'water';
    activeSubmenu = null;
    
    // Always hide water overlay when water submenu closes
    if (wasWaterSubmenu) {
      setWaterOverlay(false);
    }
  }
  
  // Hide sub-toolbar and reset position
  const subToolbar = document.getElementById('subToolbar');
  subToolbar.classList.add('hidden');
  subToolbar.style.top = '';
  subToolbar.style.visibility = '';
}

function updateToolSelection() {
  // Update all tool buttons including sub-toolbar buttons
  document.querySelectorAll('.tool-btn').forEach(b => {
    const bt = b.dataset.tool;
    b.style.borderColor = '';
    b.style.opacity = '';
    if (bt === st.selectedTool) {
      b.style.borderColor = '#666';
      b.style.opacity = '1';
    } else {
      // All other unselected buttons get reduced opacity (including submenu toggle showing X and disaster buttons)
      b.style.opacity = '0.5';
    }
  });
}

// Create tooltip element
let tooltipEl = null;
function createTooltip() {
  if (!tooltipEl) {
    tooltipEl = document.createElement('div');
    tooltipEl.className = 'tooltip';
    document.body.appendChild(tooltipEl);
  }
  return tooltipEl;
}

function showTooltip(button, text) {
  // Only show on devices that support hover
  if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {
    const tooltip = createTooltip();
    const shortcut = button.dataset.shortcut;
    if (shortcut) {
      tooltip.innerHTML = `${text}<span class="tooltip-shortcut">${shortcut}</span>`;
    } else {
      tooltip.textContent = text;
    }
    tooltip.classList.add('show');
    
    const rect = button.getBoundingClientRect();
    tooltip.style.left = `${rect.left - tooltip.offsetWidth - 8}px`;
    tooltip.style.top = `${rect.top + rect.height / 2}px`;
    tooltip.style.transform = 'translateY(-50%)';
    
    // Recalculate position after tooltip is rendered
    setTimeout(() => {
      const tooltipRect = tooltip.getBoundingClientRect();
      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;
    }, 0);
  }
}

function hideTooltip() {
  if (tooltipEl) {
    tooltipEl.classList.remove('show');
  }
}

// Keyboard shortcut mapping
const keyToTool = {
  'r': 'road',
  'R': 'road',
  'h': 'residential',
  'H': 'residential',
  'c': 'commercial',
  'C': 'commercial',
  'i': 'industrial',
  'I': 'industrial',
  'p': 'park',
  'P': 'park',
  's': 'services',
  'S': 'services',
  'e': 'power',
  'E': 'power',
  'q': 'water',
  'Q': 'water',
  'd': 'bulldoze',
  'D': 'bulldoze',
  'w': 'disaster',
  'W': 'disaster'
};

function triggerToolByKey(key) {
  const tool = keyToTool[key];
  if (!tool) return false;
  
  // Find the button for this tool
  if (tool === 'disaster') {
    const disasterBtn = document.querySelector('[data-submenu="disaster"]');
    if (disasterBtn && st.disastersEnabled) {
      if (activeSubmenu && activeSubmenu.button === disasterBtn) {
        closeSubmenu();
      } else {
        openSubmenu(disasterBtn, 'disaster');
      }
      return true;
    }
  } else if (tool === 'park') {
    const parkBtn = document.querySelector('[data-submenu="park"]');
    if (parkBtn) {
      if (activeSubmenu && activeSubmenu.button === parkBtn) {
        closeSubmenu();
      } else {
        openSubmenu(parkBtn, 'park');
      }
      return true;
    }
  } else if (tool === 'services') {
    const servicesBtn = document.querySelector('[data-submenu="services"]');
    if (servicesBtn) {
      if (activeSubmenu && activeSubmenu.button === servicesBtn) {
        closeSubmenu();
      } else {
        openSubmenu(servicesBtn, 'services');
      }
      return true;
    }
  } else if (tool === 'power') {
    const powerBtn = document.querySelector('[data-submenu="power"]');
    if (powerBtn) {
      if (activeSubmenu && activeSubmenu.button === powerBtn) {
        closeSubmenu();
      } else {
        openSubmenu(powerBtn, 'power');
      }
      return true;
    }
  } else if (tool === 'water') {
    const waterBtn = document.querySelector('[data-submenu="water"]');
    if (waterBtn) {
      if (activeSubmenu && activeSubmenu.button === waterBtn) {
        closeSubmenu();
      } else {
        openSubmenu(waterBtn, 'water');
      }
      return true;
    }
  } else {
    const toolBtn = document.querySelector(`[data-tool="${tool}"]`);
    if (toolBtn) {
      toolBtn.click();
      return true;
    }
  }
  return false;
}

// Handle submenu shortcuts when submenu is open
function handleSubmenuShortcut(key) {
  if (!activeSubmenu) return false;
  
  if (activeSubmenu.submenuKey === 'disaster') {
    const shortcuts = { '1': 'fire', '2': 'crime', '3': 'earthquake' };
    const disaster = shortcuts[key];
    if (disaster) {
      const subBtn = document.querySelector(`[data-disaster="${disaster}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  } else if (activeSubmenu.submenuKey === 'park') {
    const shortcuts = { '1': 'park', '2': 'park2', '3': 'park3', '4': 'park4' };
    const parkTool = shortcuts[key];
    if (parkTool) {
      const subBtn = document.querySelector(`[data-tool="${parkTool}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  } else if (activeSubmenu.submenuKey === 'services') {
    const shortcuts = { '1': 'police', '2': 'fire', '3': 'school', '4': 'hospital' };
    const servicesTool = shortcuts[key];
    if (servicesTool) {
      const subBtn = document.querySelector(`[data-tool="${servicesTool}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  } else if (activeSubmenu.submenuKey === 'power') {
    const shortcuts = { '1': 'coal', '2': 'nuclear', '3': 'wind' };
    const powerTool = shortcuts[key];
    if (powerTool) {
      const subBtn = document.querySelector(`[data-tool="${powerTool}"]`);
      if (subBtn) {
        subBtn.click();
        return true;
      }
    }
  }
  return false;
}

function setSpeedByNumber(num) {
  plySnd('click');
  if (num === 0) {
    st.speed = 0;
  } else if (num === 1) {
    st.speed = 3000;
  } else if (num === 2) {
    st.speed = 1500;
  } else if (num === 3) {
    st.speed = 500;
  }
  sv();
  if (tkTmr) clearInterval(tkTmr);
  if (st.speed > 0) {
    TK_INT = st.speed;
    tkTmr = setInterval(simTk, TK_INT);
    updNwsTk();
  } else {
    updNwsTk();
  }
  updUI();
}

document.addEventListener('keydown', (e) => {
  // Don't trigger if user is typing in an input field
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
    return;
  }
  
  // Handle speed controls (0-3) only if no submenu is open
  if (!activeSubmenu && (e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3')) {
    const num = parseInt(e.key);
    setSpeedByNumber(num);
    e.preventDefault();
    return;
  }
  
  // Handle submenu shortcuts when submenu is open
  if (handleSubmenuShortcut(e.key)) {
    e.preventDefault();
    return;
  }
  
  // Handle main tool shortcuts
  if (triggerToolByKey(e.key)) {
    e.preventDefault();
  }
});

document.querySelectorAll('.tool-btn').forEach(b => {
  const tooltipText = b.dataset.tooltip;
  if (tooltipText) {
    b.addEventListener('mouseenter', () => {
      showTooltip(b, tooltipText);
    });
    b.addEventListener('mouseleave', () => {
      hideTooltip();
    });
  }
  
  b.addEventListener('click', (e) => {
    plySnd('click');
    hideTooltip();
    
    // Check if this button has a submenu
    if (b.dataset.submenu) {
      // If submenu is already open, close it (force close to handle water+bulldoze case)
      if (activeSubmenu && activeSubmenu.button === b) {
        forceCloseSubmenu();
      } else {
        // Open submenu
        openSubmenu(b, b.dataset.submenu);
      }
    } else if (b.dataset.tool) {
      // Regular tool selection
      selTl(b.dataset.tool);
      closeSubmenu();
    }
  });
});

function updateDisasterButtonsVisibility() {
  const disasterButtons = document.querySelectorAll('.disaster-btn');
  disasterButtons.forEach(btn => {
    btn.style.display = st.disastersEnabled ? 'flex' : 'none';
  });
}

function centerCanvas() {
  const gridContainer = document.getElementById('grid');
  if (!gridContainer) return;
  
  // Wait for next frame to ensure layout is calculated
  requestAnimationFrame(() => {
    const zoom = st.zoom || 1;
    const canvasWidth = cvs.width * zoom;
    const canvasHeight = cvs.height * zoom;
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // If canvas is smaller than container, center it with CSS
    if (canvasWidth <= containerWidth && canvasHeight <= containerHeight) {
      // Center using flexbox or margin auto
      gridContainer.style.display = 'flex';
      gridContainer.style.justifyContent = 'center';
      gridContainer.style.alignItems = 'center';
      gridContainer.scrollLeft = 0;
      gridContainer.scrollTop = 0;
    } else {
      // Canvas is larger, use scroll positioning
      gridContainer.style.display = 'block';
      gridContainer.style.justifyContent = '';
      gridContainer.style.alignItems = '';
      
      // Calculate scroll position to center the canvas
      const scrollLeft = Math.max(0, (canvasWidth - containerWidth) / 2);
      const scrollTop = Math.max(0, (canvasHeight - containerHeight) / 2);
      
      gridContainer.scrollLeft = scrollLeft;
      gridContainer.scrollTop = scrollTop;
    }
  });
}

function applyZoom() {
  if (!st.zoom) st.zoom = 1;
  cvs.style.transform = `scale(${st.zoom})`;
  cvs.style.transformOrigin = 'top left';
  document.getElementById('zoomLevel').textContent = Math.round(st.zoom * 100) + '%';
  sv();
  centerCanvas();
}

function zoomIn() {
  if (!st.zoom) st.zoom = 1;
  st.zoom = Math.min(3, st.zoom + 0.25);
  applyZoom();
}

function zoomOut() {
  if (!st.zoom) st.zoom = 1;
  st.zoom = Math.max(0.25, st.zoom - 0.25);
  applyZoom();
}

function zoomReset() {
  st.zoom = 1;
  applyZoom();
}

document.getElementById('zoomInBtn').addEventListener('click', () => { plySnd('click'); zoomIn(); });
document.getElementById('zoomOutBtn').addEventListener('click', () => { plySnd('click'); zoomOut(); });

const inpNm=document.getElementById('cityName');
inpNm.addEventListener('focus', () => edtNm=true);
inpNm.addEventListener('blur', () => { edtNm=false; st.cityName=inpNm.value||'new city'; sv(); updUI(); });
inpNm.addEventListener('input', () => updInpWd());
inpNm.addEventListener('change', e => { st.cityName=e.target.value||'new city'; sv(); });
inpNm.addEventListener('click', e => e.target.select());

document.getElementById('menuBtn').addEventListener('click', () => {
  plySnd('click'); const m=document.getElementById('menu'); m.classList.toggle('hidden');
  document.getElementById('newGamePanel').classList.add('hidden'); 
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
});

document.getElementById('speedToggle').addEventListener('click', () => {
  plySnd('click');
  if (st.speed===0) st.speed=3000; else if (st.speed===3000) st.speed=1500; else if (st.speed===1500) st.speed=500; else st.speed=0;
  sv(); if (tkTmr) clearInterval(tkTmr);
  if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); updNwsTk(); }
  else updNwsTk();
  updUI();
});

const exportBtn = document.getElementById('exportBtn');
if (exportBtn) {
  exportBtn.addEventListener('click', () => {
    try { plySnd('click'); } catch(e) {}
    try {
      const stateJson = JSON.stringify(st, null, 2);
      const cityName = (st.cityName || 'city').replace(/[^a-z0-9]/gi, '_').toLowerCase();
      const dateStr = new Date().toISOString().split('T')[0];
      const filename = `${cityName}_${dateStr}.json`;
      
      let url;
      let useBlob = true;
      try {
        const blob = new Blob([stateJson], { type: 'application/json' });
        url = URL.createObjectURL(blob);
      } catch (e) {
        useBlob = false;
        url = 'data:application/json;charset=utf-8,' + encodeURIComponent(stateJson);
      }
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        if (useBlob && url) URL.revokeObjectURL(url);
      }, 100);
    } catch (e) {
      console.error('Export failed:', e);
      alert('Export failed: ' + (e.message || String(e)));
    }
  });
}

document.getElementById('importBtn').addEventListener('click', () => {
  plySnd('click');
  document.getElementById('importFileInput').click();
});

document.getElementById('importFileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const importedState = JSON.parse(event.target.result);
      if (importedState.grid && importedState.grid.length === GR_SZ) {
        st = importedState;
        if (!st.rDemand) st.rDemand = 50;
        if (!st.cDemand) st.cDemand = 50;
        if (!st.iDemand) st.iDemand = 50;
        if (!st.year) st.year = 1990;
        if (!st.newsEvents) st.newsEvents = [];
        if (!st.ticksSinceNews) st.ticksSinceNews = 0;
        if (st.taxRate === undefined) st.taxRate = 10;
        if (!st.terrain) st.terrain = genTerr('balanced');
        if (!st.landValue) {
          st.landValue = [];
          for (let y = 0; y < GR_SZ; y++) {
            const vr = [];
            for (let x = 0; x < GR_SZ; x++) vr.push(50);
            st.landValue.push(vr);
          }
        }
        if (!st.crime) {
          st.crime = [];
          for (let y = 0; y < GR_SZ; y++) {
            const cr = [];
            for (let x = 0; x < GR_SZ; x++) cr.push(30);
            st.crime.push(cr);
          }
        }
        if (!st.fires) st.fires = [];
        if (!st.employment) st.employment = 0;
        if (!st.cars) st.cars = [];
        if (!st.crimeEvents) st.crimeEvents = [];
        st.stationDispatches = {};
        if (st.cars && st.cars.length > 0) {
          st.cars.forEach(car => {
            if (car.stationKey) incrementStationDispatchCount(car.stationKey);
          });
        }
        if (!st.zoom) st.zoom = 1;
        if (st.disastersEnabled === undefined) st.disastersEnabled = true;
        if (!st.powerGrid) initPowerGrid();
        sv();
        if (tkTmr) clearInterval(tkTmr);
        if (st.speed > 0) {
          TK_INT = st.speed;
          tkTmr = setInterval(simTk, TK_INT);
          updNwsTk();
        } else {
          updNwsTk();
        }
        drGr();
        updUI();
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('aiPanel').classList.add('hidden');
        document.getElementById('infoPanel').classList.add('hidden');
        currentInfoType = null;
        setLandValueOverlay(false);
        setCrimeOverlay(false);
        setTimeout(centerCanvas, 100);
      } else {
        alert('Invalid city file format');
      }
    } catch (error) {
      console.error('Import failed:', error);
      alert('Failed to import city file');
    }
    e.target.value = '';
  };
  reader.readAsText(file);
});

document.getElementById('newCityBtn').addEventListener('click', () => { 
  plySnd('click'); 
  document.getElementById('newCityName').value = '';
  document.getElementById('menu').classList.add('hidden'); 
  document.getElementById('newGamePanel').classList.remove('hidden'); 
});

function generateRandomCityName() {
  const prefixes = ['new', 'port', 'lake', 'river', 'green', 'sun', 'oak', 'maple', 'pine', 'cedar', 'spring', 'summer', 'winter', 'bay', 'hill', 'valley', 'mountain', 'forest', 'park', 'bridge', 'mill', 'brook', 'rock', 'stone', 'bright', 'fair', 'grand', 'royal', 'silver', 'golden'];
  const suffixes = ['ville', 'burg', 'ton', 'field', 'wood', 'dale', 'brook', 'haven', 'port', 'shore', 'view', 'ridge', 'crest', 'peak', 'falls', 'springs', 'beach', 'bay', 'city', 'town', 'land', 'ford', 'bridge', 'mill', 'park', 'grove', 'heights', 'hills', 'valley', 'creek'];
  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
  const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
  const cityName = prefix + suffix;
  return cityName.charAt(0).toUpperCase() + cityName.slice(1);
}

document.getElementById('startGameBtn').addEventListener('click', () => {
  plySnd('click');
  const inputValue = document.getElementById('newCityName').value.trim();
  const nm = inputValue || generateRandomCityName(), tr=document.getElementById('terrainType').value, df=document.getElementById('difficulty').value;
  let mn=50000; if (df==='easy') mn=100000; else if (df==='hard') mn=20000;
  aiReq=false; initGr(tr); st.money=mn; st.population=0; st.happiness=70; st.tickCount=0; st.cityName=nm; st.rDemand=50; st.cDemand=50; st.iDemand=50; st.year=1950; st.newsEvents=['Welcome to '+nm+'!']; st.ticksSinceNews=0; st.employment=0; st.taxRate=10;
  if (!st.zoom) st.zoom=1;
  drGr(); updUI(); updNwsTk(); sv();
  document.getElementById('newGamePanel').classList.add('hidden');
  document.getElementById('aiPanel').classList.add('hidden');
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
  setTimeout(centerCanvas, 100);
});

document.getElementById('aiSuggestBtn').addEventListener('click', async () => {
  plySnd('click'); document.getElementById('menu').classList.add('hidden'); document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
  setWaterOverlay(false);
  const pnl=document.getElementById('aiPanel'), msg=document.getElementById('aiMessage');
  pnl.classList.remove('hidden'); msg.innerHTML='<span class="text-neutral-500">thinking...</span>';
  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);
  const prm=`You are an AI mayor advisor for a SimCity-like game. Analyze the current city state and give 2-3 SHORT, actionable suggestions (1-2 sentences total).\n\nCurrent city stats:\n- Money: $${st.money.toLocaleString()}\n- Population: ${st.population}\n- Happiness: ${st.happiness}/100\n- Buildings: ${JSON.stringify(cnts)}\n- RCI Demand: R=${st.rDemand}% C=${st.cDemand}% I=${st.iDemand}%\n\nAvailable building types: road, residential, commercial, industrial, park, police, fire, school, hospital\n\nGive practical advice based on what's missing or unbalanced. Keep it brief and conversational.`;
  try {
    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});
    if (!r.ok) throw new Error('AI request failed');
    const d=await r.json(), rp=d.reply||'everything looks good!';
    msg.textContent=''; let i=0;
    const tw=setInterval(() => { if (i<rp.length) { msg.textContent+=rp.charAt(i); i++; } else clearInterval(tw); },20);
  } catch(e) { console.error('AI error:',e); msg.textContent='could not reach AI mayor. try building more infrastructure!'; }
});

document.getElementById('closeAiBtn').addEventListener('click', () => { plySnd('click'); document.getElementById('aiPanel').classList.add('hidden'); });
document.getElementById('closeInfoBtn').addEventListener('click', () => {
  plySnd('click');
  document.getElementById('infoPanel').classList.add('hidden');
  currentInfoType = null;
  setLandValueOverlay(false);
  setCrimeOverlay(false);
  setWaterOverlay(false);
});

function statItem(label, value, colorClass = '') {
  return `<div class="flex flex-col flex-shrink-0"><div class="text-xs text-neutral-400">${label}</div><div class="${colorClass}">${value}</div></div>`;
}

function getStatsContent(infoType) {
  const cnts = {};
  st.grid.flat().forEach(c => cnts[c.type] = (cnts[c.type] || 0) + 1);
  const getCount = type => cnts[type] || 0;
  
  let content = '';
  let title = '';
  
  if (infoType === 'rci') {
    title = 'City Stats';
    
    // Get power and water stats with details
    const powerStats = calculatePowerStats(true);
    const powerSurplus = powerStats.powerSurplus;
    const powerColor = powerSurplus >= 0 ? 'text-green-500' : 'text-red-500';
    const powerDisplay = powerSurplus >= 0 ? `+${powerSurplus}` : powerSurplus.toString();
    
    const waterStats = calculateWaterStats(true);
    const waterSurplus = waterStats.waterSurplus;
    const waterColor = waterSurplus >= 0 ? 'text-green-500' : 'text-red-500';
    const waterDisplay = waterSurplus >= 0 ? `+${waterSurplus}` : waterSurplus.toString();
    
    content = `
      <div class="space-y-3">
        <div>
          <div class="text-xs text-neutral-500 mb-1">RCI Demand</div>
          <div class="flex flex-wrap gap-6 py-2">
            ${statItem('residential', `${st.rDemand}%`, 'text-green-500')}
            ${statItem('commercial', `${st.cDemand}%`, 'text-blue-500')}
            ${statItem('industrial', `${st.iDemand}%`, 'text-yellow-500')}
          </div>
        </div>
        <div class="h-px w-full bg-neutral-700"></div>
        <div>
          <div class="text-xs text-neutral-500 mb-1">‚ö° Power</div>
          <div class="flex flex-wrap gap-6 py-2">
            ${statItem('generation', `+${powerStats.totalPowerGeneration}`, 'text-green-500')}
            ${statItem('consumption', `-${powerStats.totalPowerConsumption}`, 'text-red-500')}
            ${statItem('surplus', powerDisplay, powerColor)}
          </div>
          <div class="flex flex-wrap gap-6 py-1 text-xs">
            ${powerStats.coalCount > 0 ? statItem('Coal', `+${powerStats.coalGen} (${powerStats.coalCount})`, '') : ''}
            ${powerStats.nuclearCount > 0 ? statItem('Nuclear', `+${powerStats.nuclearGen} (${powerStats.nuclearCount})`, '') : ''}
            ${powerStats.windCount > 0 ? statItem('Wind', `+${powerStats.windGen} (${powerStats.windCount})`, '') : ''}
          </div>
        </div>
        <div class="h-px w-full bg-neutral-700"></div>
        <div>
          <div class="text-xs text-neutral-500 mb-1">üíß Water</div>
          <div class="flex flex-wrap gap-6 py-2">
            ${statItem('generation', `+${waterStats.totalWaterGeneration}`, 'text-green-500')}
            ${statItem('consumption', `-${waterStats.totalWaterConsumption}`, 'text-red-500')}
            ${statItem('surplus', waterDisplay, waterColor)}
          </div>
          <div class="flex flex-wrap gap-6 py-1 text-xs">
            ${waterStats.waterplantCount > 0 ? statItem('Treatment', `+${waterStats.waterplantGen} (${waterStats.waterplantCount})`, '') : ''}
            ${waterStats.watertowerCount > 0 ? statItem('Tower', `+${waterStats.watertowerGen} (${waterStats.watertowerCount})`, '') : ''}
          </div>
        </div>
      </div>
      <div class="mt-3 text-xs text-neutral-400">Power flows via roads, water via pipes. Negative values indicate shortage.</div>`;
  } else if (infoType === 'pop') {
    title = 'Population';
    const bPR=10; let popL1=0, popL2=0, popL3=0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x];
      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
        const sM=(c.w||1)*(c.h||1);
        if (c.level===3) popL3+=Math.floor(bPR*sM*1.5);
        else if (c.level===2) popL2+=Math.floor(bPR*sM*1.2);
        else if (c.level>=1) popL1+=Math.floor(bPR*sM*1);
      }
    }
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('total', fmtCompact(st.population))}${statItem('zones', cnts.residential||0)}${statItem('employment', `${st.employment}%`)}${statItem('L1', fmtCompact(popL1))}${statItem('L2', fmtCompact(popL2))}${statItem('L3', fmtCompact(popL3))}</div><div class="mt-3 text-xs text-neutral-400">Build more residential zones to grow, levels upgrade with parks, services, and education</div>`;
  } else if (infoType === 'power') {
    title = 'Energy';
    // Calculate power stats with detailed breakdown
    const powerStats = calculatePowerStats(true);
    const powerSurplus = powerStats.powerSurplus;
    const powerColor = powerSurplus >= 0 ? 'text-green-500' : 'text-red-500';
    const surplusDisplay = powerSurplus >= 0 ? `+${powerSurplus}` : powerSurplus.toString();
    
    content = `<div class="flex flex-wrap gap-6 py-2">
      ${statItem('generation', `+${powerStats.totalPowerGeneration}`, 'text-green-500')}
      ${statItem('consumption', `-${powerStats.totalPowerConsumption}`, 'text-red-500')}
      ${statItem('surplus', surplusDisplay, powerColor)}
    </div>
    <div class="mt-2 space-y-2">
      <div>
        <div class="h-px w-full bg-neutral-700 mb-1"></div>
        <div class="flex flex-wrap gap-6 py-2">
          ${powerStats.coalCount > 0 ? statItem('Coal', `+${powerStats.coalGen} (${powerStats.coalCount})`, '') : ''}
          ${powerStats.nuclearCount > 0 ? statItem('Nuclear', `+${powerStats.nuclearGen} (${powerStats.nuclearCount})`, '') : ''}
          ${powerStats.windCount > 0 ? statItem('Wind', `+${powerStats.windGen} (${powerStats.windCount})`, '') : ''}
          ${powerStats.coalCount === 0 && powerStats.nuclearCount === 0 && powerStats.windCount === 0 ? '<div class="text-xs text-neutral-500">No power plants built</div>' : ''}
        </div>
      </div>
      <div>
        <div class="h-px w-full bg-neutral-700 mb-1"></div>
        <div class="flex flex-wrap gap-6 py-2">
          ${powerStats.residentialConsumption > 0 ? statItem('Residential', `-${powerStats.residentialConsumption}`, 'text-green-500') : ''}
          ${powerStats.commercialConsumption > 0 ? statItem('Commercial', `-${powerStats.commercialConsumption}`, 'text-blue-500') : ''}
          ${powerStats.industrialConsumption > 0 ? statItem('Industrial', `-${powerStats.industrialConsumption}`, 'text-yellow-500') : ''}
          ${powerStats.totalPowerConsumption === 0 ? '<div class="text-xs text-neutral-500">No buildings consuming power</div>' : ''}
        </div>
      </div>
    </div>
    <div class="mt-2 text-xs text-neutral-400">Power flows via roads from power plants. L2+L3 residential, all commercial and industrial require power.</div>`;
  } else if (infoType === 'water') {
    title = 'Water';
    // Calculate water stats with detailed breakdown
    const waterStats = calculateWaterStats(true);
    const waterSurplus = waterStats.waterSurplus;
    const waterColor = waterSurplus >= 0 ? 'text-green-500' : 'text-red-500';
    const surplusDisplay = waterSurplus >= 0 ? `+${waterSurplus}` : waterSurplus.toString();
    
    content = `<div class="flex flex-wrap gap-6 py-2">
      ${statItem('generation', `+${waterStats.totalWaterGeneration}`, 'text-green-500')}
      ${statItem('consumption', `-${waterStats.totalWaterConsumption}`, 'text-red-500')}
      ${statItem('surplus', surplusDisplay, waterColor)}
    </div>
    <div class="mt-2 space-y-2">
      <div>
        <div class="h-px w-full bg-neutral-700 mb-1"></div>
        <div class="flex flex-wrap gap-6 py-2">
          ${waterStats.waterplantCount > 0 ? statItem('Treatment Plant', `+${waterStats.waterplantGen} (${waterStats.waterplantCount})`, '') : ''}
          ${waterStats.watertowerCount > 0 ? statItem('Water Tower', `+${waterStats.watertowerGen} (${waterStats.watertowerCount})`, '') : ''}
          ${waterStats.waterplantCount === 0 && waterStats.watertowerCount === 0 ? '<div class="text-xs text-neutral-500">No water infrastructure built</div>' : ''}
        </div>
      </div>
      <div>
        <div class="h-px w-full bg-neutral-700 mb-1"></div>
        <div class="flex flex-wrap gap-6 py-2">
          ${waterStats.residentialConsumption > 0 ? statItem('Residential', `-${waterStats.residentialConsumption}`, 'text-green-500') : ''}
          ${waterStats.commercialConsumption > 0 ? statItem('Commercial', `-${waterStats.commercialConsumption}`, 'text-blue-500') : ''}
          ${waterStats.industrialConsumption > 0 ? statItem('Industrial', `-${waterStats.industrialConsumption}`, 'text-yellow-500') : ''}
          ${waterStats.totalWaterConsumption === 0 ? '<div class="text-xs text-neutral-500">No buildings consuming water</div>' : ''}
        </div>
      </div>
    </div>
    <div class="mt-2 text-xs text-neutral-400">Water flows via pipes from water plants/towers. All L1+ buildings require water.</div>`;
  } else if (infoType === 'money') {
    title = 'Budget';
    // Calculate income breakdown (same logic as simTk)
    let residentialIncome = 0, commercialRevenue = 0, industrialRevenue = 0, tourismIncome = 0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x];
      if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
        const lv=st.landValue[y][x]||50;
        const level=c.level||0;
        const size=(c.w||1)*(c.h||1);
        const baseTax=2.5; // Increased to balance expenses
        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));
        const landValueMultiplier=1+(lv-50)/100;
        const popPerCell=Math.floor(10*size*levelMultiplier);
        residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);
      } else if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {
        const lv=st.landValue[y][x]||50;
        const level=c.level||0;
        const size=(c.w||1)*(c.h||1);
        const baseRevenue=18; // Increased to balance expenses
        const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));
        const landValueMultiplier=1+(lv-50)/80;
        const employmentMultiplier=0.5+(st.employment/200);
        const populationMultiplier=Math.min(2.0,1+(st.population/5000));
        commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);
      } else if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {
        const lv=st.landValue[y][x]||50;
        const level=c.level||0;
        const size=(c.w||1)*(c.h||1);
        const baseRevenue=24; // Increased to balance expenses
        const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));
        const landValueMultiplier=1+(lv-50)/100;
        const employmentMultiplier=0.4+(st.employment/167);
        industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);
      } else if (c.type && c.type.startsWith('park')) {
        const size=(c.w||1)*(c.h||1);
        const baseTourism=6; // Increased to balance expenses
        const populationMultiplier=Math.min(3.0,1+(st.population/3000));
        const happinessMultiplier=0.7+(st.happiness/143);
        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);
      }
    }
    const taxMultiplier=0.5+(st.taxRate/20);
    const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);
    
    // Calculate maintenance (same logic as simTk) - UPDATED
    let buildingMaintenance = 0, infrastructureCost = 0, serviceCosts = 0, crimeExpenses = 0, roadMaintenanceBonus = 0, powerPlantMaintenance = 0;
    
    // Base building maintenance
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x];
      if (c.type==='road') buildingMaintenance+=2;
      else if (c.type==='residential' && !c.abandoned) {
        const level=c.level||0;
        const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));
        buildingMaintenance+=Math.floor(5*levelMultiplier);
      }
      else if (c.type==='commercial' && !c.abandoned) {
        const level=c.level||0;
        const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));
        buildingMaintenance+=Math.floor(8*levelMultiplier);
      }
      else if (c.type==='industrial' && !c.abandoned) {
        const level=c.level||0;
        const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));
        buildingMaintenance+=Math.floor(12*levelMultiplier);
      }
      else if (c.type && c.type.startsWith('park')) buildingMaintenance+=4;
      else if (c.type==='police') buildingMaintenance+=25;
      else if (c.type==='fire') buildingMaintenance+=25;
      else if (c.type==='school') buildingMaintenance+=40;
      else if (c.type==='hospital') buildingMaintenance+=60;
      else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {
        const maint = POWER_PLANT_MAINTENANCE[c.type] || 0;
        powerPlantMaintenance += maint;
      }
    }
    
    // Population-based costs
    if (st.population > 0) {
      infrastructureCost = Math.floor(st.population * 0.5);
      
      // Service operation costs
      let avgCrime = 0;
      for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
        avgCrime += st.crime[y][x] || 30;
      }
      avgCrime = avgCrime / (GR_SZ * GR_SZ);
      const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100));
      const fireOpCost = Math.floor(st.population * 0.2);
      const educationCost = Math.floor(st.population * 0.4);
      const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));
      serviceCosts = policeOpCost + fireOpCost + educationCost + healthCost;
      
      // Crime expenses
      if (avgCrime > 40) {
        crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20);
      }
    }
    
    // Road maintenance bonus
    const rdC = getCount('road');
    roadMaintenanceBonus = Math.floor(rdC * 0.1);
    
    const totalMaintenance = buildingMaintenance + powerPlantMaintenance + infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;
    const netIncome = totalIncome - totalMaintenance;
    
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('balance', `$${st.money.toLocaleString()}`)}${statItem('income/mo', netIncome>=0?`+$${netIncome.toLocaleString()}`:`-$${Math.abs(netIncome).toLocaleString()}`, netIncome>=0?'text-green-500':'text-red-400')}${statItem('expenses/mo', `-$${totalMaintenance.toLocaleString()}`, 'text-red-400')}</div>
      <div class="mt-2 space-y-2">
        <div>
          <div class="h-px w-full bg-neutral-700 mb-1"></div>
          <div class="flex flex-wrap gap-6 py-2">
            ${statItem('Residential Tax', `$${Math.floor(residentialIncome*taxMultiplier).toLocaleString()}`, 'text-green-400')}
            ${statItem('Commercial', `$${Math.floor(commercialRevenue*taxMultiplier).toLocaleString()}`, 'text-blue-400')}
            ${statItem('Industrial', `$${Math.floor(industrialRevenue*taxMultiplier).toLocaleString()}`, 'text-yellow-400')}
            ${statItem('Tourism', `$${Math.floor(tourismIncome*taxMultiplier).toLocaleString()}`, 'text-emerald-400')}
          </div>
        </div>
        <div>
          <div class="h-px w-full bg-neutral-700 mb-1"></div>
          <div class="flex flex-wrap gap-6 py-2">
            ${statItem('Buildings', `-$${buildingMaintenance.toLocaleString()}`, 'text-red-400')}
            ${powerPlantMaintenance > 0 ? statItem('Power', `-$${powerPlantMaintenance.toLocaleString()}`, 'text-red-400') : ''}
            ${infrastructureCost > 0 ? statItem('Infrastructure', `-$${infrastructureCost.toLocaleString()}`, 'text-red-400') : ''}
            ${serviceCosts > 0 ? statItem('Services', `-$${serviceCosts.toLocaleString()}`, 'text-red-400') : ''}
            ${crimeExpenses > 0 ? statItem('Crime', `-$${crimeExpenses.toLocaleString()}`, 'text-red-400') : ''}
            ${roadMaintenanceBonus > 0 ? statItem('Roads', `-$${roadMaintenanceBonus.toLocaleString()}`, 'text-red-400') : ''}
          </div>
        </div>
        <div class="mt-2 pt-2 border-t border-neutral-700">
          <label class="text-xs text-neutral-400 block mb-2" id="taxRateLabel">Tax Rate: ${st.taxRate}%</label>
          <input type="range" id="taxRateSlider" min="0" max="20" value="${st.taxRate}" 
            class="w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-green-600"
            oninput="st.taxRate=parseInt(this.value); const lbl=document.getElementById('taxRateLabel'); if(lbl) lbl.textContent='Tax Rate: '+st.taxRate+'%'; updateStatsPanel(); sv();">
          <div class="text-xs text-neutral-500 mt-1">Lower taxes boost happiness, higher taxes boost income</div>
        </div>
      </div>`;
  } else if (infoType === 'happy') {
    title = 'Happiness';
    let avgCrime = 0;
    for (let y = 0; y < GR_SZ; y++) {
      for (let x = 0; x < GR_SZ; x++) {
        avgCrime += st.crime[y][x] || 30;
      }
    }
    avgCrime = Math.floor(avgCrime / (GR_SZ * GR_SZ));
    content = `<div class="flex flex-wrap gap-6 py-2">${statItem('level', `${st.happiness}/100`)}${statItem('parks', cnts.park||0)}${statItem('services', (cnts.police||0)+(cnts.fire||0)+(cnts.school||0)+(cnts.hospital||0))}${statItem('crime', `${avgCrime}%`)}${statItem('crimes', st.crimeEvents.length)}</div><div class="mt-3 text-xs text-neutral-400">Build parks, services, and police to increase</div>`;
  }
  
  return { title, content };
}

['rciBtn','popBtn','moneyBtn','happyBtn'].forEach((btnId, idx) => {
  const infoType = ['rci','pop','money','happy'][idx];
  document.getElementById(btnId).addEventListener('click', () => {
    const { title, content } = getStatsContent(infoType);
    shwInfo(title, content, infoType);
  });
});

function updateStatsPanel() {
  if (!currentInfoType) return;
  const pnl = document.getElementById('infoPanel');
  if (!pnl || pnl.classList.contains('hidden')) return;
  
  const { title, content } = getStatsContent(currentInfoType);
  
  if (title && content) {
    document.getElementById('infoTitle').innerHTML = title;
    document.getElementById('infoContent').innerHTML = content;
  }
}

function hasRdAcc(x,y) {
  const bounds = getBuildingBoundsFromCell(x,y);
  const startX = bounds.startX ?? x;
  const startY = bounds.startY ?? y;
  const w = bounds.w || 1;
  const h = bounds.h || 1;

  for (let dy=0; dy<h; dy++) {
    for (let dx=0; dx<w; dx++) {
      const cx = startX + dx, cy = startY + dy;
      for (let ndy=-1; ndy<=1; ndy++) {
        for (let ndx=-1; ndx<=1; ndx++) {
          if (ndx===0 && ndy===0) continue;
          const nx=cx+ndx, ny=cy+ndy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            if (st.grid[ny][nx].type==='road') return true;
          }
        }
      }
    }
  }
  return false;
}

function initPowerGrid() {
  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) {
    st.powerGrid = [];
    for (let y=0; y<GR_SZ; y++) {
      const row = [];
      for (let x=0; x<GR_SZ; x++) row.push(false);
      st.powerGrid.push(row);
    }
  } else {
    for (let y=0; y<GR_SZ; y++) {
      for (let x=0; x<GR_SZ; x++) st.powerGrid[y][x] = false;
    }
  }
}

function calculatePowerGrid() {
  initPowerGrid();
  
  // Find all power plants
  const powerPlants = [];
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (cell.type === 'coal' || cell.type === 'nuclear' || cell.type === 'wind') {
        powerPlants.push({x, y});
      }
    }
  }
  
  if (powerPlants.length === 0) {
    allocatePowerToBuildings();
    return;
  }
  
  // BFS from each power plant along roads
  const visited = new Set();
  const queue = [];
  
  // Start BFS from each power plant's adjacent road tiles
  for (const plant of powerPlants) {
    // Check adjacent tiles for roads
    for (let dy=-1; dy<=1; dy++) {
      for (let dx=-1; dx<=1; dx++) {
        if (dx===0 && dy===0) continue;
        const nx = plant.x + dx, ny = plant.y + dy;
        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
          if (st.grid[ny][nx].type === 'road') {
            const key = `${nx},${ny}`;
            if (!visited.has(key)) {
              visited.add(key);
              queue.push({x: nx, y: ny});
              st.powerGrid[ny][nx] = true;
            }
          }
        }
      }
    }
  }
  
  // BFS along road network
  while (queue.length > 0) {
    const current = queue.shift();
    
    // Check all 4 directions (up, down, left, right)
    const directions = [[0,-1], [0,1], [-1,0], [1,0]];
    for (const [dx, dy] of directions) {
      const nx = current.x + dx, ny = current.y + dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
        const key = `${nx},${ny}`;
        if (!visited.has(key) && st.grid[ny][nx].type === 'road') {
          visited.add(key);
          queue.push({x: nx, y: ny});
          st.powerGrid[ny][nx] = true;
        }
      }
    }
  }
  
  // Mark all tiles adjacent to powered roads as powered
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      if (st.powerGrid[y][x]) {
        // Check adjacent tiles (including diagonals)
        for (let dy=-1; dy<=1; dy++) {
          for (let dx=-1; dx<=1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
              if (!st.powerGrid[ny][nx]) {
                st.powerGrid[ny][nx] = true;
              }
            }
          }
        }
      }
    }
  }
  
  allocatePowerToBuildings();
}

function hasPowerAccess(x,y) {
  // Check if building at (x,y) has power access
  // Power flows via roads, so check if any adjacent tile is powered
  const bounds = getBuildingBoundsFromCell(x,y);
  const startX = bounds.startX ?? x;
  const startY = bounds.startY ?? y;
  const w = bounds.w || 1;
  const h = bounds.h || 1;

  if (!st.powerGrid || st.powerGrid.length !== GR_SZ) return false;
  
  for (let dy=0; dy<h; dy++) {
    for (let dx=0; dx<w; dx++) {
      const cx=startX+dx, cy=startY+dy;
      // Check adjacent tiles (including diagonals)
      for (let ndy=-1; ndy<=1; ndy++) {
        for (let ndx=-1; ndx<=1; ndx++) {
          if (ndx===0 && ndy===0) continue;
          const nx=cx+ndx, ny=cy+ndy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            if (st.powerGrid[ny][nx]) return true;
          }
        }
      }
    }
  }
  return false;
}

function buildingHasPower(x,y) {
  if (!hasPowerAccess(x,y)) return false;
  const key = getBuildingPowerKey(x,y);
  if (!key) return false;
  if (!st.powerShortageBuildings || typeof st.powerShortageBuildings !== 'object') return true;
  return !st.powerShortageBuildings[key];
}

// ===== Water System =====
function getWaterConsumption(buildingType, level) {
  if (buildingType === 'residential') {
    if (level === 1) return 3;
    if (level === 2) return 6;
    if (level === 3) return 10;
    return 0; // L0 residential doesn't need water
  } else if (buildingType === 'commercial') {
    if (level === 1) return 8;
    if (level === 2) return 15;
    if (level === 3) return 25;
    return 0;
  } else if (buildingType === 'industrial') {
    if (level === 1) return 12;
    if (level === 2) return 25;
    if (level === 3) return 40;
    return 0;
  }
  return 0;
}

function getBuildingWaterKey(x, y) {
  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;
  const cell = st.grid[y][x];
  if (!cell || !cell.type || cell.type === 'empty') return null;
  if (cell.buildingId != null) return `b:${cell.buildingId}`;
  const bounds = getBuildingBoundsFromCell(x,y);
  const w = bounds.w || 1;
  const h = bounds.h || 1;
  return `b:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;
}

function getWaterPlantKey(x, y) {
  if (x<0 || x>=GR_SZ || y<0 || y>=GR_SZ) return null;
  const cell = st.grid[y][x];
  if (!cell || !cell.type) return null;
  if (cell.buildingId != null) return `p:${cell.buildingId}`;
  const bounds = getBuildingBoundsFromCell(x,y);
  const w = bounds.w || 1;
  const h = bounds.h || 1;
  return `p:${cell.type}:${bounds.startX},${bounds.startY},${w}x${h}`;
}

function getWaterSystemSnapshot() {
  const processedWaterPlants = new Set();
  const processedBuildings = new Set();
  const consumers = [];
  let totalWaterGeneration = 0;
  let totalWaterConsumption = 0;
  let waterplantGen = 0, watertowerGen = 0;
  let waterplantCount = 0, watertowerCount = 0;
  let residentialConsumption = 0, commercialConsumption = 0, industrialConsumption = 0;
  
  for (let y = 0; y < GR_SZ; y++) {
    for (let x = 0; x < GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (!cell) continue;
      
      if (cell.type === 'waterplant' || cell.type === 'watertower') {
        const plantKey = getWaterPlantKey(x,y);
        if (plantKey && !processedWaterPlants.has(plantKey)) {
          processedWaterPlants.add(plantKey);
          const gen = WATER_GENERATION[cell.type] || 0;
          totalWaterGeneration += gen;
          if (cell.type === 'waterplant') { waterplantGen += gen; waterplantCount++; }
          else if (cell.type === 'watertower') { watertowerGen += gen; watertowerCount++; }
        }
      }
      
      if (cell.type === 'residential' || cell.type === 'commercial' || cell.type === 'industrial') {
        if (cell.abandoned) continue;
        const buildingKey = getBuildingWaterKey(x,y);
        if (!buildingKey || processedBuildings.has(buildingKey)) continue;
        processedBuildings.add(buildingKey);
        
        const level = cell.level || 0;
        const perTileConsumption = getWaterConsumption(cell.type, level);
        if (perTileConsumption <= 0) continue;
        const bounds = getBuildingBoundsFromCell(x,y);
        const area = Math.max(1,(bounds.w||1)*(bounds.h||1));
        const consumption = perTileConsumption * area;
        totalWaterConsumption += consumption;
        if (cell.type === 'residential') residentialConsumption += consumption;
        else if (cell.type === 'commercial') commercialConsumption += consumption;
        else industrialConsumption += consumption;
        
        const hasConnection = hasWaterAccess(x,y);
        consumers.push({
          key: buildingKey,
          type: cell.type,
          level,
          consumption,
          hasConnection,
          x: bounds.startX,
          y: bounds.startY
        });
      }
    }
  }
  
  return {
    totalWaterGeneration,
    totalWaterConsumption,
    waterplantGen,
    watertowerGen,
    waterplantCount,
    watertowerCount,
    residentialConsumption,
    commercialConsumption,
    industrialConsumption,
    consumers
  };
}

function allocateWaterToBuildings() {
  if (!st.waterShortageBuildings || typeof st.waterShortageBuildings !== 'object') {
    st.waterShortageBuildings = {};
  }
  const snapshot = getWaterSystemSnapshot();
  const shortageMap = {};
  const connectedBuildings = [];
  
  for (const consumer of snapshot.consumers) {
    if (!consumer.hasConnection) {
      shortageMap[consumer.key] = true;
    } else if (consumer.consumption > 0) {
      connectedBuildings.push(consumer);
    }
  }
  
  const typePriority = {residential:0, commercial:1, industrial:2};
  connectedBuildings.sort((a,b) => {
    const typeDiff = (typePriority[a.type] ?? 99) - (typePriority[b.type] ?? 99);
    if (typeDiff !== 0) return typeDiff;
    if (b.level !== a.level) return b.level - a.level;
    if (a.consumption !== b.consumption) return a.consumption - b.consumption;
    return a.key.localeCompare(b.key);
  });
  
  let remainingWater = snapshot.totalWaterGeneration;
  for (const building of connectedBuildings) {
    if (remainingWater >= building.consumption) {
      remainingWater -= building.consumption;
    } else {
      shortageMap[building.key] = true;
    }
  }
  
  st.waterShortageBuildings = shortageMap;
}

// Calculate water generation and consumption statistics
function calculateWaterStats(includeDetails = false) {
  const snapshot = getWaterSystemSnapshot();
  const result = {
    totalWaterGeneration: snapshot.totalWaterGeneration,
    totalWaterConsumption: snapshot.totalWaterConsumption,
    waterSurplus: snapshot.totalWaterGeneration - snapshot.totalWaterConsumption
  };
  
  if (includeDetails) {
    result.waterplantGen = snapshot.waterplantGen;
    result.watertowerGen = snapshot.watertowerGen;
    result.waterplantCount = snapshot.waterplantCount;
    result.watertowerCount = snapshot.watertowerCount;
    result.residentialConsumption = snapshot.residentialConsumption;
    result.commercialConsumption = snapshot.commercialConsumption;
    result.industrialConsumption = snapshot.industrialConsumption;
  }
  
  return result;
}

function initWaterGrid() {
  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) {
    st.waterGrid = [];
    for (let y=0; y<GR_SZ; y++) {
      st.waterGrid.push([]);
      for (let x=0; x<GR_SZ; x++) st.waterGrid[y][x] = false;
    }
  }
}

function calculateWaterGrid() {
  // Always reset the entire grid to false before recalculating
  st.waterGrid = [];
  for (let y=0; y<GR_SZ; y++) {
    st.waterGrid.push([]);
    for (let x=0; x<GR_SZ; x++) st.waterGrid[y][x] = false;
  }
  
  // Find all water plants and all pipes
  const waterPlants = [];
  const allPipes = [];
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const cell = st.grid[y][x];
      if (cell.type === 'waterplant' || cell.type === 'watertower') {
        waterPlants.push({x, y});
      }
      if (cell.pipe === true) {
        allPipes.push({x, y});
      }
    }
  }
  
  // If no water plants, no coverage at all
  if (waterPlants.length === 0) {
    allocateWaterToBuildings();
    return;
  }
  
  // BFS from each water plant along pipes to mark all connected pipes
  const pipeNetwork = new Set(); // Track only pipes that are connected to water plants
  const visited = new Set();
  const queue = [];
  
  // Start BFS from each water plant's adjacent pipe tiles (4 cardinal directions only)
  for (const plant of waterPlants) {
    // Check adjacent tiles for pipes (only 4 cardinal directions for connection)
    const directions = [[0,-1], [0,1], [-1,0], [1,0]];
    for (const [dx, dy] of directions) {
      const nx = plant.x + dx, ny = plant.y + dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
        if (st.grid[ny][nx].pipe === true) {
          const key = `${nx},${ny}`;
          if (!visited.has(key)) {
            visited.add(key);
            queue.push({x: nx, y: ny});
            pipeNetwork.add(key);
          }
        }
      }
    }
  }
  
  // BFS along pipe network - only mark the pipes themselves
  while (queue.length > 0) {
    const current = queue.shift();
    
    // Check all 4 cardinal directions (up, down, left, right)
    const directions = [[0,-1], [0,1], [-1,0], [1,0]];
    for (const [dx, dy] of directions) {
      const nx = current.x + dx, ny = current.y + dy;
      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
        const key = `${nx},${ny}`;
        if (!visited.has(key) && st.grid[ny][nx].pipe === true) {
          visited.add(key);
          queue.push({x: nx, y: ny});
          pipeNetwork.add(key);
        }
      }
    }
  }
  
  // IMPORTANT: Only mark coverage for pipes that are connected to water plants
  // Water plants themselves do NOT provide coverage - they need pipes!
  for (const pipeKey of pipeNetwork) {
    const [pipeX, pipeY] = pipeKey.split(',').map(Number);
    st.waterGrid[pipeY][pipeX] = true; // The pipe itself has water
    
    // Mark adjacent tiles (including diagonals) around connected pipes - 2x range
    for (let dy=-2; dy<=2; dy++) {
      for (let dx=-2; dx<=2; dx++) {
        const nx = pipeX + dx, ny = pipeY + dy;
        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
          st.waterGrid[ny][nx] = true;
        }
      }
    }
  }
  
  allocateWaterToBuildings();
}

function isNearWaterTile(x, y, maxDistance = 2) {
  // Check if location (x,y) is within maxDistance tiles of a water terrain tile
  for (let dy = -maxDistance; dy <= maxDistance; dy++) {
    for (let dx = -maxDistance; dx <= maxDistance; dx++) {
      const nx = x + dx, ny = y + dy;
      if (nx >= 0 && nx < GR_SZ && ny >= 0 && ny < GR_SZ) {
        const distance = Math.abs(dx) + Math.abs(dy); // Manhattan distance
        if (distance <= maxDistance && st.terrain[ny][nx] === 'water') {
          return true;
        }
      }
    }
  }
  return false;
}

function hasWaterAccess(x,y) {
  // Check if building at (x,y) has water access
  // Water flows via pipes, so check if building's own tiles or adjacent tiles have water
  const bounds = getBuildingBoundsFromCell(x,y);
  const startX = bounds.startX ?? x;
  const startY = bounds.startY ?? y;
  const w = bounds.w || 1;
  const h = bounds.h || 1;

  if (!st.waterGrid || st.waterGrid.length !== GR_SZ) return false;
  
  for (let dy=0; dy<h; dy++) {
    for (let dx=0; dx<w; dx++) {
      const cx=startX+dx, cy=startY+dy;
      
      // First check if the building's own tile has water coverage (pipe on building)
      if (st.waterGrid[cy][cx]) return true;
      
      // Then check adjacent tiles (including diagonals)
      for (let ndy=-1; ndy<=1; ndy++) {
        for (let ndx=-1; ndx<=1; ndx++) {
          if (ndx===0 && ndy===0) continue;
          const nx=cx+ndx, ny=cy+ndy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            if (st.waterGrid[ny][nx]) return true;
          }
        }
      }
    }
  }
  return false;
}

function buildingHasWater(x,y) {
  if (!hasWaterAccess(x,y)) return false;
  const key = getBuildingWaterKey(x,y);
  if (!key) return false;
  if (!st.waterShortageBuildings || typeof st.waterShortageBuildings !== 'object') return true;
  return !st.waterShortageBuildings[key];
}

function hasSchoolCoverage(x,y) {
  // Check if building at (x,y) is within a school's bounds (8-tile radius)
  const bounds = getBuildingBoundsFromCell(x,y);
  const startX = bounds.startX ?? x;
  const startY = bounds.startY ?? y;
  const w = bounds.w || 1;
  const h = bounds.h || 1;

  // Check each cell of the building
  for (let dy=0; dy<h; dy++) {
    for (let dx=0; dx<w; dx++) {
      const cx=startX+dx, cy=startY+dy;
      // Check for schools within 8-tile radius
      for (let sdy=-8; sdy<=8; sdy++) {
        for (let sdx=-8; sdx<=8; sdx++) {
          const nx=cx+sdx, ny=cy+sdy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            const d=Math.abs(sdx)+Math.abs(sdy);
            if (d<=8 && st.grid[ny][nx].type==='school') {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}

// ===== Game Logic =====
function calcLV(x,y) {
  let v=50; const tr=st.terrain[y][x];
  if (tr==='water') for (let dy=-2; dy<=2; dy++) for (let dx=-2; dx<=2; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) { const d=Math.abs(dx)+Math.abs(dy); if (d<=2) v+=(3-d)*5; }
  }
  let pk=0, pl=0, sv=0;
  for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
      const d=Math.abs(dx)+Math.abs(dy), c=st.grid[ny][nx];
      if (c.type.startsWith('park')) { const m=(c.w||1)*(c.h||1); const sizeBoost=m>1?1.5:1; pk+=(7-d)*2*m*sizeBoost; }
      else if (c.type==='industrial') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*2*m; }
      else if (c.type==='coal') { const m=(c.w||1)*(c.h||1); pl+=(7-d)*3*m; } // Coal plants pollute more than industrial
      else if (c.type==='police'||c.type==='fire'||c.type==='school'||c.type==='hospital') sv+=(7-d);
    }
  }
  v+=Math.min(pk,30); v-=Math.min(pl,40); v+=Math.min(sv,20);
  if (!hasRdAcc(x,y)) v-=30;
  return Math.max(0,Math.min(100,v));
}

function calcCrime(x,y) {
  let c=30; const tr=st.terrain[y][x];
  if (tr==='water'||tr==='cliff') return 0;
  
  // Reduce crime near police stations (8-tile radius)
  let policeCoverage=0;
  for (let dy=-8; dy<=8; dy++) for (let dx=-8; dx<=8; dx++) {
    const nx=x+dx, ny=y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
      const d=Math.abs(dx)+Math.abs(dy), cell=st.grid[ny][nx];
      if (cell.type==='police' && d<=8) {
        policeCoverage+=(9-d)*3;
      }
    }
  }
  c-=Math.min(policeCoverage,50);
  
  // Increase crime in high-population areas without police coverage
  const cell=st.grid[y][x];
  if ((cell.type==='residential'||cell.type==='commercial') && !cell.abandoned) {
    const popDensity=(cell.w||1)*(cell.h||1)*(cell.level||0);
    if (policeCoverage<10) c+=popDensity*5;
  }
  
  // Factor in happiness (low happiness = more crime)
  if (st.happiness<50) c+=20;
  else if (st.happiness<70) c+=10;
  
  // Increase crime if no road access
  if (!hasRdAcc(x,y)) c+=15;
  
  // Check for active crime events nearby
  for (const evt of st.crimeEvents) {
    const dx=Math.abs(x-evt.x), dy=Math.abs(y-evt.y), d=dx+dy;
    if (d<=3) c+=Math.max(0,(4-d)*10);
  }
  
  return Math.max(0,Math.min(100,c));
}

function updLV() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.landValue[y][x]=calcLV(x,y); }
function updCrime() { for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) st.crime[y][x]=calcCrime(x,y); }

function calcDmd(rC,cC,iC,p) {
  let rD=50, cD=50, iD=50; const tZ=rC+cC+iC;
  if (tZ===0) { rD=80; cD=40; iD=40; }
  else {
    const iR={r:0.5,c:0.25,i:0.25}, aR={r:rC/tZ,c:cC/tZ,i:iC/tZ};
    rD=Math.max(0,Math.min(100,50+(iR.r-aR.r)*200)); cD=Math.max(0,Math.min(100,50+(iR.c-aR.c)*200)); iD=Math.max(0,Math.min(100,50+(iR.i-aR.i)*200));
    if (p>0) { const jA=cC*5+iC*8, jN=p*0.6; if (jA<jN) { cD=Math.min(100,cD+20); iD=Math.min(100,iD+20); } }
    if (st.happiness<50) rD=Math.max(0,rD-20); else if (st.happiness>80) rD=Math.min(100,rD+10);
  }
  return {rDemand:rD,cDemand:cD,iDemand:iD};
}

function cleanupNewsEvents() {
  // Remove all event messages (fire, robbery, earthquake, etc.) - they have emojis
  st.newsEvents = st.newsEvents.filter(ev => !ev.includes('üî•') && !ev.includes('üö®') && !ev.includes('üåé'));
  
  // Keep only the 3 most recent AI news items
  const aiNews = st.newsEvents.filter(ev => !ev.includes('Welcome to'));
  const welcomeMsgs = st.newsEvents.filter(ev => ev.includes('Welcome to'));
  st.newsEvents = [...welcomeMsgs, ...aiNews.slice(-3)];
}

async function genNws() {
  if (aiReq) return; aiReq=true;
  cleanupNewsEvents(); // Clean old events and AI news before generating new one
  const cnts={}; st.grid.flat().forEach(c => cnts[c.type]=(cnts[c.type]||0)+1);
  const ctx=`${st.cityName}, ${st.year}, pop ${st.population}, $${(st.money/1000).toFixed(0)}k, happiness ${st.happiness}, ${cnts.residential||0}R ${cnts.commercial||0}C ${cnts.industrial||0}I`;
  const prm=`Generate ONE quirky news headline (8 words max) for SimCity game. Context: ${ctx}. Topics: era-specific events (${st.year}s culture/tech), citizen stories, weird happenings, local color, achievements, community events. NO fires, earthquakes, crimes, or disasters. Include brief stat at end like (+200 pop) or (-$2k) or (+5 joy). Be creative and fun. Return ONLY headline.`;
  try {
    const r=await fetch('/api/applet-ai', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({prompt:prm})});
    if (!r.ok) throw new Error('AI request failed');
    const d=await r.json(); let ev=d.reply||'City continues to grow';
    ev=ev.replace(/^["']|["']$/g,'').trim();
    const m=ev.match(/\(([^)]+)\)/);
    if (m) {
      const ch=m[1];
      if (ch.includes('pop')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0); st.population=Math.max(0,st.population+vl); }
      else if (ch.includes('$')||ch.includes('k')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0), mt=ch.includes('k')?1000:1; st.money+=vl*mt; }
      else if (ch.includes('joy')||ch.includes('happiness')) { const vl=parseInt(ch.match(/-?\d+/)?.[0]||0); st.happiness=Math.max(0,Math.min(100,st.happiness+vl)); }
    }
    st.newsEvents.push(ev);
    nwsQ.push(ev); if (!trans && st.speed>0) shwNxtNws();
  } catch(e) { console.error('News generation error:',e); } finally { aiReq=false; }
}

function tryMrgPark(x,y) {
  const c=st.grid[y][x]; if (!c||!c.type.startsWith('park')) return false;
  if (!isTopLeftCell(x,y)) return false;
  
  // Try to merge 2x1 tiles into 2x2
  if (c.w===2&&c.h===1) {
    // Check if there's a 2x1 tile directly above or below
    const checkAbove=y>0 && x+1<GR_SZ;
    const checkBelow=y+1<GR_SZ && x+1<GR_SZ;
    
    if (checkAbove) {
      const above=st.grid[y-1][x];
      if (above.type===c.type&&above.w===2&&above.h===1 && y-1>=0 && x+1<GR_SZ && st.grid[y-1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y-1>=0 && y<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y-1+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
    
    if (checkBelow) {
      const below=st.grid[y+1][x];
      if (below.type===c.type&&below.w===2&&below.h===1 && y+1<GR_SZ && x+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
  }
  
  // Try to merge 1x2 tiles into 2x2
  if (c.w===1&&c.h===2) {
    // Check if there's a 1x2 tile directly left or right
    const checkLeft=x>0 && y+1<GR_SZ;
    const checkRight=x+1<GR_SZ && y+1<GR_SZ;
    
    if (checkLeft) {
      const left=st.grid[y][x-1];
      if (left.type===c.type&&left.w===1&&left.h===2 && x-1>=0 && y+1<GR_SZ && st.grid[y+1][x-1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x-1>=0 && x<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x-1+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
    
    if (checkRight) {
      const right=st.grid[y][x+1];
      if (right.type===c.type&&right.w===1&&right.h===2 && x+1<GR_SZ && y+1<GR_SZ && st.grid[y+1][x+1].type===c.type) {
        // Merge into 2x2 - ensure all cells are within bounds
        if (y>=0 && y+1<GR_SZ && x>=0 && x+1<GR_SZ) {
          const buildingId = nextBuildingId++;
          for (let dy=0; dy<2; dy++) {
            for (let dx=0; dx<2; dx++) {
              const nx=x+dx, ny=y+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:2,h:2,buildingId:buildingId};
              }
            }
          }
          return true;
        }
      }
    }
  }
  
  // Original logic: merge 1x1 tiles
  if (c.w!==1||c.h!==1) return false;
  
  // Try to merge with adjacent parks of the same type
  const dirs=[{dx:0,dy:0,w:2,h:2},{dx:-1,dy:0,w:2,h:1},{dx:0,dy:-1,w:1,h:2},{dx:-1,dy:-1,w:2,h:2},{dx:0,dy:0,w:2,h:1},{dx:0,dy:0,w:1,h:2}];
  for (const d of dirs) {
    const sx=x+d.dx, sy=y+d.dy;
    if (sx<0||sy<0||sx+d.w>GR_SZ||sy+d.h>GR_SZ) continue;
    
    // Check if all cells in the area are the same park type and 1x1
    let canMerge=true;
    for (let dy=0; dy<d.h; dy++) for (let dx=0; dx<d.w; dx++) {
      const nx=sx+dx, ny=sy+dy, nb=st.grid[ny][nx];
      if (nb.type!==c.type||nb.w!==1||nb.h!==1) { canMerge=false; break; }
    }
    
    if (canMerge) {
      // Merge the parks - ensure all cells are within bounds
      const buildingId = nextBuildingId++;
      for (let dy=0; dy<d.h; dy++) {
        for (let dx=0; dx<d.w; dx++) {
          const nx=sx+dx, ny=sy+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            st.grid[ny][nx]={type:c.type,age:Math.max(st.grid[ny][nx].age,c.age),level:1,w:d.w,h:d.h,buildingId:buildingId};
          }
        }
      }
      return true;
    }
  }
  return false;
}

// First step: merge 1x1 buildings to 2x1 or 1x2
function tryMrgTo2x1(x,y) {
  const c=st.grid[y][x]; if (!c) return false;
  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;
  
  // Only merge mature 1x1 buildings
  const w=c.w||1, h=c.h||1;
  if (w!==1 || h!==1) return false;
  if (c.level<=0 || c.abandoned) return false;
  
  const targets=[
    {dx:1, dy:0, w:2, h:1}, // Merge to the right (2x1)
    {dx:0, dy:1, w:1, h:2}  // Merge downward (1x2)
  ];
  
  for (const target of targets) {
    const adjX=x+target.dx, adjY=y+target.dy;
    if (adjX<0||adjX>=GR_SZ||adjY<0||adjY>=GR_SZ) continue;
    const adj=st.grid[adjY][adjX];
    if (!adj) continue;
    if (adj.type!==c.type) continue;
    if ((adj.w||1)!==1 || (adj.h||1)!==1) continue;
    
    const adjLevel=adj.level||0;
    if (adjLevel<=0 && !adj.abandoned) continue; // keep level-0 zones 1x1
    
    const topLeftX=Math.min(x,adjX);
    const topLeftY=Math.min(y,adjY);
    const bestAge=Math.max(c.age||0,adj.age||0);
    const bestLevel=Math.max(1,Math.min(c.level||1,adj.level||c.level||1));
    const isAbandoned=c.abandoned && adj.abandoned;
    
    const buildingId = nextBuildingId++;
    for (let dy=0; dy<target.h; dy++) {
      for (let dx=0; dx<target.w; dx++) {
        const nx=topLeftX+dx, ny=topLeftY+dy;
        if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
          st.grid[ny][nx]={type:c.type,age:bestAge,level:bestLevel,w:target.w,h:target.h,abandoned:isAbandoned,buildingId:buildingId};
        }
      }
    }
    return true;
  }
  
  return false;
}

function tryMrg(x,y) {
  const c=st.grid[y][x]; if (!c) return false;
  const isZ=c.type==='residential'||c.type==='commercial'||c.type==='industrial'; if (!isZ) return false;
  
  // Only merge buildings that are 1x2 or 2x1 (not 1x1 - those merge first)
  const w=c.w||1, h=c.h||1;
  if (!((w===1&&h===2) || (w===2&&h===1))) return false;
  if (!isTopLeftCell(x,y)) return false;
  if (c.level<=0 || c.abandoned) return false;
  
  const baseLevel=Math.max(1,c.level||1);
  const baseAge=c.age||0;
  const expansions=[];
  
  if (w===2 && h===1) {
    if (y>0) expansions.push({topLeftX:x, topLeftY:y-1, fillCells:[{x:x,y:y-1},{x:x+1,y:y-1}]});
    if (y+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x,y:y+1},{x:x+1,y:y+1}]});
  } else if (w===1 && h===2) {
    if (x>0) expansions.push({topLeftX:x-1, topLeftY:y, fillCells:[{x:x-1,y:y},{x:x-1,y:y+1}]});
    if (x+1<GR_SZ) expansions.push({topLeftX:x, topLeftY:y, fillCells:[{x:x+1,y:y},{x:x+1,y:y+1}]});
  }
  
  for (const option of expansions) {
    const {topLeftX, topLeftY, fillCells}=option;
    if (topLeftX<0 || topLeftY<0 || topLeftX+1>=GR_SZ || topLeftY+1>=GR_SZ) continue;
    
    let canExpand=true;
    let mergedAge=baseAge;
    for (const pos of fillCells) {
      if (pos.x<0 || pos.x>=GR_SZ || pos.y<0 || pos.y>=GR_SZ) { canExpand=false; break; }
      const target=st.grid[pos.y][pos.x];
      if (!target) { canExpand=false; break; }
      if (target.type!==c.type) { canExpand=false; break; }
      if ((target.w||1)!==1 || (target.h||1)!==1) { canExpand=false; break; }
      const targetLevel=target.level||0;
      if (targetLevel>0 && !target.abandoned) { canExpand=false; break; }
      mergedAge=Math.max(mergedAge,target.age||0);
    }
    
    if (!canExpand) continue;
    
    const buildingId = nextBuildingId++;
    for (let dy=0; dy<2; dy++) {
      for (let dx=0; dx<2; dx++) {
        const nx=topLeftX+dx, ny=topLeftY+dy;
        st.grid[ny][nx]={type:c.type,age:mergedAge,level:baseLevel,w:2,h:2,abandoned:false,buildingId:buildingId};
      }
    }
    return true;
  }
  
  return false;
}

function updFires() {
  st.fires=st.fires.filter(f => {
    f.age++;
    
    // Count fire trucks at scene (from vehicles that have arrived and are within coverage range)
    const trucksAtScene = st.cars.filter(c => 
      c.mission && 
      c.mission.type === 'fire' && 
      c.mission.arrived && 
      isWithinCoverageRange(c.mission.targetX, c.mission.targetY, f.x, f.y)
    ).length;
    
    // Fires REQUIRE fire trucks to be extinguished - they won't go out on their own
    // With trucks: extinguish faster (10 ticks per truck, min 5 ticks)
    // Without trucks: fire continues indefinitely (but building will eventually be destroyed)
    if (trucksAtScene === 0) {
      // No fire trucks - fire continues burning
      // After 60 ticks without trucks, building is destroyed anyway
      if (f.age > 60) {
        sendEmergencyVehiclesHome('fire', f.x, f.y);
        
        const cell=st.grid[f.y][f.x];
        if (cell && cell.type!=='empty') {
          const bounds=getBuildingBoundsFromCell(f.x,f.y);
          const w=bounds.w||1, h=bounds.h||1;
          for (let dy=0; dy<h; dy++) {
            for (let dx=0; dx<w; dx++) {
              const nx=bounds.startX+dx, ny=bounds.startY+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
                normalizeEmptyCell(nx,ny);
              }
            }
          }
        }
        return false; // Remove fire after building destroyed
      }
      return true; // Keep fire burning
    }
    
    // Fire trucks are at scene - extinguish fire
    // More trucks = faster extinguishing (15 ticks with 1 truck, down to 5 ticks with 3+ trucks)
    const maxAge = trucksAtScene >= 1 ? Math.max(5, 15 - (trucksAtScene - 1) * 5) : 60;
    
    if (f.age>maxAge) { 
      sendEmergencyVehiclesHome('fire', f.x, f.y);
      
      // If fire trucks arrived (trucksAtScene > 0), save the building
      if (trucksAtScene > 0) {
        // Fire extinguished successfully - building saved!
        return false; // Remove fire
      } else {
        // No fire trucks - building destroyed
        const cell=st.grid[f.y][f.x];
        if (cell && cell.type!=='empty') {
          const bounds=getBuildingBoundsFromCell(f.x,f.y);
          const w=bounds.w||1, h=bounds.h||1;
          for (let dy=0; dy<h; dy++) {
            for (let dx=0; dx<w; dx++) {
              const nx=bounds.startX+dx, ny=bounds.startY+dy;
              if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
                normalizeEmptyCell(nx,ny);
              }
            }
          }
        }
        return false; 
      }
    }
    const c=st.grid[f.y][f.x]; if (c.type==='empty') return false;
    let hasFr=false; for (let dy=-3; dy<=3; dy++) for (let dx=-3; dx<=3; dx++) {
      const nx=f.x+dx, ny=f.y+dy; if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) if (st.grid[ny][nx].type==='fire') hasFr=true;
    }
    // With fire trucks, fires can be extinguished earlier
    const minAgeForSpread = trucksAtScene > 0 ? 5 : 10;
    if (hasFr && f.age>minAgeForSpread) return false; return true;
  });
}

function startFire() {
  const blds=[]; for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x]; if ((c.type==='residential'||c.type==='commercial'||c.type==='industrial') && !c.abandoned) blds.push({x,y});
  }
  if (blds.length>0) {
    const b=blds[Math.floor(Math.random()*blds.length)]; 
    st.fires.push({x:b.x,y:b.y,age:0,fireTrucksAtScene:0});
    plySnd('fire');
    
    // Dispatch fire truck from nearest fire station
    const dispatched = dispatchEmergencyVehicle('fire', b.x, b.y, 'fire');
    const cost = 5000;
    st.newsEvents.push(`üî• Fire! (-$${fmtCompact(cost)})`);
    st.money-=cost;
    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
  }
}

function startQuake() {
  plySnd('earthquake');
  const gr=document.getElementById('grid'); gr.classList.add('earthquake');
  setTimeout(() => gr.classList.remove('earthquake'),1500);
  const blds=[]; 
  const processedBuildings=new Set(); // Track buildings we've already added
  
  // Collect buildings, but only add the top-left cell of each building
  for (let y=0; y<GR_SZ; y++) {
    for (let x=0; x<GR_SZ; x++) {
      const c=st.grid[y][x]; 
      if (c.type==='empty' || c.type==='road') continue;
      
      // Skip level 0 RCI zones (empty zones), but allow abandoned buildings
      const isZone=c.type==='residential'||c.type==='commercial'||c.type==='industrial';
      if (isZone && (c.level||0)===0 && !c.abandoned) continue;
      
      const w=c.w||1, h=c.h||1;
      // Only add the top-left cell of each building to avoid duplicates
      // Check if this is the top-left cell
      let isTopLeft=true;
      if (w>1 || h>1) {
        // Check if there's a cell to the left or above with the same building
        if (x>0) {
          const leftCell=st.grid[y][x-1];
          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {
            isTopLeft=false;
          }
        }
        if (y>0) {
          const aboveCell=st.grid[y-1][x];
          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {
            isTopLeft=false;
          }
        }
      }
      
      if (isTopLeft) {
        // Ensure this building's footprint does not include any roads (which can happen
        // with older saves or after complex merges next to roads)
        let hasRoadInFootprint=false;
        for (let dy=0; dy<h && !hasRoadInFootprint; dy++) {
          for (let dx=0; dx<w; dx++) {
            const nx=x+dx, ny=y+dy;
            if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
              if (st.grid[ny][nx].type==='road') {
                hasRoadInFootprint=true;
                break;
              }
            }
          }
        }
        if (hasRoadInFootprint) continue;

        const buildingKey=`${x},${y},${c.type},${w},${h}`;
        if (!processedBuildings.has(buildingKey)) {
          processedBuildings.add(buildingKey);
          blds.push({x,y,w,h});
        }
      }
    }
  }
  
  const dmg=Math.min(5,Math.floor(blds.length*0.1));
  for (let i=0; i<dmg; i++) {
    if (blds.length>0) {
      const b=blds.splice(Math.floor(Math.random()*blds.length),1)[0];
      // Destroy all cells that are part of this building using robust bounds
      const bounds=getBuildingBoundsFromCell(b.x,b.y);
      const w=bounds.w||1, h=bounds.h||1;
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=bounds.startX+dx, ny=bounds.startY+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            // Only destroy if it's not a road
            if (st.grid[ny][nx].type!=='road') {
              st.grid[ny][nx]={type:'empty',age:0,level:0,w:1,h:1,buildingId:null};
              normalizeEmptyCell(nx,ny); // Ensure it's 1x1
            }
          }
        }
      }
    }
  }
  const cost = 10000;
  st.newsEvents.push(`üåé Earthquake! ${dmg} buildings damaged (-$${fmtCompact(cost)})`);
  st.money-=cost;
  nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
}

function updCrimeEvents() {
  st.crimeEvents=st.crimeEvents.filter(evt => {
    evt.age++;
    
    // Count police cars at scene (from vehicles that have arrived and are within coverage range)
    const policeAtScene = st.cars.filter(c => 
      c.mission && 
      c.mission.type === 'crime' && 
      c.mission.arrived && 
      isWithinCoverageRange(c.mission.targetX, c.mission.targetY, evt.x, evt.y)
    ).length;
    
    // Crimes REQUIRE police cars to resolve - they won't resolve on their own
    // Without police cars: crime continues indefinitely (causing ongoing costs)
    if (policeAtScene === 0) {
      // No police cars - crime continues
      // After 100 ticks without police, crime eventually stops (but damage is done)
      if (evt.age > 100) {
        // Crime resolved after long time without police (but should have been handled)
        return false;
      }
      // Continue costing money while crime is active
      if (evt.age % 10 === 0) {
        st.money -= 500; // Ongoing cost every 10 ticks
      }
      return true; // Keep crime active
    }
    
    // Police cars are at scene - resolve crime quickly
    // Resolve faster with more cars: 5 ticks per car (min 2 ticks)
    const maxAge = Math.max(2, 20 - policeAtScene * 5);
    
    if (evt.age>maxAge) {
      sendEmergencyVehiclesHome('crime', evt.x, evt.y);
      return false;
    }
    return true;
  });
}

function startCrimeEvent() {
  const blds=[];
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    // Higher crime areas are more likely to have crime events
    const crimeLevel=st.crime[y][x]||30;
    if ((c.type==='residential'||c.type==='commercial') && !c.abandoned && crimeLevel>40) {
      // Weight by crime level - higher crime = more likely
      for (let i=0; i<Math.floor(crimeLevel/20); i++) blds.push({x,y,crimeLevel});
    }
  }
  if (blds.length>0) {
    const b=blds[Math.floor(Math.random()*blds.length)];
    const crimeTypes=['robbery','break-in','vandalism'];
    const crimeType=crimeTypes[Math.floor(Math.random()*crimeTypes.length)];
    st.crimeEvents.push({x:b.x,y:b.y,type:crimeType,age:0,policeCarsAtScene:0});
    plySnd('crime');
    
    // Dispatch police car from nearest police station
    const dispatched = dispatchEmergencyVehicle('police', b.x, b.y, 'crime');
    const cost=Math.floor(Math.random()*3000)+2000;
    st.money-=cost;
    const msg=crimeType==='robbery'?`üö® Robbery! (-$${fmtCompact(cost)})`:
           crimeType==='break-in'?`üö® Break-in! (-$${fmtCompact(cost)})`:
           `üö® Vandalism! (-$${fmtCompact(cost)})`;
    st.newsEvents.push(msg);
    nwsQ.push(st.newsEvents[st.newsEvents.length-1]); if (!trans && st.speed>0) shwNxtNws();
  }
}

function simTk() {
  st.tickCount++; st.ticksSinceNews++;
  if (st.tickCount%12===0) {
    st.year++;
    // Clean up old event messages and AI news every year
    cleanupNewsEvents();
  }
  // Recalculate power grid each tick
  calculatePowerGrid();
  calculateWaterGrid();
  let rC=0, cC=0, iC=0, pC=0, poC=0, fC=0, sC=0, hC=0, rdC=0; const cntd={};
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const k=`${x},${y}`; if (cntd[k]) continue;
    const c=st.grid[y][x]; 
    // Normalize empty cells to ensure they're always 1x1
    if (c.type==='empty') normalizeEmptyCell(x,y);
    if (c.type!=='empty') {
      const w=c.w||1, h=c.h||1;
      // Only increment age once per building (only for the top-left cell being processed)
      c.age++;
      // For multi-tile buildings, sync age to all cells
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx<GR_SZ && ny<GR_SZ) {
            st.grid[ny][nx].age = c.age; // Sync age across all cells
          }
          cntd[`${nx},${ny}`]=true;
        }
      }
    }
    if (c.type==='residential') rC++; else if (c.type==='commercial') cC++; else if (c.type==='industrial') iC++;
    else if (c.type.startsWith('park')) pC++;     else if (c.type==='police') poC++; else if (c.type==='fire') fC++;
    else if (c.type==='school') sC++; else if (c.type==='hospital') hC++; else if (c.type==='road') rdC++;
    else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {
      // Count power plants (for stats)
    }
  }
  updLV();
  updCrime();
  // Track processed buildings to avoid duplicate updates for merged buildings
  const processedBuildings = new Set();
  const processedCells = new Set(); // Track individual cells that have been processed
  
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential'||c.type==='commercial'||c.type==='industrial') {
      // Skip if this cell has already been processed (e.g., as part of a merged building)
      const cellKey = `${x},${y}`;
      if (processedCells.has(cellKey)) continue;
      
      const w=c.w||1, h=c.h||1;
      // Only process the top-left cell of each building
      let isTopLeft=true;
      if (w>1 || h>1) {
        // Check if there's a cell to the left or above with the same building
        if (x>0) {
          const leftCell=st.grid[y][x-1];
          if (leftCell.type===c.type && (leftCell.w||1)===w && (leftCell.h||1)===h) {
            isTopLeft=false;
          }
        }
        if (y>0) {
          const aboveCell=st.grid[y-1][x];
          if (aboveCell.type===c.type && (aboveCell.w||1)===w && (aboveCell.h||1)===h) {
            isTopLeft=false;
          }
        }
      }
      
      if (!isTopLeft) continue;
      
      // Skip if this building has already been processed
      const buildingKey = `${x},${y},${c.type},${w},${h}`;
      if (processedBuildings.has(buildingKey)) continue;
      processedBuildings.add(buildingKey);
      
      // Mark all cells of this building as processed
      for (let dy=0; dy<h; dy++) {
        for (let dx=0; dx<w; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
            processedCells.add(`${nx},${ny}`);
          }
        }
      }
        
        const lv=st.landValue[y][x], hr=hasRdAcc(x,y), mv=c.type==='industrial'?10:20;
        const level = c.level || 0;
        
        // Check power requirements
        let needsPower = false;
        if (c.type === 'residential' && (level === 2 || level === 3)) needsPower = true;
        else if (c.type === 'commercial' || c.type === 'industrial') needsPower = true;
        
        const hasPower = buildingHasPower(x, y);
        
        // Track ticks without road access
      if (!hr) {
        c.ticksNoRoad = (c.ticksNoRoad || 0) + 1;
      } else {
        c.ticksNoRoad = 0;
      }
      
      // Track ticks without power (if building needs it)
      if (needsPower && !hasPower) {
        c.ticksNoPower = (c.ticksNoPower || 0) + 1;
      } else {
        c.ticksNoPower = 0;
      }
      
      // Immediate abandonment if land value too low OR no power for extended period (15 ticks)
      if (lv<mv || (needsPower && !hasPower && c.ticksNoPower > 15)) { 
        c.abandoned=true;
        // Keep level but mark as abandoned - don't set to 0
        // Update all cells of merged building
        const w=c.w||1, h=c.h||1;
        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
          if (x+dx<GR_SZ && y+dy<GR_SZ) {
            st.grid[y+dy][x+dx].abandoned=true;
          }
        }
      }
      // Gradual decline without road access
      else if (!hr) {
        // Downgrade every 3 ticks without road
        if (c.ticksNoRoad > 3 && c.level > 1) {
          c.level--;
          c.ticksNoRoad = 0; // Reset counter after downgrade
          // Update all cells of merged building
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;
          }
        }
        // Become abandoned after being at level 1 for 5 ticks without road
        else if (c.ticksNoRoad > 5 && c.level >= 1) {
          c.abandoned = true;
          // Keep the level, just mark as abandoned
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) {
              st.grid[y+dy][x+dx].abandoned=true;
            }
          }
        }
        // Immediately abandon if no road for 10+ ticks
        else if (c.ticksNoRoad > 10) {
          c.abandoned = true;
          // Keep the level, just mark as abandoned
          const w=c.w||1, h=c.h||1;
          for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
            if (x+dx<GR_SZ && y+dy<GR_SZ) {
              st.grid[y+dy][x+dx].abandoned=true;
            }
          }
        }
      }
      else {
        c.abandoned=false;
        // Update all cells of merged building to un-abandon
        for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
          if (x+dx<GR_SZ && y+dy<GR_SZ) {
            st.grid[y+dy][x+dx].abandoned=false;
          }
        }
        
        // Check for downgrades first (more important)
        let downgraded = false;
        
        // Downgrade if no power and building needs it (after 5 ticks)
        if (needsPower && !hasPower && c.ticksNoPower > 5 && c.level > 0) {
          // For residential: downgrade L3->L2, L2->L1 (but L1 doesn't need power so stop there)
          // For commercial/industrial: downgrade by 1 level
          if (c.type === 'residential' && c.level >= 2) {
            const newLevel = c.level - 1;
            c.level = newLevel;
            downgraded = true;
            c.ticksNoPower = 0;
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;
            }
          } else if ((c.type === 'commercial' || c.type === 'industrial') && c.level > 1) {
            const newLevel = c.level - 1;
            c.level = newLevel;
            downgraded = true;
            c.ticksNoPower = 0;
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;
            }
          }
        }
        
        if (!downgraded) {
          if (lv<30 && c.level>1) { 
            const newLevel = Math.max(1,c.level-1);
            c.level = newLevel;
            downgraded = true;
            // Update all cells of merged building
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=newLevel;
            }
          }
          // Level 3 downgrades: need land value >= 40 AND school coverage (same criteria as upgrade)
          else if (c.level===3 && (lv<40 || !hasSchoolCoverage(x,y))) { 
            c.level=2; 
            downgraded = true;
            // Update all cells of merged building
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=2;
            }
          }
        }
        
          // Upgrade logic - only if not downgraded, gradual one level at a time
          // Slowed down upgrades: require more age and better conditions
          // Also require power if building needs it
          if (!downgraded) {
            let upgraded = false;
            // Level 0 -> 1: needs age > 10 ticks (was 5)
            if (c.level===0 && c.age>10) {
              // Check if level 1 would need power
              const wouldNeedPower = (c.type === 'commercial' || c.type === 'industrial');
              if (!wouldNeedPower || hasPower) {
                c.level=1;
                upgraded = true;
              }
            }
            // Level 1 -> 2: needs age > 30 AND land value > 55 (was 15 and 50)
            // For residential: also needs power (L2 requires power)
            // For commercial/industrial: also needs power
            else if (c.level===1 && c.age>30 && lv>55) {
              if (hasPower) {
                c.level=2;
                upgraded = true;
              }
            }
            // Level 2 -> 3: needs age > 50 AND land value >= 40 AND school coverage
            // Also needs power (L3 requires power for residential, commercial, industrial)
            else if (c.level===2 && c.age>50 && lv>=40 && hasSchoolCoverage(x,y)) {
              if (hasPower) {
                c.level=3;
                upgraded = true;
              }
            }
          
          // Update all cells of merged building if upgraded
          if (upgraded) {
            for (let dy=0; dy<h; dy++) for (let dx=0; dx<w; dx++) {
              if (x+dx<GR_SZ && y+dy<GR_SZ) st.grid[y+dy][x+dx].level=c.level;
            }
          }
        }
        
        // Two-step merging process:
        // Step 1: Try to merge 1x1 buildings to 2x1 or 1x2 first
        if (c.age>8 && w===1 && h===1 && c.level>0) {
          const merged=tryMrgTo2x1(x,y);
          if (merged) {
            // Mark all cells of the newly merged building as processed
            // The merged building is now 2x1 or 1x2, so we need to update processedCells
            // But we don't know which direction it merged, so we'll let the next iteration handle it
            // For now, just mark the current cell as processed
            processedCells.add(`${x},${y}`);
            if (x+1<GR_SZ) processedCells.add(`${x+1},${y}`); // If merged right (2x1)
            if (y+1<GR_SZ) processedCells.add(`${x},${y+1}`); // If merged down (1x2)
          }
        }
        // Step 2: Try to merge 2x1 or 1x2 buildings to 2x2 (only if at least one is 2x1/1x2)
        if (c.age>12 && ((w===1&&h===2) || (w===2&&h===1)) && c.level>0) {
          // Only try merge if this is the top-left cell of the building
          // For 1x2: always top-left (spans down)
          // For 2x1: always top-left (spans right)
          const merged=tryMrg(x,y);
          if (merged) {
            // Mark all cells of the newly merged 2x2 building as processed
            // After merge, the grid has been updated with a 2x2 building
            // Check the current cell and nearby cells to find the 2x2 building's top-left
            let found2x2=false;
            for (let checkY=Math.max(0,y-1); checkY<=Math.min(GR_SZ-2,y+1) && !found2x2; checkY++) {
              for (let checkX=Math.max(0,x-1); checkX<=Math.min(GR_SZ-2,x+1) && !found2x2; checkX++) {
                const checkCell=st.grid[checkY][checkX];
                if (checkCell.type===c.type && (checkCell.w||1)===2 && (checkCell.h||1)===2) {
                  // This is the top-left of the merged 2x2 building
                  // Mark all 4 cells as processed
                  for (let dy=0; dy<2; dy++) {
                    for (let dx=0; dx<2; dx++) {
                      const nx=checkX+dx, ny=checkY+dy;
                      if (nx>=0 && nx<GR_SZ && ny>=0 && ny<GR_SZ) {
                        processedCells.add(`${nx},${ny}`);
                      }
                    }
                  }
                  found2x2=true;
                }
              }
            }
          }
        }
      }
    } else if (c.type.startsWith('park')) {
      // Try to merge parks of the same type
      tryMrgPark(x,y);
    }
  }
  const bPR=10; let nP=0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
      const sM=(c.w||1)*(c.h||1), lM=c.level===3?1.5:(c.level===2?1.2:1);
      nP+=Math.floor(bPR*sM*lM);
    }
  }
  st.population=nP;
  const jA=cC*5+iC*8, jN=nP*0.6;
  if (jA<=0 || jN<=0) st.employment=0;
  else st.employment=Math.min(100,Math.floor((Math.min(jA,jN)/jN)*100));
  
  // IMPROVED ECONOMY CALCULATIONS
  // 1. Residential tax income (scaled by level and land value)
  let residentialIncome = 0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='residential' && hasRdAcc(x,y) && !c.abandoned) {
      const lv=st.landValue[y][x]||50;
      const level=c.level||0;
      const size=(c.w||1)*(c.h||1);
      const baseTax=2.5; // Base tax per person (increased to balance expenses)
      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));
      const landValueMultiplier=1+(lv-50)/100; // +1% per point above 50
      const popPerCell=Math.floor(10*size*levelMultiplier);
      residentialIncome+=Math.floor(popPerCell*baseTax*levelMultiplier*landValueMultiplier);
    }
  }
  
  // 2. Commercial revenue (based on population served, level, land value, employment)
  let commercialRevenue = 0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='commercial' && hasRdAcc(x,y) && !c.abandoned) {
      const lv=st.landValue[y][x]||50;
      const level=c.level||0;
      const size=(c.w||1)*(c.h||1);
      const baseRevenue=18; // Base revenue per cell (increased to balance expenses)
      const levelMultiplier=level===3?3.0:(level===2?2.0:(level===1?1.5:0.8));
      const landValueMultiplier=1+(lv-50)/80;
      const employmentMultiplier=0.5+(st.employment/200); // 0.5x to 1.0x based on employment
      const populationMultiplier=Math.min(2.0,1+(st.population/5000)); // More population = more customers
      commercialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier*populationMultiplier);
    }
  }
  
  // 3. Industrial revenue (based on employment, level, land value)
  let industrialRevenue = 0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='industrial' && hasRdAcc(x,y) && !c.abandoned) {
      const lv=st.landValue[y][x]||50;
      const level=c.level||0;
      const size=(c.w||1)*(c.h||1);
      const baseRevenue=24; // Base revenue per cell (increased to balance expenses)
      const levelMultiplier=level===3?2.8:(level===2?2.0:(level===1?1.4:0.7));
      const landValueMultiplier=1+(lv-50)/100;
      const employmentMultiplier=0.4+(st.employment/167); // 0.4x to 1.0x based on employment
      industrialRevenue+=Math.floor(baseRevenue*size*levelMultiplier*landValueMultiplier*employmentMultiplier);
    }
  }
  
  // 4. Tourism income from parks (scaled by park size and city population)
  let tourismIncome = 0;
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type && c.type.startsWith('park')) {
      const size=(c.w||1)*(c.h||1);
        const baseTourism=6; // Base tourism per cell (increased to balance expenses)
        const populationMultiplier=Math.min(3.0,1+(st.population/3000)); // More people = more visitors
        const happinessMultiplier=0.7+(st.happiness/143); // Higher happiness = more tourism
        tourismIncome+=Math.floor(baseTourism*size*populationMultiplier*happinessMultiplier);
    }
  }
  
  // 5. Apply tax rate multiplier (taxRate is 0-20, convert to 0.5-1.5 multiplier)
  const taxMultiplier=0.5+(st.taxRate/20); // 10% tax = 1.0x, 20% = 1.5x, 0% = 0.5x
  const totalIncome=Math.floor((residentialIncome+commercialRevenue+industrialRevenue+tourismIncome)*taxMultiplier);
  
  // 6. Improved maintenance (scaled by building level) - INCREASED COSTS
  let totalMaintenance = 0;
  
  // Base building maintenance (increased)
  for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
    const c=st.grid[y][x];
    if (c.type==='road') totalMaintenance+=2; // Increased from 1
    else if (c.type==='residential' && !c.abandoned) {
      const level=c.level||0;
      const levelMultiplier=level===3?2.5:(level===2?1.8:(level===1?1.3:0.5));
      totalMaintenance+=Math.floor(5*levelMultiplier); // Increased from 2
    }
    else if (c.type==='commercial' && !c.abandoned) {
      const level=c.level||0;
      const levelMultiplier=level===3?2.2:(level===2?1.6:(level===1?1.2:0.6));
      totalMaintenance+=Math.floor(8*levelMultiplier); // Increased from 3
    }
    else if (c.type==='industrial' && !c.abandoned) {
      const level=c.level||0;
      const levelMultiplier=level===3?2.0:(level===2?1.5:(level===1?1.1:0.5));
      totalMaintenance+=Math.floor(12*levelMultiplier); // Increased from 5
    }
    else if (c.type && c.type.startsWith('park')) totalMaintenance+=4; // Increased from 2
    else if (c.type==='police') totalMaintenance+=25; // Increased from 10
    else if (c.type==='fire') totalMaintenance+=25; // Increased from 10
    else if (c.type==='school') totalMaintenance+=40; // Increased from 15
    else if (c.type==='hospital') totalMaintenance+=60; // Increased from 20
    else if (c.type==='coal' || c.type==='nuclear' || c.type==='wind') {
      const maint = POWER_PLANT_MAINTENANCE[c.type] || 0;
      totalMaintenance += maint;
    }
  }
  
  // Population-based infrastructure costs (utilities, waste management, etc.)
  const infrastructureCost = Math.floor(st.population * 0.5); // $0.50 per person
  
  // Service operation costs (based on population served)
  let serviceCosts = 0;
  if (st.population > 0) {
    // Police operation cost (scales with population and crime)
    let avgCrime = 0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      avgCrime += st.crime[y][x] || 30;
    }
    avgCrime = avgCrime / (GR_SZ * GR_SZ);
    const policeOpCost = Math.floor(st.population * 0.3 * (1 + avgCrime/100)); // Higher crime = more police costs
    serviceCosts += policeOpCost;
    
    // Fire department operation cost
    const fireOpCost = Math.floor(st.population * 0.2);
    serviceCosts += fireOpCost;
    
    // Education costs (scales with population)
    const educationCost = Math.floor(st.population * 0.4);
    serviceCosts += educationCost;
    
    // Healthcare costs (scales with population and affected by happiness)
    const healthCost = Math.floor(st.population * 0.35 * (1 + (100-st.happiness)/200));
    serviceCosts += healthCost;
  }
  
  // Crime-related expenses (damage, insurance, etc.)
  let crimeExpenses = 0;
  if (st.population > 0) {
    let avgCrime = 0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      avgCrime += st.crime[y][x] || 30;
    }
    avgCrime = avgCrime / (GR_SZ * GR_SZ);
    if (avgCrime > 40) {
      crimeExpenses = Math.floor(st.population * (avgCrime - 40) / 20); // $1 per person per 20 crime points above 40
    }
  }
  
  // Road maintenance (increases with city size and traffic)
  const roadMaintenanceBonus = Math.floor(rdC * 0.1); // Additional cost for extensive road networks
  
  totalMaintenance += infrastructureCost + serviceCosts + crimeExpenses + roadMaintenanceBonus;
  
  const inc=totalIncome, mnt=totalMaintenance;
  st.money+=inc-mnt;
  let hp=70;
  if (st.population>0) {
    const pR=pC/(rC+1); hp+=Math.min(pR*50,15);
    const sR=(poC+fC+sC+hC)/(st.population/100+1); hp+=Math.min(sR*20,10);
    const jR=(cC+iC)/(rC+1); if (jR<0.5) hp-=10; else if (jR>2) hp-=5;
    if (st.money<0) hp-=15;
    // Tax rate affects happiness: 10% is neutral, lower = happier, higher = unhappier
    const taxImpact=(st.taxRate-10)*0.8; // -8 to +8 happiness based on tax rate (0-20%)
    hp-=taxImpact;
    // Factor in crime - calculate average city crime
    let avgCrime=0;
    for (let y=0; y<GR_SZ; y++) for (let x=0; x<GR_SZ; x++) {
      avgCrime+=st.crime[y][x]||30;
    }
    avgCrime=avgCrime/(GR_SZ*GR_SZ);
    // High crime reduces happiness (up to -15 points)
    if (avgCrime>60) hp-=Math.min(15,Math.floor((avgCrime-60)/2));
    else if (avgCrime>40) hp-=Math.min(8,Math.floor((avgCrime-40)/3));
    // Police coverage improves happiness
    if (poC>0 && st.population>0) {
      const policeRatio=poC/(st.population/500+1);
      hp+=Math.min(5,policeRatio*2);
    }
  }
  st.happiness=Math.max(0,Math.min(100,Math.floor(hp)));
  const dmd=calcDmd(rC,cC,iC,st.population); st.rDemand=Math.floor(dmd.rDemand); st.cDemand=Math.floor(dmd.cDemand); st.iDemand=Math.floor(dmd.iDemand);
  const tB=rC+cC+iC+pC+poC+fC+sC+hC;
  if (st.ticksSinceNews>=20 && tB>5 && !aiReq) { st.ticksSinceNews=0; genNws(); }
    if (Math.random()<0.02 && tB>10) startFire();
    if (Math.random()<0.01 && tB>20) startQuake();
    if (Math.random()<0.02 && st.population>50) startCrimeEvent();
    ensureEmergencyCoverage();
    updFires(); updCrimeEvents(); drGr(); updUI(); updateStatsPanel(); sv();
}

// ===== Audio =====
const aC=new (window.AudioContext||window.webkitAudioContext)();
function plySnd(t) {
  const n=aC.currentTime;
  if (t==='place') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); }
  else if (t==='bulldoze') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sawtooth'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(200,n); g.gain.setValueAtTime(0.15,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); }
  else if (t==='click') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(600,n); g.gain.setValueAtTime(0.08,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.05); o.start(n); o.stop(n+0.05); }
  else if (t==='error') { const o=aC.createOscillator(), g=aC.createGain(); o.type='square'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(300,n); o.frequency.setValueAtTime(200,n+0.1); g.gain.setValueAtTime(0.1,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); }
  else if (t==='fire') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(700,n); o.frequency.setValueAtTime(500,n+0.15); o.frequency.setValueAtTime(700,n+0.3); o.frequency.setValueAtTime(500,n+0.45); g.gain.setValueAtTime(0.06,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.6); o.start(n); o.stop(n+0.6); }
  else if (t==='crime') { const o=aC.createOscillator(), g=aC.createGain(); o.type='sine'; o.connect(g); g.connect(aC.destination); o.frequency.setValueAtTime(800,n); o.frequency.setValueAtTime(600,n+0.12); o.frequency.setValueAtTime(800,n+0.24); o.frequency.setValueAtTime(600,n+0.36); o.frequency.setValueAtTime(800,n+0.48); g.gain.setValueAtTime(0.06,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.6); o.start(n); o.stop(n+0.6); }
  else if (t==='earthquake') {
    // Low rumble
    const o1=aC.createOscillator(), g1=aC.createGain();
    o1.type='sine'; o1.connect(g1); g1.connect(aC.destination);
    o1.frequency.setValueAtTime(80,n);
    o1.frequency.exponentialRampToValueAtTime(30,n+1.5);
    g1.gain.setValueAtTime(0.25,n);
    g1.gain.exponentialRampToValueAtTime(0.001,n+1.5);
    o1.start(n); o1.stop(n+1.5);
    
    // Mid rumble for more impact
    const o2=aC.createOscillator(), g2=aC.createGain();
    o2.type='sine'; o2.connect(g2); g2.connect(aC.destination);
    o2.frequency.setValueAtTime(150,n);
    o2.frequency.exponentialRampToValueAtTime(60,n+1.5);
    g2.gain.setValueAtTime(0.15,n);
    g2.gain.exponentialRampToValueAtTime(0.001,n+1.5);
    o2.start(n); o2.stop(n+1.5);
  }
}

if (!ld()) { initGr('balanced'); st.newsEvents=['Welcome to '+st.cityName+'!']; }
if (!st.zoom) st.zoom=1;
if (st.disastersEnabled === undefined) st.disastersEnabled = true;
const disastersToggleEl = document.getElementById('disastersToggle');
if (disastersToggleEl) {
  disastersToggleEl.checked = st.disastersEnabled;
  disastersToggleEl.addEventListener('change', (e) => {
    st.disastersEnabled = e.target.checked;
    updateDisasterButtonsVisibility();
    sv();
  });
}
updateDisasterButtonsVisibility();
applyZoom();
drGr(); updUI(); updNwsTk(); selTl('road');
if (st.speed>0) { TK_INT=st.speed; tkTmr=setInterval(simTk,TK_INT); }

// Center canvas after page is fully loaded
window.addEventListener('load', () => {
  setTimeout(centerCanvas, 100);
});

// Re-center canvas when window is resized
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(centerCanvas, 100);
});

setInterval(() => { if (st.speed>0) { updCars(); drGr(); } },50);

// Building info panel for stat view
function showBuildingInfo(x, y) {
  const c = st.grid[y][x];
  if (!c || c.type === 'empty') return;
  
  const panel = document.getElementById('buildingInfoPanel');
  const title = document.getElementById('buildingInfoTitle');
  const content = document.getElementById('buildingInfoContent');
  
  // Get building icon
  const icon = {
    'residential': 'üè†',
    'commercial': 'üè¢',
    'industrial': 'üè≠',
    'road': 'üõ£Ô∏è',
    'park': 'üå≥',
    'park2': 'üå∏',
    'park3': 'üå≤',
    'park4': 'üåª',
    'police': 'üëÆ',
    'fire': 'üöí',
    'school': 'üè´',
    'hospital': 'üè•'
  }[c.type] || 'üèóÔ∏è';
  
  // Format building name
  const name = c.type.charAt(0).toUpperCase() + c.type.slice(1).replace(/\d+$/, '');
  title.textContent = `${icon} ${name}`;
  
  // Build content
  let statItems = [];
  
  // Size info for multi-tile buildings
  if (c.w > 1 || c.h > 1) {
    statItems.push(statItem('size', `${c.w}√ó${c.h}`));
  }
  
  // Level info for zones
  if (c.type === 'residential' || c.type === 'commercial' || c.type === 'industrial') {
    if (c.abandoned) {
      statItems.push(statItem('status', 'Abandoned', 'text-red-400'));
    } else {
      statItems.push(statItem('level', c.level));
    }
  }
  
  // Age info
  if (c.age !== undefined) {
    const years = Math.floor(c.age / 12);
    statItems.push(statItem('age', `${years} year${years !== 1 ? 's' : ''}`));
  }
  
  // Land value and crime for this tile
  const landValue = st.landValue[y] && st.landValue[y][x] !== undefined ? st.landValue[y][x] : 50;
  const crime = st.crime[y] && st.crime[y][x] !== undefined ? st.crime[y][x] : 30;
  
  if (showLandValueOverlay) {
    const lvColor = landValue >= 80 ? 'text-green-400' : landValue >= 50 ? 'text-yellow-400' : 'text-orange-400';
    statItems.push(statItem('land value', landValue.toFixed(0), lvColor));
  }
  
  if (showCrimeOverlay) {
    const crimeColor = crime >= 70 ? 'text-red-400' : crime >= 30 ? 'text-yellow-400' : 'text-green-400';
    const crimeLevel = crime >= 70 ? 'High' : crime >= 30 ? 'Medium' : 'Low';
    statItems.push(statItem('crime', `${crimeLevel} (${crime.toFixed(0)})`, crimeColor));
  }
  
  if (statItems.length > 0) {
    content.innerHTML = `<div class="flex flex-wrap gap-6 py-2">${statItems.join('')}</div>`;
  } else {
    content.innerHTML = '';
  }
  panel.classList.remove('hidden');
  
  // Set highlighted building (get full building bounds from top-left corner)
  const bounds = getBuildingBoundsFromCell(x, y);
  highlightedBuilding = {
    x: bounds.startX,
    y: bounds.startY,
    w: bounds.w,
    h: bounds.h
  };
  drGr(); // Redraw to show highlight
}

function hideBuildingInfo() {
  const panel = document.getElementById('buildingInfoPanel');
  panel.classList.add('hidden');
  highlightedBuilding = null;
  drGr(); // Redraw to remove highlight
}
</script>
</body>
</html>

